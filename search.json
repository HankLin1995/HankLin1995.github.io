[{"title":"CADVBA教學(一)","url":"/posts/558703190/","content":"前言\r\n一般提到CAD大多數都以為是AutoCAD，但其實CAD版本有好多好多種，只是因為學校通常都先教AutoCAD進行使用，透過教育版的免費制度培養一票AutoCAD的粉絲，在習慣介面之後跳往其他版本的CAD會有點障礙，但因為AutoCAD在後期大多改成訂閱制，導致很多公司行號轉往其他管道使用，筆者所在的機關目前也是使用ProgeCAD作為主力使用。\r\n關於CAD的版本:\r\n\r\nAutoCAD(訂閱制)\r\nZWCAD(中資成分被禁用)\r\nProgeCAD(買斷制)\r\n\r\n如果基本的操作功能不敷使用導致效率低落時，可以透過CAD本身提供的套件進行額外強化，而VBA則是提供套件之一，筆者自2018年起便開始進行AutoCADVBA相關開發，特別介紹啟蒙導師為馬克的營建與電腦，當初就是被他的Excel自動繪製縱坡圖表吸引到，而開始一系列的研究之路。\r\n本系列文主要是介紹筆者在CADVBA上的心路歷程，希望能夠由淺入深，期待各位讀者吸收後也能具備修改VBA程式碼的能力，優化自身工作流程，藉由節省下來的時間來開發更多好用的工具，良性循環。\r\n\r\nVBA環境建立\r\nAutoCAD\r\n自2012年起，不再預設安裝於AutoCAD，如果需要使用時要到官網下載安裝。\r\n官方VBA下載點\r\nProgeCAD\r\n內建於裡面，但屬性及方法仍不像AutoCAD那麼完整，有時候請原廠修復時也比較會拖，需要透過修改演算法進行問題排除。\r\n不同版本間的CAD開發\r\nExcel與CAD連接方法\r\nExcel是大部分工程人員最常接觸的工具，Excel作為資料進出的主要操作媒介，同時也具備VBA的功能，能夠將CAD作為引用項目進行連動，資料就能透過Excel與CAD連接，驅動CAD進行圖說繪製。\r\n先期引用\r\n\r\nExcel&gt;檔案&gt;選項&gt;自訂功能區&gt;開發人員勾選\r\n\r\n\r\n\r\nFig1. 開發人員選單\r\n\r\n\r\n開發人員&gt;檢視程式碼&gt;工具&gt;設定引用項目&gt;找到相關的套件勾選\r\n\r\n\r\n\r\nFig2. 引用項目勾選\r\n\r\n若以ProgeCAD2021版為例，會找到ProgeCAD 2021 Object\r\nLibrary，這個就是引用對象，不同年代版本對應到的名稱會不同，這是他比較麻煩的地方。\r\n後期引用\r\n透過函數的引用可以直接操作CAD，達成在VBA中進行資料傳遞到CAD的作用，並驅動CAD提供的函數進行點、線、面、文字等等基本操作。\r\npublic mo &#x27;模型空間public pa &#x27;配置空間public acadDoc &#x27;操作工具類函數Sub CADInit()On Error Resume NextSet acadApp = GetObject(, &quot;AutoCAD&quot;) If Err &lt;&gt; 0 Then Set acadApp = CreateObject(&quot;AutoCAD&quot;)acadApp.Visible = TrueOn Error GoTo 0Set mo = acadApp.ActiveDocument.ModelSpaceSet pa = acadApp.ActiveDocument.PaperSpaceSet acadDoc = acadApp.ActiveDocumentEnd Sub\r\n踩雷過程\r\n\r\nAutoCAD用先期引用時，會因為各主機安裝版本不同導致出現錯誤，需要進入程式碼編輯器中勾選正確版本的引用項目，並取消遺漏的引用項目，不然會導致程式碼出現不可解釋的錯誤行為。\r\nProgeCAD只能透過先期引用，後期引用會失效，操作部分物件內容時會失效，我遇到的是Library物件的操作會出現問題，Library物件的CreatePoint方法與點資料密切關連，不可避免，後來透過明確的先期引用引入就可以了。\r\n物件瀏覽是在查詢對象的屬性及方法必備工具，需要有引用才有辦法顯示ProgeCAD相關物件，引用的名稱叫做IntelliCAD，如要採用後期引用時，傳送給其他人時要記得取消勾選。\r\n\r\n相關文章\r\n\r\nAutoCADVBA學習資源\r\nVBA引用項目問題\r\n\r\n","categories":["基本原理"],"tags":["AutoCAD VBA","ProgeCAD VBA"]},{"title":"土方計算-方格法(VBA)","url":"/posts/4262718496/","content":"🙌前言\r\n本篇主要介紹利用 AutoCAD VBA 的物件操作+\r\nExcel VBA\r\n的工作表函數來簡化平坦地貌收方作業的過程。\r\n\r\n土方計算是工程施作時有關於甲乙方針對土方數量時的重要依據，分為小型工程及大型工程來討論。\r\n\r\n小型工程\r\n土方金額佔比不高的情況下，通常契約數量多少就多少，甲乙雙方不太會有意見。\r\n大型工程\r\n土方金額佔比高的情況下，甲乙雙方會針對設計原始地貌進行收方作業並作成土方報告，並以此作為契約數量修正的依據，再根據結構體的設計高程及圖說指定的開挖方式重新計算挖填方數量。\r\n計算方法選定\r\n地形模型的建立會根據地貌狀況而定\r\n\r\n具有複雜地形特徵的地區，使用TIN(不規則三角網)\r\n地形變化相對平緩的地區，使用DEM(數字高程模型)\r\n\r\n方格法便是使用DEM的概念，透過每個方格頂點計算方格平均高程後推算求得土方體積，高程頂點則利用IDW(反距離加權法)來進行高程賦值，插值過程會需要大量的基本運算。\r\n\r\n有關不規則三角網另請參考筆者前文 CAD\r\nVBA@收方作業(不規則三角網法)\r\n\r\n\r\n🎬影片操作\r\n\r\n\r\n\r\n有收方作業的需求歡迎透過左方側邊欄內容聯繫E-mail或LINE進行諮詢。\r\n\r\n👉實現邏輯\r\n建立測量點(影片未出現)\r\n可以將GPS或全測站所拿到的高程點匯出成CSV檔案再放置於Excel會比較快，如果收到的檔案已經是CAD圖也可以，圖塊的點資料可以萃取出他的XY座標，Z座標則通常會放置於圖塊屬性中，這需要看個案圖塊內容解決。\r\n\r\n將設計圖面所記錄的高程點放入工作表(\"DESIGN\")\r\n\r\n\r\n\r\nFig1. 設計圖面高程\r\n\r\n\r\n將收方作業所記錄的高程點放入工作表(\"CHECK\")\r\n\r\n\r\n\r\nFig2.收方作業高程\r\n\r\n\r\n\r\n\r\n欄位名稱\r\n用途說明\r\n\r\n\r\n\r\n\r\nNum\r\n點名稱\r\n\r\n\r\nX\r\nTWD97-E座標\r\n\r\n\r\nY\r\nTWD97-N座標\r\n\r\n\r\nZ\r\n高程\r\n\r\n\r\nLength\r\n與頂點的距離\r\n\r\n\r\n\r\n此處的Length會由每一點去與range(\"F1\")、range(\"G1\")進行距離換算(IDW使用)\r\n繪製點位(0608更新)\r\n填寫完\r\nDESIGN工作表及CHECK工作表時，可以確認一下邊界是否符合設定範圍，此時可以點選按鈕\"繪製點位\"來檢核實際點資料坐落於CAD中的何處。\r\n\r\n\r\nFig2-1.繪製點位成果\r\n\r\n建立方格\r\n\r\n取得計畫範圍之後，找出其邊界位置\r\n方格會在邊界內依序繪製並與計畫範圍判釋兩多邊形位置關係\r\n位置關係可分為下列三種\r\n\r\n計畫範圍外&gt;&gt;刪除\r\n計畫範圍內&gt;&gt;保留不動\r\n計畫範圍與之相交&gt;&gt;另外建立計畫範圍外部面積\r\n\r\n\r\n\r\n計畫範圍與之相交可能會有小問題，需要針對錯誤地方進行-BO增加方格邊界線或刪除錯誤方格\r\n\r\n方格編號及面積\r\n\r\n框選所有方格及外部面積\r\n方格由左上到右下依序編號\r\n計算外部面積形心到所有方格的位置並指定其歸屬哪個方格\r\n由指定內容進行面積扣除\r\n\r\n\r\n\r\nFig3.方格資料主要頁面\r\n\r\n\r\n\r\n\r\n欄位名稱\r\n用途說明\r\n\r\n\r\n\r\n\r\nNum\r\n方格編號\r\n\r\n\r\nGrid_Handle\r\n方格在CAD中的連接碼\r\n\r\n\r\nCentroid_X\r\n方格形心X座標\r\n\r\n\r\nCentroid_Y\r\n方格形心Y座標\r\n\r\n\r\nDESIGN\r\n平均頂點設計高程\r\n\r\n\r\nCHECK\r\n平均頂點收方高程\r\n\r\n\r\nVolume\r\n土方體積\r\n\r\n\r\n\r\n方格頂點計算插值\r\n\r\n匯出所有方格不重複頂點\r\n針對每個頂點進行IDW插值\r\n搜尋半徑預設為方格大小，計算點數預設為3點\r\n如頂點因為高程點的分布關係無法滿足上述條件則插值為0\r\n\r\n\r\n\r\nFig4.方格頂點資料\r\n\r\n方格土方體積計算\r\n\r\n透過Grid_Handle連接該方格在CAD中的各頂點\r\n將各頂點與設計高程座標比對計算該方格平均頂點設計高程\r\n將各頂點與收方高程座標比對計算該方格平均頂點收方高程\r\n由平均收方高程扣除平均設計高程與方格面積進行相乘求得方格土方體積\r\n\r\n土方報告\r\n將上述計算成果放入工作表(\"REPORT\")\r\n\r\n\r\nFig5.土方計算書\r\n\r\nVBA工具連結\r\n上述基本功能有需要可以參考下方連結，操作上有問題可至LINE官方帳號提問。\r\n🔗土方計算(方格法)VBA操作檔案+完整原始碼\r\n\r\n可視化呈現(開發中)\r\n方格可以透過建立3D\r\nBOX的方式進行可視化呈現，因為高程的差異只有一點點，所以還是需要將高程倍數放大讓使用者可以更清楚掌握細節。\r\n\r\n\r\nFig6.土方高程差可視化呈現\r\n\r\n除了以柱狀體方式呈現以外，也可以透過Hatch的顏色差異進行挖方填方的判釋，比如說挖方區域就給綠色，填方區域就給紅色。\r\n👨‍🏫幾何圖學判釋\r\n\r\n整體還有很多實現細節可以進去程式碼裡面看!\r\n\r\n判斷點跟多邊形的關係\r\nFunction IsPointInPolygon(X, Y, poly() As Double) As Boolean    &#x27; Check if a point is inside a polygon.    &#x27; Args:    &#x27;   x: X coordinate of the point.    &#x27;   y: Y coordinate of the point.    &#x27;   poly: An array representing the vertices of the polygon.    &#x27; Returns:    &#x27;   True if the point is inside the polygon, False otherwise.    Dim i As Integer, j As Integer    Dim numVertices As Integer    Dim oddNodes As Boolean    numVertices = UBound(poly) \\ 2 + 1    &#x27; Check if the point is inside the polygon using the ray-casting algorithm    j = numVertices - 1    oddNodes = False    For i = 0 To numVertices - 1        If (poly(2 * i + 1) &gt; Y) &lt;&gt; (poly(2 * j + 1) &gt; Y) Then            If (poly(2 * j + 1) - poly(2 * i + 1)) &lt;&gt; 0 Then                If X &lt; (poly(2 * j) - poly(2 * i)) * (Y - poly(2 * i + 1)) / (poly(2 * j + 1) - poly(2 * i + 1)) + poly(2 * i) Then                    oddNodes = Not oddNodes                End If            End If        End If        j = i    Next i    &#x27; Check if the point is exactly on a vertex or an edge    For i = 0 To numVertices - 1        j = (i + 1) Mod numVertices        &#x27; Check if the point is on a vertex        If X = poly(2 * i) And Y = poly(2 * i + 1) Then            IsPointInPolygon = True            Exit Function        End If        &#x27; Check if the point is on an edge        If ((poly(2 * i + 1) &lt;= Y And Y &lt;= poly(2 * j + 1)) Or (poly(2 * j + 1) &lt;= Y And Y &lt;= poly(2 * i + 1))) And _           (X &lt;= myMax(poly(2 * i), poly(2 * j))) And (poly(2 * j + 1) - poly(2 * i + 1) &lt;&gt; 0) Then            If X = (poly(2 * j) - poly(2 * i)) * (Y - poly(2 * i + 1)) / (poly(2 * j + 1) - poly(2 * i + 1)) + poly(2 * i) Then                IsPointInPolygon = True                Exit Function            End If        End If    Next i    IsPointInPolygon = oddNodesEnd Function\r\n判斷多邊形的位置關係\r\nFunction PolygonsRelation(poly1() As Double, poly2() As Double) As String    &#x27; Check relation between two closed polygons.    &#x27; Args:    &#x27;   poly1: An array representing the vertices of the first closed polygon.    &#x27;   poly2: An array representing the vertices of the second closed polygon.    &#x27; Returns:    &#x27;   String indicating the relation between two polygons:    &#x27;     - &quot;Disjoint&quot;: If polygons are disjoint.    &#x27;     - &quot;Contains&quot;: If poly1 contains poly2.    &#x27;     - &quot;Contained By&quot;: If poly2 contains poly1.    &#x27;     - &quot;Overlap&quot;: If polygons overlap.        Dim i As Integer, j As Integer    Dim numVertices1 As Integer, numVertices2 As Integer    Dim containsPoly1 As Boolean, containsPoly2 As Boolean    Dim intersects As Boolean    Dim X As Double    Dim Y As Double    numVertices1 = UBound(poly1) \\ 2 + 1    numVertices2 = UBound(poly2) \\ 2 + 1        &#x27; Check if one polygon is completely contained in the other    containsPoly1 = False    containsPoly2 = False    For i = 0 To numVertices1 - 1 &#x27;檢查點資料是否在poly2裡面        If IsPointInPolygon(poly1(2 * i), poly1(2 * i + 1), poly2) Then            containsPoly1 = True            Exit For        End If            Next i        For j = 0 To numVertices2 - 1 &#x27;檢查點資料是否在poly1裡面        If IsPointInPolygon(poly2(2 * j), poly2(2 * j + 1), poly1) Then            containsPoly2 = True            Exit For        End If    Next j        &#x27; Check if polygons are disjoint    If Not containsPoly1 And Not containsPoly2 Then        intersects = False        For i = 0 To numVertices1 - 1            For j = 0 To numVertices2 - 1                If DoIntersect(poly1(2 * i), poly1(2 * i + 1), poly1((2 * ((i + 1) Mod numVertices1))), poly1((2 * ((i + 1) Mod numVertices1)) + 1), _                               poly2(2 * j), poly2(2 * j + 1), poly2((2 * ((j + 1) Mod numVertices2))), poly2((2 * ((j + 1) Mod numVertices2)) + 1)) Then                    intersects = True                    Exit For                End If            Next j            If intersects Then Exit For        Next i        If Not intersects Then            PolygonsRelation = &quot;Disjoint&quot;            Exit Function        End If    End If        &#x27; Check for containment    If containsPoly1 And containsPoly2 Then        PolygonsRelation = &quot;Overlap&quot;    ElseIf containsPoly1 Then        PolygonsRelation = &quot;Contains&quot;    ElseIf containsPoly2 Then        PolygonsRelation = &quot;Contained By&quot;    Else        PolygonsRelation = &quot;Overlap&quot;    End IfEnd Function\r\n🎯開發小結\r\n\r\n進行IDW會需要計算距離，建議透過內建函數去執行，不要從VBA算完Length之後再填儲存格，效能差很多。\r\n判定多邊形幾何關係時，需要額外考量四個頂點都在計畫範圍外但是計畫範圍有凸多邊形插在方格中的情形。\r\n電腦計算能力很強的可以將計畫範圍切成5*5的方格，但是還是要考量點資料的密度是否足夠，密度不足會導致很多頂點都是不合理的，程式會自動判釋為0\r\nIDW計算時可以透過Cross\r\nValidation的方式判斷目前模型的合理程度，影響IDW有搜尋半徑、計算最少點數、距離倒數的幕次。\r\n\r\n","categories":["專案成果"],"tags":["AutoCAD VBA","Excel VBA","土方計算"]},{"title":"GroqAPI金鑰取得教學","url":"/posts/3510612144/","content":"前言\r\n大語言模型(LLM)如果要用自己的電腦跑服務倒也不是不行，以現在大多數的地端模型來說要不就很慢，要不就很笨，所以如果要真正將專案導入AI進行使用的話，我的建議還是尋求比較聰明的模型進行API嫁接服務，當然OPENAI也有提供相關的API使用，但就是會需要一筆費用就是了，至於GROQ他就是可以提供比較聰明的開源大語言模型然後反應速度又很快的一家服務商，他所提供的GroqAPI服務有一些基本限制，但若要進行小專案的API串接已經很OK了!\r\n\r\n步驟\r\n進入網站\r\n\r\nhttps://console.groq.com/keys\r\n\r\n點選登入\r\n\r\n\r\nimage\r\n\r\n\r\n小技巧:你也可以登入之後直接輸入上述網站就會到取得金鑰的地方\r\n\r\n支援各種登入方式\r\n\r\n\r\nimage\r\n\r\n\r\nGoogle\r\nGithub\r\n\r\n建立 API key\r\n \r\n取得API Token\r\n\r\n\r\nimage\r\n\r\n完成頁面\r\n\r\n\r\nimage\r\n\r\n\r\n這一串API_TOKEN就可以拿來給其他的程式做使用了!!\r\n\r\n範例\r\n可用模型\r\n\r\n語言模型：\r\n\r\n\r\nllama-3.1-405b-reasoning\r\nllama-3.1-70b-versatile\r\nllama-3.1-8b-instant\r\nllama3-groq-70b-8192-tool-use-preview\r\nllama3-groq-8b-8192-tool-use-preview\r\nllama3-70b-8192\r\nllama3-8b-8192\r\nmixtral-8x7b-32768\r\ngemma-7b-it\r\ngemma2-9b-it\r\n\r\n\r\n語音模型（Whisper）：\r\n\r\n\r\nwhisper-large-v3\r\nwhisper-large-v3-turbo\r\n\r\n\r\n多模態／影像模型：\r\n\r\n\r\nmeta-llama/llama-4-scout-17b-16e-instruct\r\nmeta-llama/llama-4-maverick-17b-128e-instruct\r\n\r\n語音轉文字範例\r\nfrom groq import Groqclient = Groq(api_key=groq_api_key)def transcribe_audio(audio_file):    try:        with open(audio_file, &quot;rb&quot;) as file:            transcription = client.audio.transcriptions.create(                file=file,                model=&quot;whisper-large-v3&quot;,                response_format=&quot;text&quot;,                language=&quot;zh&quot;            )        return transcription    except Exception as e:        print(f&quot;Transcription error: &#123;str(e)&#125;&quot;)        return None\r\n文字任務範例\r\ndef chat_with_model(user_input):    response = client.chat.completions.create(        model=&quot;gemma2-9b-it&quot;,        messages=[            &#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: user_input&#125;        ]    )    return response.choices[0].message.content\r\n","categories":["基本概念"],"tags":["Python","API"]},{"title":"HanksVBA繪圖資料庫操作流程(一)","url":"/posts/3417119485/","content":"前言\r\n主要講述點資料、點群組資料在文字檔、EXCEL檔、CAD圖中互相傳遞的過程，最終希望達成的目標為CAD圖上面的點圖塊及多段線資料。\r\n從取得機器輸出的原始檔之後，會經過載入點資料、展點、整理數據等基本流程直到成為各線段的群組資料為止，以下將會先針對主畫面的區塊進行說明，並且依照各個基本流程的使用情境進行問題解說。\r\n相關的基本流程將包含:\r\n\r\n載入文字檔\r\n展點\r\n整理數據\r\n連線\r\n\r\n主畫面\r\n\r\n\r\nFig1.\r\nHanksVBA繪圖資料庫總表主畫面\r\n\r\n\r\n點資料\r\n\r\n\r\nFig2.\r\nHanksVBA繪圖資料庫點資料\r\n\r\n\r\n\r\n\r\n欄位名稱\r\n說明\r\n\r\n\r\n\r\n\r\nPT_NUM\r\n編號\r\n\r\n\r\nE\r\nX 座標(東座標)\r\n\r\n\r\nN\r\nY 座標(北座標)\r\n\r\n\r\nZ\r\n高程\r\n\r\n\r\nCD\r\n備註\r\n\r\n\r\n\r\n線資料(點群組資料)\r\n\r\n\r\nFig3.\r\nHanksVBA繪圖資料庫線資料\r\n\r\n\r\n\r\n\r\n欄位名稱\r\n說明\r\n\r\n\r\n\r\n\r\nFeature\r\n線屬性\r\n\r\n\r\n\r\n步驟1.載入文字檔\r\n在此僅探討文字檔如何載入至EXCEL檔案中，先假定各位已經能夠順利從機器導出原始資料，各種測量儀器能夠輸出的內容皆大同小異，文字檔通常能夠順利打開，目前有遇過的為CSV、ASC、TXT都是正常的。\r\n流程\r\n\r\n取得原始資料(本案例為CSV檔案)\r\n\r\n\r\n\r\nFig4. 原始資料\r\n\r\n\r\n點選按鈕 載入TXT\r\n點資料自動清空\r\n對話窗會跳出第一行內容，接續請選擇模式\r\n\r\n\r\n\r\nFig5. 選擇模式視窗畫面\r\n\r\n\r\n檢查並清理一下點資料(第二行E、N不應為文字)\r\n完成(詳主畫面點資料)\r\n\r\n\r\nPS:\r\n以TWD97來說，N座標大多為26XXXXX，E座標大多為6碼。\r\n\r\n步驟2.展點\r\n產生點資料前，需確保ProgeCAD目前乃呈現為已開啟並可編輯，其中圖塊部分應已載入Point該項圖塊名稱。\r\n如果要方便，可以直接將20250612-PCAD繪圖模板.dwg開啟，此dwg已包含所有後續繪圖會使用到的設定及圖塊內容。\r\n🔗\r\n繪圖模板下載連結請點我\r\n\r\n流程\r\n\r\n確認CAD已開啟並可進行編輯\r\n點選按鈕展點\r\n輸入文字高度(單位mm)，預設為0.5\r\n\r\n\r\n\r\nFig6. 文字高度視窗畫面\r\n\r\n\r\n跳出通知窗「點物件創立完成!」\r\n移動至CAD查看完成內容\r\n\r\n\r\n\r\nFig7. 點圖塊初步成果!\r\n\r\n\r\nPS:\r\n文字高度需要看測量各點位之間的距離是否會看不清楚，如果需要再將已生成的點圖塊刪除後，重新再點選按鈕生成。\r\n\r\n\r\nPS.2:\r\n移動至CAD後可能會因為基本圖幅過大導致未見點資料內容，可以先透過 ZOOM\r\n指令，選取 E 選項將作用範圍移動至既有資料的邊界。\r\n\r\n\r\nPS.3: CAD中關於點的呈現，可以透過 PTYPE\r\n指令打開選取點顯示線型，目前預設就是一個小點 \r\n\r\n步驟3.整理數據\r\n線資料是由點資料依照CD碼進行分群排序而生，也可稱為點群組資料。點群組內容可指定排序依據進行排序，並且透過線屬性的設定讓線段在繪圖的過程有不同的行為。\r\n排序依據\r\n\r\n\r\n\r\n排序方式\r\n說明\r\n\r\n\r\n\r\n\r\nE\r\n依據 E 欄位排序\r\n\r\n\r\nN\r\n依據 N 欄位排序\r\n\r\n\r\nPT_NUM\r\n依據點位編號排序\r\n\r\n\r\n\r\n線屬性\r\n\r\n\r\n\r\n屬性代碼\r\n說明\r\n\r\n\r\n\r\n\r\n留白\r\n進行連線\r\n\r\n\r\nX\r\n不進行連線\r\n\r\n\r\nA\r\n不進行連線，點位會另外畫圈提示，用於特殊點位標註\r\n\r\n\r\n\r\n流程\r\n\r\n點選按鈕 整理數據\r\n輸入排序依據\r\n\r\n\r\n\r\nFig9. 排序依據顯示畫面\r\n\r\n\r\n根據各個點群組內容首列輸入線屬性\r\n完成\r\n\r\n步驟4.連線\r\n將已經排序完成的點群組資料以及設定完線屬性後的內容繪製於CAD上面。\r\n流程\r\n\r\n點選按鈕 連線\r\n跳出通知窗「連線完成!」\r\n移動至CAD確認成果\r\n\r\n\r\n\r\nFig10. CAD線資料初步成果!\r\n\r\n結語\r\n經歷上述過程便能夠將測量回來的文字資料呈現為較為直觀的圖面資料，透過圖面資料的審查，可以即時的發現是否有某部分的測量點CD碼標註錯誤，此時可以對照該圖塊的點編號即時於點資料內容進行修正進行重新輸出。\r\n點群組的排序順位會直接影響線段的連線品質，故在測量前的工具箱會議建議可以有個良好的規劃，先將今日測量目標先繪製成紙本草圖，針對各線段進行CD碼的命名，每條線段都是基於不同CD碼而生成，測量方式則是有轉彎或有高程變化就需要進行量測才會精準。\r\n如果點資料已經相當混亂，倒也可以捨棄每線不同CD碼的原則，透過你比較舒服的方式進行測量，最後在內業過程手動進行各點的連線也可以，其中要注意連線過程需要用CAD指令PL進行，未來在橫斷面樁取樣只要有交會點就可以進行高程計算了。\r\n","categories":["專案成果"],"tags":["Excel VBA","CAD VBA"]},{"title":"HanksVBA繪圖資料庫操作流程(二)","url":"/posts/1687978399/","content":"前言\r\n承前篇HanksVBA繪圖資料庫操作流程(一)，在點資料與線資料完成之後，已經初步可以看見平面地形圖長相。在帶狀結構的設計中，平面圖上所記載內容為特徵線，如要進行橫斷面的繪製，可以透過中心線的斷面樁來對特徵線做交會分析，透過交會點換算相對中心線的橫向距離，並藉由交會點與特徵線前後相鄰頂點進行高程內插，取得所需地形資訊。\r\n相關的基本流程將包含:\r\n\r\n設定流心\r\n設定樁號\r\n補充樁號\r\n清除樁號\r\n\r\n主畫面\r\n\r\n\r\nFig1. 主畫面\r\n\r\n\r\n步驟5.設定流心\r\n流心即帶狀構造之中心線，可以依照該基地是否進行地籍套繪分成兩種處理方法\r\nA.偏移中心線\r\n在地籍套匯之後，為避免臨田講話，原則將中心線偏移至兩側地籍線中間以求公平，此時就需要在平面地形圖開啟地籍圖層，透過指令PL沿中心點連線。\r\nB.照舊使用\r\n未經地籍套匯，經會議決議為照舊使用，則需將既有渠道之兩側渠底或兩側渠頂皆按實量回來，再透過以下流程進行流心繪製，繪製完畢後檢查起點及終點，做適當的延伸操作。\r\n流程\r\n\r\n點選按鈕設定流心\r\n\r\n\r\n\r\nFig2. 平面圖工具畫面\r\n\r\n\r\n輸入流心連線距離\r\n點選按鈕生成流心\r\n移動至CAD\r\n選擇第一條邊界，按下Enter\r\n選擇第二條邊界，按下Enter\r\n確認成果\r\n\r\n\r\n\r\nFig3. 流心連線距離差異比較\r\n\r\n\r\nPS:如果渠道較為蜿蜒，可以設定為5，渠道較為平直，可以設定為20\r\n\r\n\r\nPS.2:中心線生成之後可以作為參考點使用，如果認為點資料生成位置不合理(通常會在轉彎處、起點或終點)，可以刪除點資料進行調整或是手動用指令PL重新描繪也OK\r\n\r\n步驟6.設定樁號\r\n繪製完中心線後，需要透過斷面樁來得到橫斷面的長相，各個樁號的間距50公尺進行。\r\n流程\r\n\r\n\r\nFig4. 平面圖工具畫面\r\n\r\n\r\n輸入起始樁號\r\n輸入橫斷面單邊寬\r\n點選按鈕取得樁號\r\n移動至CAD\r\n選擇中心線\r\n輸入下一個間距\r\n確認成果\r\n\r\n\r\n\r\nFig5. 斷面樁生成結果\r\n\r\n\r\nPS:如果中心線的方向與想像中不同，可以勾選樁號反轉。\r\n\r\n\r\nPS2:下一個間距如果全部都是50公尺為整數樁進行取樣，則輸入50-，後續的樁號就會自動以50作為距離進行。\r\n\r\n\r\n步驟7.補充樁號\r\n一般來說，中心線都會用整數樁的方式進行取樣樁號劃分(0+050.0+100.0+150...等)，但若遇到地形比較有變化的部分，可以再透過補充樁號的過程在該處補上斷面樁，未來無論在構造物設計或計算土方時也會比較精準。\r\n流程\r\n\r\n點選按鈕補充樁號\r\n移動至CAD\r\n點選中心線\r\n輸入生成方式\r\n\r\n點選位置\r\n輸入樁號\r\n\r\n是否要繼續?(Y/N)\r\n輸入N結束\r\n\r\n步驟8.清除樁號\r\n當斷面樁位置異常時，可以透過此步驟進行同步清理圖說與中心線工作表，如果是progeCAD的朋友，建議先用圖層隔離的方式僅顯示斷面樁的圖層會比較好進行框選。\r\n流程\r\n\r\n點選按鈕清除樁號\r\n移動至CAD\r\n框選斷面文字及斷面樁\r\n完成\r\n\r\n結語\r\n經歷上述過程便能夠將中心線的位置、斷面樁的劃分作一個比較良好的規劃，在後續橫斷面、縱斷面的輸出過程時也能夠比較真實的還原地形現況。\r\n目前所遇到的中心線仍然還是用PL所進行繪製的折線，對於工程設計而言，除了折線外還可能會遇到曲線的部分，曲線是一個比較複雜的題目，筆者僅針對簡單的圓曲線有進行VBA程式設計，可以在單曲線定線工具中找到相關的說明，原理也大抵是對圓曲線做折線的擬合。\r\n","categories":["專案成果"],"tags":["Excel VBA","CAD VBA"]},{"title":"HanksVBA繪圖資料庫操作流程(三)","url":"/posts/2604629158/","content":"前言\r\n承前篇HanksVBA繪圖資料庫操作流程(二)，在中心線與斷面樁完成之後，此時就要透過斷面樁與特徵線之間的幾何關係換算其橫向相對座標及高程，計算成果除了可以繪製橫斷面外，同時也能透過萃取出各特徵線上的高程資訊作為縱斷面之資料來源。\r\n相關的基本流程將包含:\r\n\r\n樁號取樣\r\n高程重整\r\n橫斷面圖\r\n擷取CD碼\r\n快速縱斷面\r\n\r\n主畫面\r\n\r\n\r\nFig1. 主要畫面\r\n\r\n\r\n步驟9.樁號取樣\r\n特徵線與斷面樁透過取得其位於斷面樁上各個交點來推算該點距離斷面樁的端點距離以及該點位於特徵線上之前後端點的高程進行內插值換算，進而取得一份具有X、Y、交點CD碼的表格。\r\n\r\n\r\nFig2. 橫斷面基本資料表\r\n\r\n流程\r\n\r\n移動至工作表\"中心線\"\r\n點選按鈕樁號取樣\r\n移動至CAD\r\n框選斷面樁，按下Enter\r\n框選特徵線，按下Enter\r\n成果出現於工作表\"橫斷面\"\r\n\r\n\r\nPS:通常起點、終點比較容易出現有異常，通常是發生於特徵線與斷面樁無法交會的情況，此時可以先透過CAD指令EX將特徵線延長至該斷面樁，再透過按鈕檢查點高程進行線段高程檢查、取近似點處理。\r\n\r\n步驟10.高程重整\r\n除了透過取特徵線高程作為來源外，也能在CAD中透過指令OFFSET建立虛擬特徵線，並且將該虛擬特徵線賦予其要同步的高程來源，以矩形渠道為例，通常只會拿取渠底中心、兩側渠頂作為特徵線使用(目前在橫斷面圖上看起來就像是V字型)，若要正確描述橫斷面圖的長相(U字型)\r\n，還需要透過兩側渠頂的位置往渠底中心偏移複製0.1公分，再透過高程重整的方式將左渠底及右渠底的高程設定等同渠底中心，這樣便能看見一完整的渠道樣式。\r\n\r\n\r\nFig3. 高程重整基本資料表\r\n\r\n流程\r\n\r\n確認橫斷面含有Y值為0的數值\r\n設定高程代碼、取代高程、運算值\r\n點選按鈕高程重整\r\n完成\r\n\r\n步驟11.橫斷面圖\r\n在目前的步驟所產製出來的內容為純地形的橫斷面圖，如果要放置渠道的話需要再透過後續步驟_的渠道型式表設定進行，到時候才有辦法進行挖方、填方的面積計算。\r\n流程\r\n\r\n點選按鈕橫斷面圖\r\n輸入圖紙比例(預設100)\r\n輸入X軸偏移距離(預設10000)\r\n輸入Y軸偏移距離(預設2000)\r\n輸入切換個數(預設100)\r\n判定是否邊界CD碼未設定環境名稱，有的話再輸入該CD對應環境名\r\n移動至CAD\r\n點選繪製基準點\r\n完成\r\n\r\n\r\n\r\nFig4. 橫斷面CAD圖說\r\n\r\n\r\nPS:繪製過程的選項可以都先採用預設，產生初次成果後再透過目前的狀況進行微調，如發現Y軸偏移距離不夠大，就再往上加，如果要放入圖框，則可以將切換個數改為3，他繪製指定數量後就會偏移X軸繪製。\r\n\r\n步驟12.擷取CD碼\r\n每一個橫斷面都會記錄其CD碼，如果要進行坡度設計的時候會需要把每個樁號的重要CD碼繪製於縱斷面上呈現，比較好確認高程相對應關係，要取得其高程資料需要先設定其代碼對應到的高程名稱以及放置於第幾列。\r\n\r\n\r\nFig5. 縱斷面擷取CD碼基本資料\r\n\r\n流程\r\n\r\n設定高程代碼、高程列位、高程名稱\r\n點選按鈕擷取CD碼\r\n資料擷取後送至工作表\"縱斷面\"(目前被隱藏起來)\r\n完成\r\n\r\n\r\nPS:高程名稱的結尾必須為**高，EX:地盤高、路面高，後續再去圖說裡面改\r\n\r\n步驟13.快速縱斷面(Optional)\r\n快速就可以直接看見地盤高與其他相關高程的關係，每條線都是一個圖層。\r\n流程\r\n\r\n點選按鈕快速縱斷面\r\n輸入X軸比例(預設2500)\r\n輸入Y軸比例(預設100)\r\n移動至CAD\r\n輸入取樣間距(預設為1)\r\n點選繪製基準點\r\n完成\r\n\r\n\r\n\r\nFig6. 簡易縱斷面CAD圖\r\n\r\n\r\nPS:取樣間距如果為5.10.15.20.25，設定為1時會全部顯示，設定為2的時候則會依照5.15.25這樣顯示(每2個取一次)。\r\n\r\n結語\r\n在橫斷面圖的繪製過程，除了可以看出目前的地形與周邊的環境資訊(田、路)，也能判定是否有歧異點的發生，來針對地形點錯誤排查，有些時候可能會因為抄錄錯誤或機器輸出的異常，導致橫斷面的長相不合常理，如果在Excel橫斷面表上就發現高程值為0，那麼就得要先確認特徵線是否有經過人為移動或延伸、剪斷等等，這時候透過按鈕檢查點高程通常能解決大多數問題。\r\n當操作完擷取CD碼之後才能進行快速縱斷面，這部分的功能只是讓用戶能夠早點知道縱斷面效果，減少在繪製詳細的縱斷面過程的勞累，在圖說上可以取得地盤高、路面高、田面高...等等關鍵的資訊，設計者可以先在該簡圖上大約繪製計畫高、渠頂高，於此可以先先確認是否會有路面無法排水、田面無法取水等問題，再者，當地形地貌比較複雜時，也能夠將取樣間距設定為10M或5M，當地形特徵點都有按實際取回時，快速縱斷面也能完整的復現實際的地形地貌。\r\n","categories":["專案成果"],"tags":["Excel VBA","CAD VBA"]},{"title":"HanksVBA繪圖資料庫操作流程(五)","url":"/posts/3706799986/","content":"前言\r\n承前篇HanksVBA繪圖資料庫操作流程(四)，我們已經可以繪製比較詳盡的縱斷面圖，接下來要進行的就是配合周邊高程進行計畫高的設計、渠道的斷面尺寸決定，過程需要考量幾個重點:\r\n\r\n渠頂凸出路面造成路面積水。\r\n渠頂不足以支撐路面高，土方崩落問題。\r\n渠道深度過高並且可能有跌落風險時，需額外考量安全措施。\r\n田坵引水灌溉時水頭不足，引水灌溉有困難。\r\n基礎裸露於田面之上，可能會導致基礎淘空。\r\n\r\n假設上述內容皆以考量周全，此時就會有一個適合的渠道尺寸，就能將渠道圖擺設於橫斷面上，進行土方工程的挖填方量計算。\r\n其相關的基本流程為:\r\n\r\n渠道型式表\r\n匯入渠道\r\n橫斷面圖\r\n土方面積\r\n顯示挖填\r\n土石方報表\r\n\r\n主畫面\r\n\r\n\r\nFig1. 渠道型式表主畫面\r\n\r\n\r\n步驟17. 渠道型式表\r\n單位為公尺，輸入尺寸時須確保有涵蓋到縱斷面圖的起點跟終點，尺寸部分有時候會有漸變的型式，此時就要輸入漸變的前後尺寸並且用\r\n~ 進行串聯，左牆如由0.8公尺漸變到1.2公尺可輸入0.8 ~ 1.2。\r\n流程\r\n\r\n輸入渠道名稱\r\n輸入起迄點\r\n輸入渠道型式(A、B、C...等)\r\n設定型式尺寸\r\n\r\n步驟18. 匯入渠道\r\n設定完渠道型式後，需要將渠道放置於橫斷面的某個位置進行佈設，此時會需要指定橫斷面表上所記錄的CD碼作為基準後，將渠道依照中心線及縱斷面上記錄的高程放置。\r\n流程\r\n\r\n移動至工作表\"橫斷面\"\r\n點選按鈕匯入渠道\r\n輸入渠道中心點CD碼名稱\r\n\r\n\r\n\r\nFig2. 渠道中心點CD碼\r\n\r\n4.完成\r\n\r\n\r\nFig3. 橫斷面表(含渠道參數)\r\n\r\n步驟19. 橫斷面圖\r\n匯入渠道完成後，重新產製橫斷面圖的過程會判定橫斷面表上是否具備渠道參數(比如25.458,A)這類的內容後詢問用戶是否要產生挖方、填方內容，橫斷面圖繪製完成後就會將挖方、填方的數字填列到中心線的對應內容，填寫完畢後就能直接產生土方計算書。\r\n流程\r\n\r\n點選按鈕橫斷面圖\r\n輸入圖紙比例(預設100)\r\n輸入X軸偏移距離(預設10000)\r\n輸入Y軸偏移距離(預設2000)\r\n輸入切換個數(預設100)\r\n判定是否邊界CD碼未設定環境名稱，有的話再輸入該CD對應環境名\r\n詢問是否要建立填方線?\r\n\r\n\r\n\r\nFig4. 是否要建立填方線\r\n\r\n\r\n移動至CAD\r\n點選繪製基準點\r\n完成\r\n\r\n\r\n\r\nFig5. 橫斷面圖對照圖\r\n\r\n\r\nPS:左方為不預先建立填方線，右方為預先建立填方線，正常的填方線需要考慮從挖方線與地形線的交會點取水平延伸到渠牆，但若只是概估值，可以先預先建立填方線減少額外框選的工作。\r\n\r\n步驟20. 土方面積\r\n在不預先建立回填線的前提下，需要使用者針對橫斷面圖進行填方線、填方面積邊界線的繪製，如果挖方線繪製不合理時，也會需要使用者進行挖方線、挖方面積邊界線的修正，繪製線段跟邊界線的過程需要遵循指定的圖層名稱，如下表所述:\r\n\r\n\r\n\r\n用途\r\n圖層名稱\r\n\r\n\r\n\r\n\r\n挖方線\r\nCAL\r\n\r\n\r\n填方線\r\nFAL\r\n\r\n\r\n挖方面積\r\n橫斷面-挖方\r\n\r\n\r\n填方面積\r\n橫斷面-填方\r\n\r\n\r\n\r\n流程\r\n\r\n移動至CAD\r\n圖層變更為FAL，繪製填方線\r\n圖層變更為橫斷面-填方，透過指令\"-BO\"點選面積內部點\r\n移動至工作表\"中心線\"\r\n如工作表上的挖填方數據要重算，請先進行刪除!!!\r\n點選按鈕土方面積\r\n移動至CAD，框選剛剛繪製的內容\r\n完成\r\n\r\n\r\n\r\nFig6. 中心線主畫面\r\n\r\n\r\nPS:將具有渠道參數的橫斷面表繪製的過程，至少會在中心線上出現挖方的數據，如果數據都要透過框選來產生時，需要先將工作表上的數據進行刪除，否則系統會在框選完面積之後再加上原本已經有存在的資料，導致面積出現異常。\r\n\r\n\r\nPS.2:框選面積的過程，可以適度的調整圖層的顯示，如要進行挖方面積點選時可以將渠道圖層、中心線圖層先關閉，如要進行填方面積點選時可以將地形線圖層先關閉，會比較好點。\r\n\r\n步驟21. 顯示挖填\r\n橫斷面圖的標題需要出現挖方面積、填方面積以及中心線距離地形線的落差，系統將透過工作表\"中心線\"上所記錄資料填寫至CAD圖上對應到的樁號位置。\r\n流程\r\n\r\n點選按鈕顯示挖填\r\n移動至CAD\r\n框選橫斷面圖的標題(圖層名稱為TITLE)\r\n完成\r\n\r\n\r\n\r\nFig1. 顯示挖填對照圖\r\n\r\n步驟22. 土石方報表\r\n報表範本位於某張隱藏資料表-土石方報表，如要修改內容可以先進行取消隱藏後修正再回復隱\r\n流程\r\n\r\n點選按鈕報表\r\n完成\r\n\r\n\r\n\r\nFig1. 土石方報表\r\n\r\n結語\r\n本篇主要在介紹關於渠道擺設於橫斷面圖上的過程，雖然流程不是很複雜，但數量多的時候會造成繪製人員出現職業倦怠，尤其是將資料從工作表謄寫到CAD圖上的過程，相當容易出現錯誤，即便對於工程人員而言，這一點點土方工作根本不是什麼大錢，但錯誤總是會被某些人找出來然後叫你改，為了減少這類情況發生，善用工具將謄寫資料的過程簡單化是很有幫助的。\r\n截至目前一系列的操作已經可以完整的產生平面圖、橫斷面圖、縱斷面圖，再來就是要開始進行標準斷面的設計以及最重要的擺設圖框、批次出圖，這部分留待後續說明，關於繪圖資料庫已經可以先告一段落，後續談到圖框時才會繼續使用。\r\n","categories":["專案成果"],"tags":["Excel VBA","CAD VBA"]},{"title":"HanksVBA繪圖資料庫操作流程(四)","url":"/posts/3761000123/","content":"前言\r\n承前篇HanksVBA繪圖資料庫操作流程(三)，我們已經可以得知橫斷面地形的樣貌以及初步的縱斷面圖高程相對關係，接著就是針對縱斷面圖的圖表區進行更詳細的坡度設計以及渠道樣式的幾何尺寸擇定，後續將設計成果放回到橫斷面圖上的絕對高程後就可以開始進行比較繁瑣的土方計算框選、計算。\r\n相關的基本流程將包含:\r\n\r\n取得資料\r\n取得坡度\r\n縱斷面圖\r\n\r\n主畫面\r\n\r\n\r\nFig1. 主畫面\r\n\r\n\r\n步驟14.取得資料\r\n透過之前的操作，目前會有一些基本資料存在隱藏的工作表\"縱斷面\"之中，此時透過取得資料的操作可以將標題為樁號、地盤高、各式高程的資料匯入\"縱斷面繪圖\"的工作表，減少之前人為複製貼上的繁瑣步驟。\r\n流程\r\n\r\n確認按鈕擷取CD碼已被操作\r\n點選按鈕取得資料\r\n完成\r\n\r\n步驟15.取得坡度\r\n縱斷面資料表會先引入基本的樁號、單距、高程，此時用戶只要決定設計起始點、說明而已，設計起始點會有三種型式(S:起點，向右半圓、C:轉折，整個圓、E:終點，向左半圓)，有出現S標示的時候就必須要出現E標示，每個樁號所對應到的標示都會特別做高程標記並呈現於坡度表上。\r\n流程\r\n\r\n確定有建立設計起始點標記\r\n點選按鈕取得坡度\r\n輸入是否要刪除計畫高\r\n輸入起點高程\r\n自動換算起點高程至下一個標記的地盤高的適合坡度\r\n輸入使用坡度，完成\r\n\r\n\r\n\r\nFig2. 坡度對話窗\r\n\r\n\r\nPS:一般來說，整數樁的部分不用特別再打說明，非整數樁部分會需要說明一下，比如可能是有水路流入或流出、構造物之類。\r\n\r\n步驟16.縱斷面圖\r\n可以先用預設的參數內容繪製一次後，再根據你的需求進行參數微調，包含大小、間隔等等，主要需要注意的是樁號形式，如為公路工程大多會需要修改為0K+000。\r\n\r\n\r\nFig3. 縱斷面參數調整畫面\r\n\r\n流程\r\n\r\n點選按鈕縱斷面圖\r\n跳出縱斷面繪圖參數表單\r\n點選按鈕繪製縱斷面圖\r\n移動至CAD\r\n點選繪圖基準點\r\n完成\r\n\r\n\r\n\r\nFig4. 縱斷面成果\r\n\r\n結語\r\n縱斷面圖的繪製包含兩個區域，表格區與繪圖區，如果需要呈現於表格區的部分，需要將欄位新增到坡降列的上方，如果需要呈現於繪圖區的部分，需要將列名更改為OO高，此時就會繪製到繪圖區中。\r\n\r\n河川局的案例如下 \r\n\r\n只要會打字，基本的列名稱(樁號、坡降、設計起始點、說明)都有進行輸入，列名稱有預計要繪圖的部分有設定為OO高，他就會正常繪製出縱斷面圖，不需要依賴按鈕進行也可以操作，算是相當開放的一套填寫介面，任何的公式都可以插入進去。\r\n相關舊文章\r\nAutoCAD VBA\r\n縱斷面繪製自動化-1\r\n","categories":["專案成果"],"tags":["Excel VBA","CAD VBA"]},{"title":"LINE機器人自動備份群組照片","url":"/posts/3782846762/","content":"前言\r\n在執行工程時，經常會為了聯絡相關事宜建立LINE群組來進行交談，通常施工照片也會在這個群裡面進行上傳讓大家可以確認內容，上傳照片到LINE群組的時候除了直接上傳外，也可以透過建立相簿將照片永久保存。\r\n在LINE群組的檔案機制，照片或文件會有一定時間的存活期，當過了存活期之後照片就會呈現無法下載的情形，因此將照片做一個額外存放的動作算是滿重要的一個手段，而這件事除了繁瑣也很可能會因為再次請求上傳的過程多存了不少張重複的照片，而這個部分相信大多數人都是透過人眼來進行判別，火眼金睛用久也是會累的。\r\n\r\n希望能夠打造一個當群組內判定到照片資料時，能夠自動備份到指定硬碟並汰除重複照片的機器人，減少這些瑣事的發生。\r\n\r\n至於照片後續要進行處理就可以利用施工照片VBA進行資料排序、批次改名、報表輸出。\r\n\r\n操作畫面\r\n\r\n\r\nFig1.LINE群組畫面\r\n\r\n\r\n\r\nFig2.本地端儲存畫面\r\n\r\n基本工具\r\n\r\nLINEBOT\r\n\r\nMessengerAPI\r\n\r\nngrok\r\n\r\n主要是用來建立https連線給LINEBOT的webhook使用\r\n\r\npython\r\n\r\nflask\r\nlinebotsdk\r\n\r\n\r\n相關連結\r\n\r\nLINEBOT基本建立\r\nngrok\r\n本地端使用ngrok\r\n\r\n實作邏輯\r\n預先準備內容\r\n\r\n建立flask並啟用app\r\n啟用ngrok\r\n複製將ngrok上面的對外連線IP\r\n貼到LINEBOT的webhook\r\n\r\n訊息接收過程\r\n\r\nLINEBOT在接受到群組內的訊息時\r\n判定訊息屬性是否為Image\r\n圖片內容會先暫時放在LINE機房並且生成一組token\r\n收到訊息的同時會執行API(Webhook機制)\r\nAPI中會將訊息做過濾，藉由token取得照片到本地端\r\n本地端資料庫會記錄已經存放的照片跟Image_hash\r\n判定是否有重複的image_hash，如有則回傳\"圖片已存在\"\r\n通過重複汰除機制過濾完成後可將照片存放到指定位置\r\n\r\n程式碼\r\nwebhook\r\n\r\napp_local.py\r\n\r\n# 存放在本地端sqlite+本地端硬碟from flask import Flask, request, abortfrom linebot import LineBotApi, WebhookHandlerfrom linebot.exceptions import InvalidSignatureErrorfrom linebot.models import MessageEvent, ImageMessage, TextSendMessageimport osimport uuidimport hashlibfrom sql_utils import get_db, save_photo_to_db, is_image_hash_existapp = Flask(__name__)# 設定你的 Channel Access Token 和 Channel SecretCHANNEL_ACCESS_TOKEN = &#x27;YOUR_CHANNEL_ACCESS_TOKEN&#x27;CHANNEL_SECRET = &#x27;YOUR_CHANNEL_SECRET&#x27;line_bot_api = LineBotApi(CHANNEL_ACCESS_TOKEN)handler = WebhookHandler(CHANNEL_SECRET)PHOTOS_DIR = &#x27;photos&#x27;if not os.path.exists(PHOTOS_DIR):    os.makedirs(PHOTOS_DIR)@app.route(&quot;/callback&quot;, methods=[&#x27;POST&#x27;])def callback():    # 獲取 X-Line-Signature header    signature = request.headers[&#x27;X-Line-Signature&#x27;]        # 獲取請求體    body = request.get_data(as_text=True)    try:        handler.handle(body, signature)    except InvalidSignatureError:        abort(400)    return &#x27;OK&#x27;@handler.add(MessageEvent, message=ImageMessage)def handle_image_message(event):    # 獲取圖像內容    message_content = line_bot_api.get_message_content(event.message.id)    image_data = message_content.content    image_hash = calculate_image_hash(image_data)    user_id = event.source.user_id    group_id = event.source.group_id    photo_properties = &#123;&quot;edit&quot;: &quot;false&quot;&#125;    photo_url=None    with next(get_db()) as db:        # 檢查圖片是否已存在        if is_image_hash_exist(db, image_hash):            reply_text = &quot;圖片已存在，未保存。&quot;        else:            # 保存圖片到本地資料夾            file_name = str(uuid.uuid4()) + &#x27;.jpg&#x27;            file_path = os.path.join(PHOTOS_DIR, file_name)            with open(file_path, &#x27;wb&#x27;) as f:                for chunk in message_content.iter_content():                    f.write(chunk)            # 保存圖片到資料庫            saved_photo = save_photo_to_db(db, user_id, group_id, file_name, photo_url, photo_properties, image_hash)            print(&quot;Photo saved successfully:&quot;, saved_photo)            reply_text = &quot;圖片已保存到本地端！&quot;    line_bot_api.reply_message(        event.reply_token,        TextSendMessage(text=reply_text)    )def calculate_image_hash(image_data):    hasher = hashlib.sha256()    hasher.update(image_data)    return hasher.hexdigest()@handler.add(MessageEvent)def handle_message(event):    if not isinstance(event.message, ImageMessage):        reply_text = &quot;請傳送圖片訊息。&quot;        line_bot_api.reply_message(            event.reply_token,            TextSendMessage(text=reply_text)        )if __name__ == &quot;__main__&quot;:    app.run(host=&quot;0.0.0.0&quot;, port=8000)\r\n\r\nsql_utils.py\r\n\r\nfrom sqlalchemy import create_engine, Column, Integer, String, DateTime, JSONfrom sqlalchemy.orm import sessionmaker,declarative_basefrom datetime import datetimefrom sqlalchemy.orm import SessionDATABASE_URL=&quot;sqlite:///photos.db&quot;engine = create_engine(DATABASE_URL)Base = declarative_base()SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)# 定義數據庫模型class Photo(Base):    __tablename__ = &#x27;photos_backup&#x27;    id = Column(Integer, primary_key=True, index=True)    user_id = Column(String)    group_id = Column(String)    photo_name = Column(String)    photo_url = Column(String)    photo_thumbnail_url = Column(String)    created_time = Column(DateTime, default=datetime.utcnow)    photo_properties = Column(JSON)    photo_image_hash = Column(String)#, unique=True, nullable=False)Base.metadata.create_all(bind=engine)# 獲取數據庫會話def get_db():    db = SessionLocal()    try:        yield db    finally:        db.close()def save_photo_to_db(db, user_id,group_id, photo_name, photo_url, photo_properties,image_hash):    new_photo = Photo(        user_id=user_id,        group_id=group_id,        photo_name=photo_name,        photo_url=photo_url,        photo_properties=photo_properties,        photo_image_hash=image_hash    )    db.add(new_photo)    db.commit()    db.refresh(new_photo)    return new_photodef get_photo_by_id(db: Session, photo_id: int):    return db.query(Photo).filter(Photo.id == photo_id).first()def fetch_all_photos(db: Session):    return db.query(Photo).all()def delete_photo_from_db(db: Session, photo_id: int):    photo = db.query(Photo).filter(Photo.id == photo_id).first()    if photo:        db.delete(photo)        db.commit()        print(f&quot;Photo with ID &#123;photo_id&#125; deleted successfully from database.&quot;)    else:        print(f&quot;No photo found with ID &#123;photo_id&#125;.&quot;)def is_image_hash_exist(db, image_hash):    return db.query(Photo).filter(Photo.photo_image_hash == image_hash).first() is not None\r\n結語\r\n如果您本身執行工程專案時有大量的照片需要進行自動備份，同時又有一台電腦可以不關機當作server用途，可以將他建立好python執行環境並參考上述的內容搭配使用，如有不懂的內容也歡迎聯繫作者來協助架設LINE群組機器人，自動備份工程群組內部照片省時又省力。\r\n","categories":["專案成果"],"tags":["flask","LINEBOT"]},{"title":"PCCES XML 後處理工具線上版","url":"/posts/375550287/","content":"前言\r\n公共工程的預算書編制流程中，PCCES（公共工程預算編制系統）所產出的成果有Excel或XML，Excel檔案最常令人頭痛的問題就是項目名稱過長時容易有文字不連續的問題，要轉移至其他自己編寫的小工具進行利用時需要先將這個文字部分整理後才能進行。以前筆者曾經撰寫過\r\nExcel\r\n版本的 XML 後處理工具，但考量到部分使用者可能沒有安裝\r\nExcel，或是公司資訊部門封鎖了 Excel VBA\r\n的相關功能，因此筆者決定開發一個線上版的工具供大家使用。\r\n此外，這次的開發過程，我也順道利用 ChatGPT\r\n來實作整個專案，並根據 AI 產出的架構逐步調整與優化，測試一下 AI\r\n在程式開發上的能力。\r\n\r\nAI 開發的體驗與觀察\r\n在開發過程中，我將原本的 Excel VBA 程式碼 逐步提供給\r\nChatGPT，並請它轉換成\r\nPython的streamlit套件內容。過程中，我發現 AI\r\n真的發展得相當迅速，但它在開發領域仍有一些限制：\r\n\r\n需求描述仍需人類介入：AI\r\n可以幫助撰寫基本程式，但需求描述不明確時會差那麼一點兒。\r\n\r\n錯誤排除仍需人類判斷：AI\r\n可以提供錯誤修正建議，但是否完全修正很靠運氣，有時會繞了一陣子又回到原本的狀況，這時仍然會需要懂一些基本語法會比較快解決問題。\r\n\r\nAI\r\n可以是寫程式的好夥伴，但要讓它完全取代人類的這個步驟，我想還有一段路要走，好好把握AI能夠解決基本問題的能力，從中加速迭代開發版次會是比較理想的做法，當然也不建議一次就讓AI改好改滿，改到最後你可能會不知道他到底改了什麼，反而把專案弄壞了。\r\n操作方式\r\n\r\n開啟網站 👉 PCCES\r\n後處理工具 V1.0\r\n\r\n上傳 PCCES 產出的 XML 檔案\r\n顯示總表、詳細價目表、單價分析表相關分頁\r\n於詳細價目表分頁可下載 CSV 檔案\r\n\r\n相關畫面\r\n\r\n\r\nFig1.總表\r\n\r\n未上傳XML時，會提醒需要先行上傳才能看到分頁\r\n\r\n\r\nFig2.詳細價目表\r\n\r\n此為監造報表或施工日誌主要填寫的內容依據，下載CSV後可以導入到自己撰寫的小工具\r\n\r\n\r\nFig3.單價分析表\r\n\r\n如要查閱單價分析內容可以進行項目搜尋，如要顯示全部則留白\r\n","categories":["專案成果"],"tags":["Python","PCCES"]},{"title":"創站首篇文章","url":"/posts/2051013919/","content":"🙌前言\r\n自2018年開始撰寫Blogger紀錄工作上會遇到的內容，藉由紀錄的過程也有助於加深對於某項技術的印象。想當初我遇到問題的時候也是不斷Google，受惠於很多網路大神的文章才解決了問題，期許我也能夠成為網路世界中有用的人，撰寫出一些能夠對這個世界有所幫助的文章。\r\n礙於我對於Blogger的調整不是很熟悉，常常影片上傳失敗或分頁的過程會無法完整呈現，有一天當我遇到Hexo-nexT的主題時，驚為天人，這完全就是我理想中的部落格外觀，因此就決定藉由學習一項新的技術的同時也來重建一下以前醜醜的Google\r\nBlogger...\r\n\r\n##🌟 為什麼想要重建一個部落格?\r\n主要原因\r\n\r\nHexo-nexT相當簡潔有力\r\n\r\n於我而言，理想中的部落格就是只要可以介紹我是誰、方便訪客查看文章、留言，這幾項基本功能即可\r\n剛好Hexo的nexT主題可以說是專為這些內容而生的靜態頁面渲染器，內建的文章目錄、可以直接使用markdown語法進行渲染的內容，還有各種留言外掛可供利用，完全符合我的需求。\r\n額外好處\r\n\r\n網站自主權，非常的重要!\r\n\r\nHexo可以在本地端透過hexo-cli套件進行靜態網頁渲染，讓使用者可以儲存原始檔案，不怕有一天服務收掉卻沒有原始檔可以復原。\r\n渲染後的內容要給網路看必須要找個空間進行部署，剛好GitHubPage有提供這項服務，如有購買網域，也可以進行CNAME設定即可擁有自己的官方網站部落格了，是不是很讚!\r\n\r\n⤴️未來文章組成方向\r\n這幾年來做了不少個side\r\nproject，專案執行過程也能有幸與各地網友交流，因為我本身是名工程人員，對於資訊人員所能撰寫的素材，我可以再多融入有關工程上的應用，而這些內容也是眾多網友所關注的內容，包含規劃、設計、監造、工務行政...等。\r\n在此，我很感謝曾經幫助過我的朋友，因為有你們的支持，也才能讓我有動力繼續研究開發。\r\n基本概念\r\n當遇到的問題的時候就知道要去找答案了，這是我在自學的過程中所領悟到的一件事，看過程式碼其實不代表你已經會了，而是必須要把答案寫出來並解決了問題才是真的會了!\r\n\r\n寫程式本身就是一個不斷遇到錯誤、修正錯誤的過程\r\n\r\n我會將解決問題的過程中，那些值得紀錄的基本概念寫在我的部落格中，有一天網路上相遇時能幫助到你我會很開心。\r\n專案開發\r\n寫程式的目標，往往是透過完成小專案合併成一個大專案來解決實務上的問題，懂得拆分需求也是一名好的資訊人員所需要的基本技能，開發過程難免會遇到一些奇怪的問題，但這些問題又偏離基本概念太遠，主要訴求是為了解決專案內容而生，因此這部分為以解決實務上的問題為內容，將我踩過的坑分享給各位同樣遇見該問題的人，而不再多琢磨基本概念。\r\n\r\n專案項目如果能進行良好的拆分並進行單元測試真的很有幫助\r\n\r\n專案成果\r\n\r\n專案完成一定的程度就會需要進行測試，透過實際上的測試，了解專案的瑕疵在哪裡。\r\n\r\n既然會有操作，那把專案的相關文件撰寫清楚，才可能會有辦法好好操作，因此這階段的內容是將開發完成的專案使用情況、操作步驟好好描述，在此，很感謝願意進行測試的好朋友，有你們才能讓專案趨於完整，由衷感謝!!!\r\n需求回饋\r\n不同的使用者有各式各樣的需求，這部分對我而言都是很好的回饋，如果這些需求能夠讓程式更適用於大多數人的需求，這樣對於專案執行的發展方向就會是健康的，畢竟功能好壞各有所主觀意識，但若能夠大部分的人都認為這樣很棒，那我也很樂意為之。\r\n\r\n當實務上遇到問題的時候請用力告訴我，聯絡LINE還是Mail都可以!(詳見左方側邊攔)\r\n\r\n","tags":["Blog"]},{"title":"Streamlit做手繪簽名","url":"/posts/213685522/","content":"前言\r\n工程執行過程免不了會有很多品管文件需要製作，紙本文件的加值應用相當困難，通常都會放置於一堆又一堆的資料夾中，有需要再去相互參照，大多流於形式，倘若工程文件能夠數位化，對於整個工程資料的保存、查詢會有很多好處，但經過幾次查核委員的建議，關於簽名這件事情他們有意見，既然是需要在現場進行檢查的文件，那當然會是手寫的才最香，殊不知很多委員還是認為電腦直接出的文件不能用，至少簽名的部分要手寫才是真的。\r\n基於這些理由，我希望能夠做到用手寫的觸感去簽署文件，透過Streamlit的前端及streamlit-drawable-canvas作為繪圖器，opencv作為背景去背處理，及PyMuPDF作為轉檔工具，來達成委員的要求...\r\n其實我一直不能理解，中華電信都可以用手寫的觸控板來跟客戶簽約了，為什麼公共工程一定要用紙+筆，現在其實平板電腦都很方便，把要抽查的PDF都先放好在雲端，帶去工地現場選取要抽查的對應PDF後寫紀錄表，寫完後可以即時上傳到雲端，資訊流動才會迅速，也不用這樣浪費一堆紙來記錄這些內容，未來要翻閱從雲端去撈取出來即可。\r\n\r\n🎬影片操作\r\n\r\n\r\n安裝包\r\npip install streamlit streamlit-drawable-canvas numpy opencv-python-headless Pillow PyMuPDF\r\n圖片簽名預覽\r\nimport streamlit as stfrom streamlit_drawable_canvas import st_canvasimport numpy as npimport cv2from PIL import Image# 設置 Streamlit 界面st.title(&quot;圖片簽名工具&quot;)# 上傳圖片uploaded_file = st.file_uploader(&quot;上傳圖片&quot;, type=[&quot;jpg&quot;, &quot;jpeg&quot;, &quot;png&quot;])# 繪製簽名st.write(&quot;繪製簽名&quot;)canvas_result = st_canvas(    fill_color=&quot;rgba(0, 0, 0, 0)&quot;,  # 背景填充色    stroke_width=3,    stroke_color=&quot;black&quot;,    background_color=&quot;rgba(255, 255, 255, 0)&quot;,    height=150,    width=400,    drawing_mode=&quot;freedraw&quot;,    key=&quot;canvas&quot;,)if uploaded_file is not None and canvas_result.image_data is not None:    # 讀取上傳的圖片    file_bytes = np.asarray(bytearray(uploaded_file.read()), dtype=np.uint8)    uploaded_image = cv2.imdecode(file_bytes, cv2.IMREAD_UNCHANGED)    # 獲取簽名並處理透明背景    signature_data = canvas_result.image_data    signature = cv2.cvtColor(signature_data, cv2.COLOR_RGBA2BGRA)    # 將簽名大小調整為合適大小    sig_h, sig_w, _ = signature.shape    img_h, img_w, _ = uploaded_image.shape    x_offset = img_w - sig_w - 10    y_offset = img_h - sig_h - 10    # 將簽名放置在圖片上    for c in range(0, 3):        uploaded_image[y_offset:y_offset+sig_h, x_offset:x_offset+sig_w, c] = \\            signature[:, :, c] * (signature[:, :, 3] / 255.0) + \\            uploaded_image[y_offset:y_offset+sig_h, x_offset:x_offset+sig_w, c] * (1.0 - signature[:, :, 3] / 255.0)    # 顯示合併後的圖片    st.image(uploaded_image, caption=&#x27;簽名後的圖片&#x27;, use_column_width=True)\r\n直接簽在圖片上\r\nimport streamlit as stfrom streamlit_drawable_canvas import st_canvasimport numpy as npimport cv2from PIL import Imageimport ioimport fitz  # PyMuPDF# 設置 Streamlit 界面st.title(&quot;PDF 簽名工具&quot;)# 上傳 PDFuploaded_file = st.file_uploader(&quot;上傳 PDF&quot;, type=[&quot;pdf&quot;])# 如果上傳了文件if uploaded_file is not None:    # 讀取上傳的 PDF    pdf_bytes = uploaded_file.read()    document = fitz.open(&quot;pdf&quot;, pdf_bytes)    page = document.load_page(0)    pix = page.get_pixmap()    background_image = Image.frombytes(&quot;RGB&quot;, [pix.width, pix.height], pix.samples)    # st.write(&quot;簽名調整&quot;)        # 繪製簽名    # st.write(&quot;繪製簽名&quot;)    canvas_result = st_canvas(        fill_color=&quot;rgba(0, 0, 0, 0)&quot;,  # 背景填充色        stroke_width=3,        stroke_color=&quot;black&quot;,        background_image=background_image,        height=pix.height,        width=pix.width,        drawing_mode=&quot;freedraw&quot;,        key=&quot;canvas&quot;,    )    # 滑桿調整簽名位置    # st.write(&quot;調整簽名位置&quot;)    x_offset =0# st.slider(&quot;水平位置&quot;, 0, pix.width, 0)    y_offset =0# st.slider(&quot;垂直位置&quot;, 0, pix.height, 0)    if canvas_result.image_data is not None:        # 獲取簽名並處理透明背景        signature_data = canvas_result.image_data        signature = cv2.cvtColor(signature_data, cv2.COLOR_RGBA2BGRA)        signed_images = []        for page_num in range(len(document)):            page = document.load_page(page_num)            pix = page.get_pixmap()            image = Image.frombytes(&quot;RGB&quot;, [pix.width, pix.height], pix.samples)            # 將 PIL 圖像轉換為 OpenCV 圖像            open_cv_image = np.array(image)            open_cv_image = cv2.cvtColor(open_cv_image, cv2.COLOR_RGB2BGRA)            # 簽名位置            sig_h, sig_w, _ = signature.shape            img_h, img_w, _ = open_cv_image.shape            # 確保簽名不超出邊界            if y_offset + sig_h &gt; img_h:                sig_h = img_h - y_offset            if x_offset + sig_w &gt; img_w:                sig_w = img_w - x_offset            # 簽名形狀匹配            resized_signature = cv2.resize(signature, (sig_w, sig_h))            # 將簽名放置在圖片上            for c in range(0, 3):                open_cv_image[y_offset:y_offset+sig_h, x_offset:x_offset+sig_w, c] = \\                    resized_signature[:, :, c] * (resized_signature[:, :, 3] / 255.0) + \\                    open_cv_image[y_offset:y_offset+sig_h, x_offset:x_offset+sig_w, c] * (1.0 - resized_signature[:, :, 3] / 255.0)            # 將 OpenCV 圖像轉換回 PIL 圖像            signed_image = Image.fromarray(cv2.cvtColor(open_cv_image, cv2.COLOR_BGRA2RGBA))            signed_images.append(signed_image)        # 預覽簽名後的第一頁        # st.image(signed_images[0], caption=&#x27;簽名後的 PDF 頁面預覽&#x27;, use_column_width=True)        # 將簽名後的圖像保存回 PDF        pdf_output = io.BytesIO()        signed_images[0].save(pdf_output, &quot;PDF&quot;, resolution=100.0, save_all=True, append_images=signed_images[1:])        pdf_output.seek(0)        # 提供下載鏈接        st.download_button(            label=&quot;下載簽名後的 PDF&quot;,            data=pdf_output,            file_name=&quot;signed_document.pdf&quot;,            mime=&quot;application/pdf&quot;        )\r\n比較完整做法\r\nimport streamlit as stfrom streamlit_drawable_canvas import st_canvasimport numpy as npimport cv2from PIL import Imageimport ioimport fitz  # PyMuPDFimport osimport pandas as pdst.set_page_config(    layout=&quot;wide&quot;,)dict_pdf = &#123;    &quot;測量工程抽查表&quot;: &quot;6-27.pdf&quot;,    &quot;土方工程抽查表&quot;: &quot;6-29.pdf&quot;,    &quot;模板工程抽查表&quot;: &quot;6-30.pdf&quot;,    &quot;鋼筋工程抽查表&quot;: &quot;6-31.pdf&quot;,    &quot;其他&quot;: &quot;&quot;&#125;st.sidebar.title(&quot;&#x270d; PDF 簽名工具&quot;)# 頁面導航page = st.sidebar.selectbox(&quot;選擇頁面&quot;, [&quot;手繪簽名&quot;, &quot;查看表單&quot;])# 根據選擇的頁面顯示內容if page == &quot;手繪簽名&quot;:    # 設置 Streamlit 界面    # st.title(&quot;PDF 簽名工具&quot;)    # 指定保存的文件夾路徑    save_folder = &quot;saved_pdfs&quot;    os.makedirs(save_folder, exist_ok=True)    form_selection = st.sidebar.selectbox(&quot;選擇抽查表&quot;, list(dict_pdf.keys()))    file_name = &quot;./pdfs/&quot;+dict_pdf[form_selection]    # 如果選擇了“其他”，讓用戶上傳 PDF 文件    if form_selection == &quot;其他&quot;:        uploaded_file = st.file_uploader(&quot;上傳 PDF&quot;, type=[&quot;pdf&quot;])    else:        # 否則，讀取預定義的 PDF 文件        with open(file_name, &quot;rb&quot;) as f:            uploaded_file = f.read()    if uploaded_file:        if form_selection == &quot;其他&quot;:            pdf_bytes = uploaded_file.read()        else:            pdf_bytes = uploaded_file        # 讀取 PDF        document = fitz.open(&quot;pdf&quot;, pdf_bytes)        page = document.load_page(0)        pix = page.get_pixmap(matrix=fitz.Matrix(2.0, 2.0))  # 使用 matrix 調整分辨率        original_width, original_height = pix.width, pix.height        background_image = Image.frombytes(&quot;RGB&quot;, [pix.width, pix.height], pix.samples)        # 繪製簽名        canvas_result = st_canvas(            fill_color=&quot;rgba(0, 0, 0, 0)&quot;,  # 背景填充色            stroke_width=3,            stroke_color=&quot;black&quot;,            background_image=background_image,            height=pix.height,            width=pix.width,            drawing_mode=&quot;freedraw&quot;,            key=&quot;canvas&quot;,        )        if canvas_result.image_data is not None:            # 獲取簽名並處理透明背景            signature_data = canvas_result.image_data            signature = cv2.cvtColor(signature_data, cv2.COLOR_RGBA2BGRA)            signed_images = []            # 設置簽名位置 (預設值，可以根據需要調整)            y_offset, x_offset = 0,0            for page_num in range(len(document)):                page = document.load_page(page_num)                pix = page.get_pixmap(matrix=fitz.Matrix(2.0, 2.0))  # 使用相同的 matrix 調整分辨率                image = Image.frombytes(&quot;RGB&quot;, [pix.width, pix.height], pix.samples)                # 將 PIL 圖像轉換為 OpenCV 圖像                open_cv_image = np.array(image)                open_cv_image = cv2.cvtColor(open_cv_image, cv2.COLOR_RGB2BGRA)                # 簽名位置                sig_h, sig_w, _ = signature.shape                img_h, img_w, _ = open_cv_image.shape                # 調整簽名位置以匹配新的解析度                adjusted_y_offset = int((y_offset / original_height) * img_h)                adjusted_x_offset = int((x_offset / original_width) * img_w)                # 確保簽名不超出邊界                if adjusted_y_offset + sig_h &gt; img_h:                    sig_h = img_h - adjusted_y_offset                if adjusted_x_offset + sig_w &gt; img_w:                    sig_w = img_w - adjusted_x_offset                # 簽名形狀匹配                resized_signature = cv2.resize(signature, (sig_w, sig_h))                # 將簽名放置在圖片上                for c in range(0, 3):                    open_cv_image[adjusted_y_offset:adjusted_y_offset+sig_h, adjusted_x_offset:adjusted_x_offset+sig_w, c] = \\                        resized_signature[:, :, c] * (resized_signature[:, :, 3] / 255.0) + \\                        open_cv_image[adjusted_y_offset:adjusted_y_offset+sig_h, adjusted_x_offset:adjusted_x_offset+sig_w, c] * (1.0 - resized_signature[:, :, 3] / 255.0)                # 將 OpenCV 圖像轉換回 PIL 圗像                signed_image = Image.fromarray(cv2.cvtColor(open_cv_image, cv2.COLOR_BGRA2RGBA))                signed_images.append(signed_image)            # 將簽名後的圖像保存回 PDF            pdf_output = io.BytesIO()            signed_images[0].save(pdf_output, &quot;PDF&quot;, resolution=100.0, save_all=True, append_images=signed_images[1:])            pdf_output.seek(0)            # 增加“儲存”按鈕            if st.button(&quot;儲存&quot;, type=&#x27;primary&#x27;):                # 生成保存路徑和文件名                base_file_name = form_selection if form_selection != &quot;其他&quot; else &quot;custom&quot;                existing_files = [f for f in os.listdir(save_folder) if f.startswith(base_file_name)]                file_count = len(existing_files) + 1                output_file_name = f&quot;&#123;base_file_name&#125;_&#123;file_count&#125;.pdf&quot;                save_path = os.path.join(save_folder, output_file_name)                # 將簽名後的 PDF 文件保存到指定資料夾                with open(save_path, &quot;wb&quot;) as f:                    f.write(pdf_output.getbuffer())                st.success(f&quot;已將簽名後的 PDF 保存到: &#123;save_path&#125;&quot;)elif page == &quot;查看表單&quot;:    # 指定保存的文件夾路徑    save_folder = &quot;saved_pdfs&quot;    os.makedirs(save_folder, exist_ok=True)    # 獲取所有已保存的表單    saved_forms = os.listdir(save_folder)    # 根據文件名分類表單    classified_forms = &#123;&#125;    for form in saved_forms:        form_type = form.rsplit(&#x27;_&#x27;, 1)[0]        if form_type not in classified_forms:            classified_forms[form_type] = []        classified_forms[form_type].append(form)    # 將分類表單轉換為 DataFrame    df = pd.DataFrame(        [(key, form) for key, forms in classified_forms.items() for form in forms],        columns=[&quot;表單類型&quot;, &quot;文件名&quot;]    )    # 顯示 DataFrame 並允許用戶選擇要顯示的表單    selected_forms = st.multiselect(&quot;選擇要顯示的表單&quot;, df[&quot;文件名&quot;])    # 顯示選擇的表單    if selected_forms:        for form in selected_forms:            form_path = os.path.join(save_folder, form)                        st.markdown(f&quot;####  &#123;form&#125;&quot;)                        # 使用 PyMuPDF 加載 PDF 文件            pdf_doc = fitz.open(form_path)                        # 顯示每一頁的圖像內容            for page_num in range(len(pdf_doc)):                page = pdf_doc.load_page(page_num)                                # 將 PDF 頁面轉換為圖像                pix = page.get_pixmap(matrix=fitz.Matrix(2.0, 2.0))  # 使用相同的 matrix 調整分辨率                img = Image.frombytes(&quot;RGB&quot;, [pix.width, pix.height], pix.samples)                                st.image(img, caption=f&quot;第 &#123;page_num + 1&#125; 頁&quot;)    else:        st.write(&quot;目前沒有已保存的表單。&quot;)\r\n以前做的專案\r\nExcel\r\nVBA@簽名檔小工具\r\n去年曾經有把簽名檔做成很多不同照片來調整大小及位置進行貼上，不過經廣大網友的檢視後，發現這樣委員還是會不喜歡，還是先做個紀錄給大家參考參考...\r\n","categories":["專案成果"],"tags":["Streamlit"]},{"title":"Streamlit工程進度甘特圖","url":"/posts/43562660/","content":"前言\r\n工程進行期間會有很多不同的任務，每個任務會有自己所需要花費的金額、起始日期、持續天數，藉由這些任務的組合可以統整出工程的預定進度情況，將不同任務繪製在同一個時間軸上可以清楚的了解到現階段有那些任務應該要被完成以及未來還有哪些任務需要完成，對於任務單純的工程很有大的助益。\r\n前陣子在開發施工日誌的時候，如果採用施工計畫書上的每15日累積進度做內差取值會比較容易失真，後來想想，其實這個累積進度的來源也是按照甘特圖的比例所得出的結果?但總歸如何，還是花了一些時間熟悉一下matplotlib的做圖套件，並且搭配streamlit前端介面做一個雲端服務，目標是希望能夠產出工程甘特圖及每日進度的CSV檔案，未來可以匯入其他的日報VBA工具。\r\n\r\n操作介面\r\n\r\n\r\n操作介面\r\n\r\n\r\n進入系統之後左側為任務編輯區塊，右側為甘特圖\r\n任務編輯區塊可以進行新增、刪除、編輯\r\n每次的更動都會重新生成甘特圖，下載CSV也會即時更新\r\n\r\n如有看不懂的地方可以點選影片操作教學\r\n網頁連結\r\n🔗\r\n工程進度V0.1.0 網頁連結\r\n完整做法\r\n\r\nGithub上面的是已經精挑細選過的程式碼，製作期間有陸陸續續砍掉一些功能，可以參照下面的註解處。\r\n\r\nimport streamlit as stimport pandas as pdimport matplotlib.pyplot as pltimport matplotlib.dates as mdatesimport numpy as npfrom matplotlib.font_manager import FontPropertiesimport matplotlib.ticker as tickerfrom io import BytesIOfrom datetime import date### Init ###def main_zh():    SYSTEM_VERSION=&quot;V1.0.0&quot;    # st.set_page_config(layout=&#x27;wide&#x27;)    font_prop = FontProperties(fname=&#x27;./NotoSansCJK-Regular.ttc&#x27;)    # 初始化數據，如果 st.session_state 中沒有存儲數據    # btn_sample = st.button(&quot;載入測試案例&quot;)    if &#x27;data&#x27; not in st.session_state:        # df = pd.DataFrame(columns=[&#x27;項目名稱&#x27;, &#x27;花費金額&#x27;, &#x27;起始日期&#x27;, &#x27;持續天數&#x27;, &#x27;結束日期&#x27;])    #     st.session_state[&#x27;data&#x27;]=[    #         &#123;&#x27;項目名稱&#x27;: &#x27;點我修改A&#x27;, &#x27;花費金額&#x27;: 1000, &#x27;起始日期&#x27;: &#x27;2024-07-01&#x27;, &#x27;持續天數&#x27;: 5, &#x27;結束日期&#x27;: &#x27;&#x27;&#125;,    #         &#123;&#x27;項目名稱&#x27;: &#x27;點我修改B&#x27;, &#x27;花費金額&#x27;: 1000, &#x27;起始日期&#x27;: &#x27;2024-07-01&#x27;, &#x27;持續天數&#x27;: 5, &#x27;結束日期&#x27;: &#x27;&#x27;&#125;,    #         &#123;&#x27;項目名稱&#x27;: &#x27;點我修改C&#x27;, &#x27;花費金額&#x27;: 1000, &#x27;起始日期&#x27;: &#x27;2024-07-01&#x27;, &#x27;持續天數&#x27;: 5, &#x27;結束日期&#x27;: &#x27;&#x27;&#125;    #         ]    # # st.json(st.session_state)    # if btn_sample:        # data = &#123;        #     &#x27;項目名稱&#x27;: [&#x27;基礎構造&#x27;, &#x27;結構加固&#x27;, &#x27;地基工程&#x27;, &#x27;屋頂修復&#x27;, &#x27;室內裝修&#x27;, &#x27;電力系統升級&#x27;, &#x27;水利設施建設&#x27;, &#x27;道路擴建&#x27;, &#x27;綠化工程&#x27;, &#x27;消防安全系統&#x27;],        #     &#x27;花費金額&#x27;: [50000, 120000, 80000, 100000, 60000, 70000, 90000, 110000, 80000, 90000],        #     &#x27;起始日期&#x27;: [&#x27;2024-07-01&#x27;, &#x27;2024-07-15&#x27;, &#x27;2024-08-01&#x27;, &#x27;2024-07-01&#x27;, &#x27;2024-07-05&#x27;, &#x27;2024-07-20&#x27;, &#x27;2024-07-25&#x27;, &#x27;2024-08-05&#x27;, &#x27;2024-08-10&#x27;, &#x27;2024-08-15&#x27;],        #     &#x27;持續天數&#x27;: [5, 12, 8, 10, 6, 7, 9, 11, 8, 9],        #     &#x27;結束日期&#x27;: [&#x27;&#x27;] * 10        # &#125;        # st.session_state[&#x27;data&#x27;]=[]        sample_data = [        &#123;&#x27;項目名稱&#x27;: &#x27;基礎構造&#x27;, &#x27;花費金額&#x27;: 50000, &#x27;起始日期&#x27;: &#x27;2024-07-01&#x27;, &#x27;持續天數&#x27;: 5, &#x27;結束日期&#x27;: &#x27;&#x27;&#125;,        &#123;&#x27;項目名稱&#x27;: &#x27;結構加固&#x27;, &#x27;花費金額&#x27;: 120000, &#x27;起始日期&#x27;: &#x27;2024-07-15&#x27;, &#x27;持續天數&#x27;: 12, &#x27;結束日期&#x27;: &#x27;&#x27;&#125;,        &#123;&#x27;項目名稱&#x27;: &#x27;地基工程&#x27;, &#x27;花費金額&#x27;: 80000, &#x27;起始日期&#x27;: &#x27;2024-08-01&#x27;, &#x27;持續天數&#x27;: 8, &#x27;結束日期&#x27;: &#x27;&#x27;&#125;,        &#123;&#x27;項目名稱&#x27;: &#x27;屋頂修復&#x27;, &#x27;花費金額&#x27;: 100000, &#x27;起始日期&#x27;: &#x27;2024-07-01&#x27;, &#x27;持續天數&#x27;: 10, &#x27;結束日期&#x27;: &#x27;&#x27;&#125;,        &#123;&#x27;項目名稱&#x27;: &#x27;室內裝修&#x27;, &#x27;花費金額&#x27;: 60000, &#x27;起始日期&#x27;: &#x27;2024-07-05&#x27;, &#x27;持續天數&#x27;: 6, &#x27;結束日期&#x27;: &#x27;&#x27;&#125;,        &#123;&#x27;項目名稱&#x27;: &#x27;電力系統升級&#x27;, &#x27;花費金額&#x27;: 70000, &#x27;起始日期&#x27;: &#x27;2024-07-20&#x27;, &#x27;持續天數&#x27;: 7, &#x27;結束日期&#x27;: &#x27;&#x27;&#125;,        &#123;&#x27;項目名稱&#x27;: &#x27;水利設施建設&#x27;, &#x27;花費金額&#x27;: 90000, &#x27;起始日期&#x27;: &#x27;2024-07-25&#x27;, &#x27;持續天數&#x27;: 9, &#x27;結束日期&#x27;: &#x27;&#x27;&#125;,        &#123;&#x27;項目名稱&#x27;: &#x27;道路擴建&#x27;, &#x27;花費金額&#x27;: 110000, &#x27;起始日期&#x27;: &#x27;2024-08-05&#x27;, &#x27;持續天數&#x27;: 11, &#x27;結束日期&#x27;: &#x27;&#x27;&#125;,        &#123;&#x27;項目名稱&#x27;: &#x27;綠化工程&#x27;, &#x27;花費金額&#x27;: 80000, &#x27;起始日期&#x27;: &#x27;2024-08-10&#x27;, &#x27;持續天數&#x27;: 8, &#x27;結束日期&#x27;: &#x27;&#x27;&#125;,        &#123;&#x27;項目名稱&#x27;: &#x27;消防安全系統&#x27;, &#x27;花費金額&#x27;: 90000, &#x27;起始日期&#x27;: &#x27;2024-08-15&#x27;, &#x27;持續天數&#x27;: 9, &#x27;結束日期&#x27;: &#x27;&#x27;&#125;,        ]                # df = pd.DataFrame(data)        # df[&#x27;起始日期&#x27;] = pd.to_datetime(df[&#x27;起始日期&#x27;])        # df[&#x27;結束日期&#x27;] = df[&#x27;起始日期&#x27;] + pd.to_timedelta(df[&#x27;持續天數&#x27;], unit=&#x27;D&#x27;)        # st.session_state.data = df        st.session_state[&#x27;data&#x27;]=sample_data    # for item in st.session_state[&#x27;data&#x27;]:    #     st.write(item)    # 從 st.session_state 中獲取 DataFrame    # df = st.session_state.data.dropna(subset=[&#x27;持續天數&#x27;])    col1, col2 = st.columns([1, 2])    with col1:        st.markdown(&quot;### :spiral_calendar_pad: 工程進度 &quot;+SYSTEM_VERSION)        st.info(&quot;作者:**HankLin @202407**&quot;)        st.markdown(&quot;---&quot;)        # 新增方式，回饋到 st.session_state        # with st.form(&quot;C&quot;, True):        #     myitem = st.text_input(&quot;施作項目:&quot;)        #     mycost = st.number_input(&quot;花費金額:&quot;)        #     mystart_date = st.date_input(&quot;開始日期:&quot;)        #     mydays = st.number_input(&quot;持續天數&quot;)        #     # st.json(st.session_state[&#x27;data&#x27;])        #     if st.form_submit_button(&quot;新增&quot;):        #         new_item = &#123;        #             # &#x27;項目編號&#x27;: max(df[&#x27;項目編號&#x27;], default=0) + 1,  # 自動分配新的項目編號        #             &#x27;項目名稱&#x27;: myitem,        #             &#x27;花費金額&#x27;: mycost,        #             &#x27;起始日期&#x27;: pd.to_datetime(mystart_date),        #             &#x27;持續天數&#x27;: mydays,        #             &#x27;結束日期&#x27;: &quot;&quot;#pd.to_datetime(mystart_date) + pd.to_timedelta(mydays, unit=&#x27;D&#x27;)        #         &#125;        #         # df = pd.concat([df, pd.DataFrame([new_item])], ignore_index=True)        #         # new_items=st.session_state[&#x27;data&#x27;].append(new_item)        #         # st.json(st.session_state[&#x27;data&#x27;])        #         # st.session_state.data = df        #         st.session_state[&#x27;data&#x27;].append(new_item)        #         st.success(&quot;成功新增施工項目！&quot;)        # 總表（編輯方式），回饋到 st.session_state        st.markdown(&quot;##### \t\t&#x1f447; 施工項目填寫&quot;)        # st.json(st.session_state)        df=pd.DataFrame(st.session_state[&#x27;data&#x27;])        # st.write(len(df))                df[&#x27;起始日期&#x27;] = pd.to_datetime(df[&#x27;起始日期&#x27;])        edited_df = st.data_editor(df, use_container_width=True,num_rows=&#x27;dynamic&#x27;,                                column_config=&#123;                                    &quot;起始日期&quot;: st.column_config.DateColumn(                                        &quot;起始日期&quot;,                                        min_value=date(2024, 1, 1),                                        max_value=date(2030, 1, 1),                                        format=&quot;YYYY-MM-DD&quot;,                                        step=1,                                    )                                &#125;,                                hide_index=True, column_order=(&quot;項目名稱&quot;, &quot;花費金額&quot;, &quot;起始日期&quot;, &quot;持續天數&quot;))        edited_df[&#x27;結束日期&#x27;] = edited_df[&#x27;起始日期&#x27;] + pd.to_timedelta(edited_df[&#x27;持續天數&#x27;], unit=&#x27;D&#x27;)        is_show_text=st.toggle(&quot;圖塊文字&quot;)    ### 計算流程以下都沒問題，可以先引入session_state後開始    # final_df=st.session_state.data    final_df=edited_df    # final_df = edited_df.dropna(subset=[&#x27;持續天數&#x27;])    if len(final_df)==0:        exit()    else:        # 計算每日耗費成本        total_cost = final_df[&#x27;花費金額&#x27;].sum()        start_date = final_df[&#x27;起始日期&#x27;].min()        end_date = final_df[&#x27;結束日期&#x27;].max()        date_range = pd.date_range(start=start_date, end=end_date, freq=&#x27;D&#x27;)  # 每日頻率        daily_cost = np.zeros(len(date_range))        for i, row in final_df.iterrows():            cost_per_day = row[&#x27;花費金額&#x27;] / row[&#x27;持續天數&#x27;]            daily_cost[(date_range &gt; row[&#x27;起始日期&#x27;]) &amp; (date_range &lt;= row[&#x27;結束日期&#x27;])] += cost_per_day        # 計算累積花費金額和每日進度百分比        cumulative_cost = np.cumsum(daily_cost)        daily_progress = (daily_cost / total_cost) * 100        cumulative_progress = (cumulative_cost / total_cost) * 100        csv_data = pd.DataFrame(&#123;            &#x27;日期&#x27;: date_range,            &#x27;當日費用&#x27;: daily_cost,            &#x27;累積費用&#x27;: cumulative_cost,            &#x27;當日進度&#x27;: daily_progress,            &#x27;累積進度&#x27;: cumulative_progress        &#125;)        # st.dataframe(csv_data)    with col2:        # plt.xticks(rotation=45)        fig, ax1 = plt.subplots(figsize=(14, 10))        # ax1=plt.xticks(rotation=45)        # 畫甘特圖，調整顏色和透明度，加入格線        colors = plt.cm.Set3.colors  # 使用單一色系        # st.json(final_df.to_json())        cnt=0        for i, row in final_df.iterrows():            if not pd.isna(row[&quot;持續天數&quot;]):                color = colors[i % len(colors)]                ax1.barh(row[&#x27;項目名稱&#x27;], row[&#x27;持續天數&#x27;], left=row[&#x27;起始日期&#x27;], height=0.3, color=color)                if is_show_text==True:                    ax1.text(row[&#x27;起始日期&#x27;], cnt, f&quot;&#123;row[&#x27;項目名稱&#x27;]&#125;: &#123;int(row[&#x27;持續天數&#x27;])&#125;天&quot;, color=&#x27;black&#x27;, verticalalignment=&#x27;center&#x27;, fontsize=10, fontproperties=font_prop)                cnt=cnt+1        # 設置標籤和標題        ax1.set_xlabel(&#x27;日期&#x27;, fontproperties=font_prop)        ax1.set_title(&#x27;施工進度甘特圖&#x27;, fontproperties=font_prop)        for label in ax1.get_yticklabels():            label.set_fontproperties(font_prop)        # 在同一張圖上繪製每日累積進度圖並標示節點百分比        ax2 = ax1.twinx()        ax2.plot(date_range, cumulative_progress, marker=&#x27;o&#x27;, linestyle=&#x27;-&#x27;, color=&#x27;orange&#x27;)        for i, txt in enumerate(cumulative_progress):            if i % 5== 0 or txt==100:  # 每10%標示一次                ax2.annotate(f&#x27;&#123;int(txt)&#125;%&#x27;, (date_range[i], cumulative_progress[i]), textcoords=&quot;offset points&quot;, xytext=(0,10), ha=&#x27;center&#x27;, fontproperties=font_prop)        ax2.set_ylabel(&#x27;累積進度百分比 (%)&#x27;, fontproperties=font_prop)        ax2.yaxis.set_major_locator(ticker.MultipleLocator(base=10))        # 調整 x 軸日期顯示為每半個月        ax1.xaxis.set_major_locator(mdates.DayLocator(interval=10))  # 每10顯示一次日期        ax1.xaxis.set_minor_locator(mdates.DayLocator(interval=1))  # 每天都顯示日期        ax1.xaxis.set_major_formatter(mdates.DateFormatter(&#x27;%Y-%m-%d&#x27;))        # 添加網格線        ax2.grid(True, which=&#x27;both&#x27;, linestyle=&#x27;:&#x27;, linewidth=0.5)        # 添加圖例，將位置調整到右下角        # ax1.legend([&#x27;工程項目&#x27;], loc=&#x27;upper left&#x27;, prop=font_prop)        ax2.legend([&#x27;累積進度&#x27;], loc=&#x27;lower right&#x27;, prop=font_prop)        # 調整圖形排版        fig.tight_layout()        ax1.set_xlim(start_date - pd.Timedelta(days=3), end_date + pd.Timedelta(days=3))        # 顯示圖形        st.pyplot(fig)    # 下載 CSV 按鈕    csv_data = pd.DataFrame(&#123;        &#x27;date&#x27;: date_range,        &#x27;progress(%)&#x27;: daily_progress/100,        &#x27;sum_progress(%)&#x27;: cumulative_progress/100    &#125;)    csv_data[&#x27;date&#x27;] = csv_data[&#x27;date&#x27;].dt.strftime(&#x27;%Y-%m-%d&#x27;)  # 將日期轉換為字串格式    csv_string = csv_data.to_csv(index=False, encoding=&#x27;utf-8-sig&#x27;)    # 提供下載按鈕    with col1:        st.download_button(            label=&quot;下載 CSV 檔案&quot;,            data=csv_string,            file_name=&#x27;progress_data.csv&#x27;,            mime=&#x27;text/csv&#x27;        )# def main_eng():#     ### Initialization ####     SYSTEM_VERSION = &quot;V1.0.0&quot;#     font_prop = FontProperties(fname=&#x27;./NotoSansCJK-Regular.ttc&#x27;)#     # Initialize data if not stored in st.session_state#     if &#x27;data&#x27; not in st.session_state:#         sample_data = [#             &#123;&#x27;project_name&#x27;: &#x27;Foundation Construction&#x27;, &#x27;cost&#x27;: 50000, &#x27;start_date&#x27;: &#x27;2024-07-01&#x27;, &#x27;duration_days&#x27;: 5, &#x27;end_date&#x27;: &#x27;&#x27;&#125;,#             &#123;&#x27;project_name&#x27;: &#x27;Structural Reinforcement&#x27;, &#x27;cost&#x27;: 120000, &#x27;start_date&#x27;: &#x27;2024-07-15&#x27;, &#x27;duration_days&#x27;: 12, &#x27;end_date&#x27;: &#x27;&#x27;&#125;,#             &#123;&#x27;project_name&#x27;: &#x27;Foundation Engineering&#x27;, &#x27;cost&#x27;: 80000, &#x27;start_date&#x27;: &#x27;2024-08-01&#x27;, &#x27;duration_days&#x27;: 8, &#x27;end_date&#x27;: &#x27;&#x27;&#125;,#             &#123;&#x27;project_name&#x27;: &#x27;Roof Repair&#x27;, &#x27;cost&#x27;: 100000, &#x27;start_date&#x27;: &#x27;2024-07-01&#x27;, &#x27;duration_days&#x27;: 10, &#x27;end_date&#x27;: &#x27;&#x27;&#125;,#             &#123;&#x27;project_name&#x27;: &#x27;Interior Decoration&#x27;, &#x27;cost&#x27;: 60000, &#x27;start_date&#x27;: &#x27;2024-07-05&#x27;, &#x27;duration_days&#x27;: 6, &#x27;end_date&#x27;: &#x27;&#x27;&#125;,#             &#123;&#x27;project_name&#x27;: &#x27;Power System Upgrade&#x27;, &#x27;cost&#x27;: 70000, &#x27;start_date&#x27;: &#x27;2024-07-20&#x27;, &#x27;duration_days&#x27;: 7, &#x27;end_date&#x27;: &#x27;&#x27;&#125;,#             &#123;&#x27;project_name&#x27;: &#x27;Water Facilities Construction&#x27;, &#x27;cost&#x27;: 90000, &#x27;start_date&#x27;: &#x27;2024-07-25&#x27;, &#x27;duration_days&#x27;: 9, &#x27;end_date&#x27;: &#x27;&#x27;&#125;,#             &#123;&#x27;project_name&#x27;: &#x27;Road Expansion&#x27;, &#x27;cost&#x27;: 110000, &#x27;start_date&#x27;: &#x27;2024-08-05&#x27;, &#x27;duration_days&#x27;: 11, &#x27;end_date&#x27;: &#x27;&#x27;&#125;,#             &#123;&#x27;project_name&#x27;: &#x27;Greening Project&#x27;, &#x27;cost&#x27;: 80000, &#x27;start_date&#x27;: &#x27;2024-08-10&#x27;, &#x27;duration_days&#x27;: 8, &#x27;end_date&#x27;: &#x27;&#x27;&#125;,#             &#123;&#x27;project_name&#x27;: &#x27;Fire Safety System&#x27;, &#x27;cost&#x27;: 90000, &#x27;start_date&#x27;: &#x27;2024-08-15&#x27;, &#x27;duration_days&#x27;: 9, &#x27;end_date&#x27;: &#x27;&#x27;&#125;,#         ]        #         st.session_state[&#x27;data&#x27;] = sample_data#     # Display UI#     col1, col2 = st.columns([1, 2])#     with col1:#         st.markdown(&quot;### :spiral_calendar_pad: Project Progress &quot; + SYSTEM_VERSION)#         st.info(&quot;Author: **HankLin @202407**&quot;)#         st.markdown(&quot;---&quot;)#         st.markdown(&quot;##### &#x1f447; Edit Construction Projects&quot;)#         df = pd.DataFrame(st.session_state[&#x27;data&#x27;])#         edited_df = st.data_editor(df, use_container_width=True, num_rows=&#x27;dynamic&#x27;,#                                 column_config=&#123;#                                     &quot;start_date&quot;: st.column_config.DateColumn(#                                         &quot;Start Date&quot;,#                                         min_value=date(2024, 1, 1),#                                         max_value=date(2030, 1, 1),#                                         format=&quot;YYYY-MM-DD&quot;,#                                         step=1,#                                     )#                                 &#125;,#                                 hide_index=True, column_order=(&quot;project_name&quot;, &quot;cost&quot;, &quot;start_date&quot;, &quot;duration_days&quot;))#         edited_df[&#x27;end_date&#x27;] = edited_df[&#x27;start_date&#x27;] + pd.to_timedelta(edited_df[&#x27;duration_days&#x27;], unit=&#x27;D&#x27;)#         is_show_text = st.toggle(&quot;Show Block Text&quot;)#     with col2:#         fig, ax1 = plt.subplots(figsize=(14, 10))#         colors = plt.cm.Set3.colors#         cnt = 0#         for i, row in edited_df.iterrows():#             if not pd.isna(row[&quot;duration_days&quot;]):#                 color = colors[i % len(colors)]#                 ax1.barh(row[&#x27;project_name&#x27;], row[&#x27;duration_days&#x27;], left=row[&#x27;start_date&#x27;], height=0.3, color=color)#                 if is_show_text:#                     ax1.text(row[&#x27;start_date&#x27;], cnt, f&quot;&#123;row[&#x27;project_name&#x27;]&#125;: &#123;int(row[&#x27;duration_days&#x27;])&#125; days&quot;, color=&#x27;black&#x27;, verticalalignment=&#x27;center&#x27;, fontsize=10, fontproperties=font_prop)#                 cnt += 1#         ax1.set_xlabel(&#x27;Date&#x27;, fontproperties=font_prop)#         ax1.set_title(&#x27;Construction Progress Gantt Chart&#x27;, fontproperties=font_prop)#         for label in ax1.get_yticklabels():#             label.set_fontproperties(font_prop)#         ax2 = ax1.twinx()#         ax2.plot(date_range, cumulative_progress, marker=&#x27;o&#x27;, linestyle=&#x27;-&#x27;, color=&#x27;orange&#x27;)#         for i, txt in enumerate(cumulative_progress):#             if i % 5 == 0 or txt == 100:#                 ax2.annotate(f&#x27;&#123;int(txt)&#125;%&#x27;, (date_range[i], cumulative_progress[i]), textcoords=&quot;offset points&quot;, xytext=(0, 10), ha=&#x27;center&#x27;, fontproperties=font_prop)#         ax2.set_ylabel(&#x27;Cumulative Progress (%)&#x27;, fontproperties=font_prop)#         ax2.yaxis.set_major_locator(ticker.MultipleLocator(base=10))#         ax1.xaxis.set_major_locator(mdates.DayLocator(interval=10))#         ax1.xaxis.set_minor_locator(mdates.DayLocator(interval=1))#         ax1.xaxis.set_major_formatter(mdates.DateFormatter(&#x27;%Y-%m-%d&#x27;))#         ax2.grid(True, which=&#x27;both&#x27;, linestyle=&#x27;:&#x27;, linewidth=0.5)#         ax2.legend([&#x27;Cumulative Progress&#x27;], loc=&#x27;lower right&#x27;, prop=font_prop)#         fig.tight_layout()#         ax1.set_xlim(start_date - pd.Timedelta(days=3), end_date + pd.Timedelta(days=3))#         st.pyplot(fig)#     # Download CSV button#     csv_data = pd.DataFrame(&#123;#         &#x27;date&#x27;: date_range,#         &#x27;progress(%)&#x27;: daily_progress/100,#         &#x27;sum_progress(%)&#x27;: cumulative_progress/100#     &#125;)#     csv_data[&#x27;date&#x27;] = csv_data[&#x27;date&#x27;].dt.strftime(&#x27;%Y-%m-%d&#x27;)#     csv_string = csv_data.to_csv(index=False, encoding=&#x27;utf-8-sig&#x27;)#     with col1:#         st.download_button(#             label=&quot;Download CSV File&quot;,#             data=csv_string,#             file_name=&#x27;progress_data.csv&#x27;,#             mime=&#x27;text/csv&#x27;#         )if __name__ == &quot;__main__&quot;:        st.set_page_config(layout=&#x27;wide&#x27;)    # language_check=st.checkbox(&quot;English&quot;)    # if language_check==True:        # main_eng()    # else:    main_zh()\r\n開發過程紀錄\r\n\r\n在dataframe中處理日期要把字串類型的日期透過'pd.to_datetime'轉型才能用\r\n中文顯示會有問題的地方要先下載好字型檔讓'fontproperties'引用\r\n甘特圖與累積進度圖要交疊在同一張圖要透過'ax2=ax1.twinx()'才能連一起\r\n調整X軸座標顯示時，可以用'ax1.set_xlim(start_date -\r\npd.Timedelta(days=3), end_date +\r\npd.Timedelta(days=3))'來將前後各往外擴一些\r\n\r\n","categories":["專案成果"],"tags":["Streamlit"]},{"title":"Streamlit建立權限控管機制","url":"/posts/777227760/","content":"前言\r\n\r\n權限控管顧名思義則是讓有登記的人可以進來雲端網頁中操作介面，這對於一些公司內部才能操作的內容有很大的幫助。\r\n\r\n權限控管基本功能:\r\n\r\n註冊\r\n登入\r\n忘記密碼\r\n重置密碼\r\n\r\n發送重置密碼時會隨意產生一組token，內容會包在電子郵件中寄送，這也算是一種多因素認證的機制。\r\n本篇文章前端介面採用Python的Streamlit套件實作，後端邏輯則採用GAS實作，資料庫則採用GoogleSpreadSheet儲存。\r\n正常的帳號密碼實作流程不建議採用明碼儲存，這裡只是一個實作的經驗，看之後密碼的部分要加鹽還是做哈希加密都可以再追加進去。\r\n\r\n\r\nGAS端\r\n先新增一個SpreadSheet並且將工作表設定如下:\r\nUsers\r\n\r\n\r\n\r\nemail\r\nusername\r\npassword\r\n\r\n\r\n\r\n\r\n...\r\n...\r\n...\r\n\r\n\r\n\r\nResetTokens\r\n\r\n\r\n\r\nemail\r\ntoken\r\ntimestamp\r\n\r\n\r\n\r\n\r\n...\r\n...\r\n...\r\n\r\n\r\n\r\ntimestamp在GAS中的目的是為了要取得24小時內的token才能有效更改新密碼\r\nfunction doPost(e) &#123;  var action = e.parameter.action;  var email = e.parameter.email;  var username = e.parameter.username;  var password = e.parameter.password;  var newPassword = e.parameter.newPassword;  var token=e.parameter.token;  try &#123;    if (action == &quot;register&quot;) &#123;      return registerUser(email, username, password);    &#125; else if (action == &quot;login&quot;) &#123;      return loginUser(username, password);    &#125; else if (action == &quot;forgotPassword&quot;) &#123;      return forgotPassword(email);    &#125; else if (action == &quot;updatePassword&quot;) &#123;      return updatePassword(username,token, newPassword);    &#125; else &#123;      return ContentService.createTextOutput(JSON.stringify(&#123; status: &quot;error&quot;, message: &quot;Invalid action&quot; &#125;)).setMimeType(ContentService.MimeType.JSON);    &#125;  &#125; catch (error) &#123;    return ContentService.createTextOutput(JSON.stringify(&#123; status: &quot;error&quot;, message: error.message &#125;)).setMimeType(ContentService.MimeType.JSON);  &#125;&#125;function registerUser(email, username, password) &#123;  var sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(&#x27;Users&#x27;);  var data = sheet.getDataRange().getValues();  for (var i = 0; i &lt; data.length; i++) &#123;    if (data[i][0] == email) &#123;      return ContentService.createTextOutput(JSON.stringify(&#123; status: &quot;error&quot;, message: &quot;Email already registered&quot; &#125;)).setMimeType(ContentService.MimeType.JSON);    &#125;  &#125;  sheet.appendRow([email, username, password]);  return ContentService.createTextOutput(JSON.stringify(&#123; status: &quot;success&quot;, message: &quot;User registered successfully&quot; &#125;)).setMimeType(ContentService.MimeType.JSON);&#125;function loginUser(username, password) &#123;  var sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(&#x27;Users&#x27;);  var data = sheet.getDataRange().getValues();  for (var i = 0; i &lt; data.length; i++) &#123;    if (data[i][1] == username &amp;&amp; data[i][2] == password) &#123;      return ContentService.createTextOutput(JSON.stringify(&#123; status: &quot;success&quot;, message: &quot;Login successful&quot; &#125;)).setMimeType(ContentService.MimeType.JSON);    &#125;  &#125;  return ContentService.createTextOutput(JSON.stringify(&#123; status: &quot;error&quot;, message: &quot;Invalid username or password&quot; &#125;)).setMimeType(ContentService.MimeType.JSON);&#125;function updatePassword(email, token, newPassword) &#123;  var sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(&#x27;ResetTokens&#x27;);  var data = sheet.getDataRange().getValues();  var now = new Date().getTime();  var tokenValid = false;  for (var i = 0; i &lt; data.length; i++) &#123;    if (data[i][0] == email &amp;&amp; data[i][1] == token) &#123;      var timestamp = data[i][2];      if (now - timestamp &lt;= 24 * 60 * 60 * 1000) &#123;  // Token valid for 24 hours        tokenValid = true;        sheet.getRange(i+1, 3).setValue(0);        break;      &#125;    &#125;  &#125;  if (tokenValid) &#123;    var userSheet =SpreadsheetApp.getActiveSpreadsheet().getSheetByName(&#x27;Users&#x27;);    var userData = userSheet.getDataRange().getValues();    for (var j = 0; j &lt; userData.length; j++) &#123;      if (userData[j][0] == email) &#123;        userSheet.getRange(j + 1, 3).setValue(newPassword);        return ContentService.createTextOutput(JSON.stringify(&#123; status: &quot;success&quot;, message: &quot;Password updated successfully&quot; &#125;)).setMimeType(ContentService.MimeType.JSON);      &#125;    &#125;  &#125;  return ContentService.createTextOutput(JSON.stringify(&#123; status: &quot;error&quot;, message: &quot;Invalid token or email&quot; &#125;)).setMimeType(ContentService.MimeType.JSON);&#125;function forgotPassword(email) &#123;  var sheet =SpreadsheetApp.getActiveSpreadsheet().getSheetByName(&#x27;Users&#x27;);  var data = sheet.getDataRange().getValues();  for (var i = 0; i &lt; data.length; i++) &#123;    if (data[i][0] == email) &#123;      // Generate a random token for password reset      var token = generateToken();      // Store the token and timestamp in a separate sheet (or update the existing sheet structure)      storeResetToken(email, token);      // Send the reset email      sendResetEmail(email, token);      return ContentService.createTextOutput(JSON.stringify(&#123; status: &quot;success&quot;, message: &quot;Password reset email sent&quot; &#125;)).setMimeType(ContentService.MimeType.JSON);    &#125;  &#125;  return ContentService.createTextOutput(JSON.stringify(&#123; status: &quot;error&quot;, message: &quot;Email not found&quot; &#125;)).setMimeType(ContentService.MimeType.JSON);&#125;function generateToken() &#123;  var charset = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&#x27;;  var token = &#x27;&#x27;;  for (var i = 0; i &lt; 20; i++) &#123;    var randomIndex = Math.floor(Math.random() * charset.length);    token += charset[randomIndex];  &#125;  return token;&#125;function storeResetToken(email, token) &#123;  var sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(&#x27;ResetTokens&#x27;);  // if (!sheet) &#123;    // sheet = SpreadsheetApp.getActiveSpreadsheet().insertSheet(&#x27;ResetTokens&#x27;);    // sheet.appendRow([&#x27;Email&#x27;, &#x27;Token&#x27;, &#x27;Timestamp&#x27;]);  // &#125;  var timestamp = new Date().getTime();  sheet.appendRow([email, token, timestamp]);&#125;function sendResetEmail(email, resetUrl) &#123;  var subject = &#x27;Password Reset Request&#x27;;  var body = &#x27;You requested a password reset. Click the link below to reset your password:\\n\\n&#x27; + resetUrl + &#x27;\\n\\nIf you did not request a password reset, please ignore this email.&#x27;;  GmailApp.sendEmail(email, subject, body);&#125;\r\n建立完成之後發布成為WebApp，會得到一串URL，此為Python中需要引入的BASE_URL\r\nPython端\r\napp.py\r\nimport streamlit as stimport requestsBASE_URL = &#x27;YOUR_GAS_WEB_APP_URL&#x27;def register_user(email, username, password):    response = requests.post(BASE_URL, data=&#123;        &#x27;action&#x27;: &#x27;register&#x27;,        &#x27;email&#x27;: email,        &#x27;username&#x27;: username,        &#x27;password&#x27;: password    &#125;)    return response.json()def login_user(username, password):    response = requests.post(BASE_URL, data=&#123;        &#x27;action&#x27;: &#x27;login&#x27;,        &#x27;username&#x27;: username,        &#x27;password&#x27;: password    &#125;)    return response.json()def forgot_password(email):    response = requests.post(BASE_URL, data=&#123;        &#x27;action&#x27;: &#x27;forgotPassword&#x27;,        &#x27;email&#x27;: email    &#125;)    return response.json()def update_password(username,token, new_password):    response = requests.post(BASE_URL, data=&#123;        &#x27;action&#x27;: &#x27;updatePassword&#x27;,        &#x27;username&#x27;: username,        &#x27;token&#x27;:token,        &#x27;newPassword&#x27;: new_password    &#125;)    return response.json()def main():    st.title(&quot;User Management System&quot;)    menu = [&quot;Home&quot;, &quot;Login&quot;, &quot;Register&quot;, &quot;Forgot Password&quot;, &quot;Update Password&quot;]    choice = st.sidebar.selectbox(&quot;Menu&quot;, menu)    if choice == &quot;Home&quot;:        st.subheader(&quot;Home&quot;)    elif choice == &quot;Login&quot;:        st.subheader(&quot;Login&quot;)        username = st.text_input(&quot;Username&quot;)        password = st.text_input(&quot;Password&quot;, type=&#x27;password&#x27;)        if st.button(&quot;Login&quot;):            result = login_user(username, password)            st.write(result)    elif choice == &quot;Register&quot;:        st.subheader(&quot;Register&quot;)        email = st.text_input(&quot;Email&quot;)        username = st.text_input(&quot;Username&quot;)        password = st.text_input(&quot;Password&quot;, type=&#x27;password&#x27;)        if st.button(&quot;Register&quot;):            result = register_user(email, username, password)            st.write(result)    elif choice == &quot;Forgot Password&quot;:        st.subheader(&quot;Forgot Password&quot;)        email = st.text_input(&quot;Email&quot;)        if st.button(&quot;Submit&quot;):            result = forgot_password(email)            st.write(result)    elif choice == &quot;Update Password&quot;:        st.subheader(&quot;Update Password&quot;)        username = st.text_input(&quot;Username&quot;)        token=st.text_input(&quot;Token&quot;)        new_password = st.text_input(&quot;New Password&quot;, type=&#x27;password&#x27;)        if st.button(&quot;Update&quot;):            result = update_password(username, token,new_password)            st.write(result)if __name__ == &#x27;__main__&#x27;:    main()\r\n將這些內容用Streamlit run app.py 即可看到使用介面\r\n\r\n\r\nimage\r\n\r\n後續要利用的時候就把登入成功的內容放置於session_state中先存起來，再顯示主要操作的介面就可以了!\r\n哈希加密算法\r\nfunction hashPassword(password) &#123;  var rawHash = Utilities.computeDigest(Utilities.DigestAlgorithm.SHA_256, password);  var hash = rawHash.map(function(byte) &#123;    var v = (byte &lt; 0 ? byte + 256 : byte).toString(16);    return v.length == 1 ? &#x27;0&#x27; + v : v;  &#125;).join(&#x27;&#x27;);  return hash;&#125;function registerUser(email, username, password) &#123;  var sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(&#x27;Users&#x27;);  var data = sheet.getDataRange().getValues();  for (var i = 0; i &lt; data.length; i++) &#123;    if (data[i][0] == email) &#123;      return ContentService.createTextOutput(JSON.stringify(&#123; status: &quot;error&quot;, message: &quot;Email already registered&quot; &#125;)).setMimeType(ContentService.MimeType.JSON);    &#125;  &#125;  var hashedPassword = hashPassword(password);  sheet.appendRow([email, username, hashedPassword]);  return ContentService.createTextOutput(JSON.stringify(&#123; status: &quot;success&quot;, message: &quot;User registered successfully&quot; &#125;)).setMimeType(ContentService.MimeType.JSON);&#125;function loginUser(username, password) &#123;  var sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(&#x27;Users&#x27;);  var data = sheet.getDataRange().getValues();  var hashedPassword = hashPassword(password);  for (var i = 0; i &lt; data.length; i++) &#123;    if (data[i][1] == username &amp;&amp; data[i][2] == hashedPassword) &#123;      return ContentService.createTextOutput(JSON.stringify(&#123; status: &quot;success&quot;, message: &quot;Login successful&quot; &#125;)).setMimeType(ContentService.MimeType.JSON);    &#125;  &#125;  return ContentService.createTextOutput(JSON.stringify(&#123; status: &quot;error&quot;, message: &quot;Invalid username or password&quot; &#125;)).setMimeType(ContentService.MimeType.JSON);&#125;function updatePassword(email, token, newPassword) &#123;  var sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(&#x27;ResetTokens&#x27;);  var data = sheet.getDataRange().getValues();  var now = new Date().getTime();  var tokenValid = false;  for (var i = 0; i &lt; data.length; i++) &#123;    if (data[i][0] == email &amp;&amp; data[i][1] == token) &#123;      var timestamp = data[i][2];      if (now - timestamp &lt;= 24 * 60 * 60 * 1000) &#123;  // Token valid for 24 hours        tokenValid = true;        sheet.getRange(i + 1, 3).setValue(0);        break;      &#125;    &#125;  &#125;  if (tokenValid) &#123;    var userSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(&#x27;Users&#x27;);    var userData = userSheet.getDataRange().getValues();    var hashedPassword = hashPassword(newPassword);    for (var j = 0; j &lt; userData.length; j++) &#123;      if (userData[j][0] == email) &#123;        userSheet.getRange(j + 1, 3).setValue(hashedPassword);        return ContentService.createTextOutput(JSON.stringify(&#123; status: &quot;success&quot;, message: &quot;Password updated successfully&quot; &#125;)).setMimeType(ContentService.MimeType.JSON);      &#125;    &#125;  &#125;  return ContentService.createTextOutput(JSON.stringify(&#123; status: &quot;error&quot;, message: &quot;Invalid token or email&quot; &#125;)).setMimeType(ContentService.MimeType.JSON);&#125;\r\n","categories":["專案開發"],"tags":["Streamlit"]},{"title":"Streamlit建置GoogleSheet簡易資料庫","url":"/posts/639809757/","content":"🙌前言\r\nStreamlit是使用python語言的前端套件，他最大的好處是就能透過套件本身程式碼生成一篇篇還算能看的使用者介面，對於Html、CSS、Javascript等前端語言感到不舒服的開發者可以妥善利用，在部署上難度也不高，幾乎可以一鍵達成。\r\n除了python本身內鍵已經有本地端sqlite可以進行資料存儲，如果資料需要上雲的話就會需要額外找尋雲端資料庫來進行資料存放，標準的關聯式有MySQL、postgreSQL、SQLserver等等比較常見的工具、非關聯式資料庫則可以透過mongoDB、firestore等等工具進行挑選。\r\n\r\n本篇要介紹的內容是針對比較簡易的前端介面，可以用Google提供的GoogleSheet來進行資料存放，並且透過GoogleAppScripts來做後端語言進行操作。\r\n\r\n\r\n基本API概念\r\n所謂前端與後端分離開發，就是透過API的方式進行資料交換，API就是一串網址(URL)外加一些夾帶的參數，參數可以是純文字、也可以是物件，然而物件的部分又可分為XML或JSON，這兩項是最常被拿來使用於API的資料交換，包含輸入到後端存放資料或者是從資料庫取出資料到前端進行渲染。\r\n公共工程常用的估價系統(PCCES)便是以XML進行資料交換，詳情可見ExcelVBA@PCCES契約項目後處理，在此不多做說明\r\nJSON\r\n大多數的第三方API都是採用JSON格式進行傳輸，這也是本篇主要資料格式，關於JSON的格式通常是以鍵-值對的方式儲存，也就是所謂的key-value，要進行資料取用或組裝時特別的方便，這也是為什麼會選用他來做為我在streamlit及GAS中的交換媒介。\r\nJSON資料可以分為GAS對象、JSON字串、python對象，每個資料都可以互相轉移，JSON字串主要是在API中所夾帶的字串，其餘python對象、GAS對象則是依照不同語言解析成相對應的物件。\r\n萬一遇見處理多巢階層的過程可以藉由扁平化(將巢狀鍵值對處理到頂層)的方法方便資料取用，也可以透過反扁平化的方法將原本的資料恢復原狀。\r\n在GAS中關於JSON格式的轉換\r\nJSON.parse()\r\nJSON.parse() 方法用於將 JSON 字串解析為 JavaScript\r\n物件。它接受一個合法的 JSON 字串並返回解析後的 JavaScript 值。\r\nJSON.stringify()\r\nJSON.stringify() 方法用於將 JavaScript 物件轉換為 JSON\r\n字串。它接受一個 JavaScript 物件並返回相應的 JSON 格式字串。\r\n在Python中關於JSON格式的轉換\r\njson.dumps()\r\njson.dumps() 方法用於將 Python 物件轉換為 JSON\r\n字串。它接受一個 Python 物件並返回相應的 JSON 格式字串。\r\njson.loads()\r\njson.loads() 方法用於將 JSON 字串解析為 Python\r\n物件。它接受一個合法的 JSON 字串並返回解析後的 Python 值。\r\njson.load()&gt;目前沒用到\r\njson.load() 方法用於從檔案中讀取 JSON 資料並將其解析為\r\nPython 物件。它接受一個可讀取的檔案物件，並返回解析後的 Python 值。\r\nPython對象操作\r\n單層\r\ndata = json.loads(json_str)# 存取一層結構name = data[&#x27;person&#x27;][&#x27;name&#x27;]age = data[&#x27;person&#x27;][&#x27;age&#x27;]# 存取多層結構city = data[&#x27;person&#x27;][&#x27;address&#x27;][&#x27;city&#x27;]zipcode = data[&#x27;person&#x27;][&#x27;address&#x27;][&#x27;zipcode&#x27;]print(name)     # Output: Johnprint(age)      # Output: 30print(city)     # Output: New Yorkprint(zipcode)  # Output: 10001\r\n多層\r\nimport jsonjson_str = &#x27;&#x27;&#x27;&#123;  &quot;person&quot;: &#123;    &quot;name&quot;: &quot;John&quot;,    &quot;age&quot;: 30,    &quot;address&quot;: &#123;      &quot;city&quot;: &quot;New York&quot;,      &quot;zipcode&quot;: &quot;10001&quot;    &#125;  &#125;&#125;&#x27;&#x27;&#x27;def process_json(data):    if isinstance(data, dict):        for key, value in data.items():            print(f&#x27;Key: &#123;key&#125;, Value: &#123;value&#125;&#x27;)            process_json(value)  # 遞迴處理值    elif isinstance(data, list):        for item in data:            process_json(item)  # 遞迴處理列表中的元素data = json.loads(json_str)process_json(data)\r\nGAS對象操作\r\nvar obj = &#123;name: &quot;John&quot;, age: 30&#125;;var jsonString = JSON.stringify(obj);//取值var name = obj.name;var age = obj[&#x27;age&#x27;];//設置obj.name = &#x27;Alice&#x27;;obj[&#x27;age&#x27;] = 25;//循環for (var key in obj) &#123;    if (obj.hasOwnProperty(key)) &#123;        Logger.log(key + &#x27;: &#x27; + obj[key]);    &#125;&#125;\r\n綜合操作\r\nstreamlit\r\nimport streamlit as stimport jsonfrom datetime import date, datetimeimport requests# 模拟一些 session state 数据st.session_state.current_page = &quot;render_page0&quot;st.session_state.submitted = Falsest.session_state.costs = &#123;    &quot;open_channel&quot;: &#123;&quot;name&quot;: &quot;渠道工程&quot;, &quot;unit_cost&quot;: 0, &quot;length&quot;: 0, &quot;total_cost&quot;: 0&#125;,    &quot;bridge&quot;: &#123;&quot;name&quot;: &quot;版橋工程&quot;, &quot;unit_cost&quot;: 0, &quot;quantity&quot;: 0, &quot;total_cost&quot;: 0&#125;,    &quot;wall&quot;: &#123;&quot;name&quot;: &quot;擋土牆&quot;, &quot;unit_cost&quot;: 0, &quot;length&quot;: 0, &quot;total_cost&quot;: 0&#125;,    &quot;road&quot;: &#123;&quot;name&quot;: &quot;道路工程&quot;, &quot;unit_cost&quot;: 0, &quot;quantity&quot;: 0, &quot;total_cost&quot;: 0&#125;,    &quot;falsework&quot;: &#123;&quot;name&quot;: &quot;版樁工程&quot;, &quot;unit_cost&quot;: 0, &quot;quantity&quot;: 0, &quot;total_cost&quot;: 0&#125;,&#125;st.session_state.totalcost = 0st.session_state.inf = &#123;    &quot;work_place&quot;: &quot;&quot;,    &quot;work_place2&quot;: &quot;&quot;,    &quot;work_station&quot;: &quot;&quot;,    &quot;work_name&quot;: &quot;&quot;,    &quot;work_benefit&quot;: &quot;&quot;,    &quot;work_place_detail&quot;: &quot;&quot;,    &quot;work_water_check&quot;: False,    &quot;work_start_date&quot;: date.today(),    &quot;work_end_date&quot;: date.today(),&#125;# 自定义 JSON 序列化器，用于处理日期字段class DateTimeEncoder(json.JSONEncoder):    def default(self, obj):        if isinstance(obj, (datetime, date)):            return obj.isoformat()        return super().default(obj)# 定义一个函数，将 st.session_state 转换为 JSONdef session_state_to_json():    selected_fields = [&quot;costs&quot;, &quot;inf&quot;] # 指定需要转换的字段    session_state_dict = &#123;key: value for key, value in st.session_state.items()if key in selected_fields&#125;    json_data = json.dumps(session_state_dict, cls=DateTimeEncoder)    return json_data# 使用函数并展示结果json_result = session_state_to_json()st.write(st.session_state)st.write(json_result)if st.button(&quot;Submit&quot;):    # 設置 Google Apps Script Web 應用程式的 URL    url = &quot;your_gas_url&quot;    # 發送 POST 請求並傳遞 JSON 資料    response = requests.post(url, data=json_result)    # 檢查請求是否成功    if response.status_code == 200:        st.write(&quot;Request successful!&quot;)    else:        st.write(&quot;Error:&quot;, response.status_code)\r\nGAS\r\n// 定义Google Sheets的IDconst SHEET_ID = &#x27;your_sheet_id&#x27;; // 替换为您的Google Sheets IDfunction doPost(e) &#123;  // 从 POST 请求中获取 JSON 字符串  var jsonString = e.postData.contents;    // 解析 JSON 字符串为对象  var dataOrigin = JSON.parse(jsonString);    var data = flattenObject(dataOrigin);  // 获取活动工作表  var ss = SpreadsheetApp.openById(SHEET_ID);  var sheet = ss.getActiveSheet();    // 获取最后一行，以便在末尾添加新数据  var lastRow = sheet.getLastRow();    // 将数据写入工作表的下一行  for (var key in data) &#123;    var columnIndex = getColumnIndex(sheet, key);    if (columnIndex === -1) &#123; // 如果列不存在，则创建新列      columnIndex = sheet.getLastColumn() + 1;      sheet.getRange(1, columnIndex).setValue(key);    &#125;    if (lastRow===0 )&#123;      sheet.getRange(lastRow + 2, columnIndex).setValue(data[key]);    &#125;else&#123;      sheet.getRange(lastRow + 1, columnIndex).setValue(data[key]);    &#125;  &#125;    // 返回回应给客户端，这是可选的  return ContentService.createTextOutput(&#x27;Success&#x27;).setMimeType(ContentService.MimeType.TEXT);&#125;// 获取列的索引，如果不存在，则返回-1function getColumnIndex(sheet, columnName) &#123;  var maxColumns = sheet.getMaxColumns(); // 获取工作表的最大列数  if (maxColumns &lt; 1) &#123;    return -1; // 如果没有列存在，则直接返回 -1  &#125;  var headersRange = sheet.getRange(1, 1, 1, maxColumns);  var headersValues = headersRange.getValues()[0]; // 只获取第一行数据  for (var i = 0; i &lt; headersValues.length; i++) &#123;    if (headersValues[i] === columnName) &#123;      return i + 1;    &#125;  &#125;  return -1; // 如果找不到，则返回 -1&#125;// 定义一个扁平化嵌套对象的函数function flattenObject(obj, parentKey = &#x27;&#x27;) &#123;  // 检查 obj 是否存在且不为 undefined 或 null  if (!obj || typeof obj !== &#x27;object&#x27;) &#123;    return &#123;&#125;;  &#125;    let result = &#123;&#125;;  for (const [key, value] of Object.entries(obj)) &#123;    const newKey = parentKey ? `$&#123;parentKey&#125;.$&#123;key&#125;` : key;    if (typeof value === &#x27;object&#x27; &amp;&amp; value !== null) &#123;      const flattened = flattenObject(value, newKey);      result = &#123; ...result, ...flattened &#125;;    &#125; else &#123;      result[newKey] = value;    &#125;  &#125;  return result;&#125;\r\nJSON物件特殊處理\r\n資料扁平化\r\nfunction doPost(e) &#123;  const jsonData = &#123;&quot;name&quot;:&quot;John&quot;,&quot;age&quot;:30,&quot;address&quot;:&#123;&quot;city&quot;:&quot;New York&quot;,&quot;country&quot;:&quot;USA&quot;&#125;&#125;;  // 扁平化对象  const flattenedObject = flattenObject(jsonData);    // 将扁平化后的对象转换为 JSON 字符串  const jsonString = JSON.stringify(flattenedObject);    // 返回 JSON 格式的数据  return ContentService.createTextOutput(jsonString).setMimeType(ContentService.MimeType.JSON);&#125;// 定义一个扁平化嵌套对象的函数function flattenObject(obj, parentKey = &#x27;&#x27;) &#123;  // 检查 obj 是否存在且不为 undefined 或 null  if (!obj || typeof obj !== &#x27;object&#x27;) &#123;    return &#123;&#125;;  &#125;    let result = &#123;&#125;;  for (const [key, value] of Object.entries(obj)) &#123;    const newKey = parentKey ? `$&#123;parentKey&#125;.$&#123;key&#125;` : key;    if (typeof value === &#x27;object&#x27; &amp;&amp; value !== null) &#123;      const flattened = flattenObject(value, newKey);      result = &#123; ...result, ...flattened &#125;;    &#125; else &#123;      result[newKey] = value;    &#125;  &#125;  return result;&#125;// 使用示例const nestedObject = &#123;  name: &quot;John&quot;,  age: 30,  address: &#123;    city: &quot;New York&quot;,    country: &quot;USA&quot;  &#125;&#125;;const flattenedObject = flattenObject(nestedObject);console.log(flattenedObject);console.log(Object.keys(flattenedObject))console.log(Object.values(flattenedObject))//[name,age,address.city,address.country]//[John,30,New York,USA]\r\n資料扁平化回復\r\nfunction unflattenObject(obj) &#123;  // 创建一个新的对象来存储恢复后的数据  let result = &#123;&#125;;  // 遍历扁平化后的对象  for (const key in obj) &#123;    if (Object.hasOwnProperty.call(obj, key)) &#123;      // 将键名拆分成各级别的嵌套键名      const keys = key.split(&#x27;.&#x27;);      let nestedObj = result;      // 迭代嵌套键名，并在新对象中重新创建嵌套结构      for (let i = 0; i &lt; keys.length; i++) &#123;        const nestedKey = keys[i];        if (i === keys.length - 1) &#123;          // 如果是最后一级键名，直接将值赋给最后一级键          nestedObj[nestedKey] = obj[key];        &#125; else &#123;          // 如果不是最后一级键名，检查是否需要创建嵌套对象          nestedObj[nestedKey] = nestedObj[nestedKey] || &#123;&#125;;          nestedObj = nestedObj[nestedKey];        &#125;      &#125;    &#125;  &#125;  return result;&#125;\r\nVBA部分\r\n\r\n只是先做紀錄，之後再跟collection的資料格式一起介紹\r\n\r\nSub TestDictionary()    Dim jsonData As Object    Set jsonData = CreateObject(&quot;Scripting.Dictionary&quot;)        &#x27; 添加?值?    jsonData(&quot;name&quot;) = &quot;John&quot;    jsonData(&quot;age&quot;) = 30        &#x27; 添加嵌套的字典?象    Dim address As Object    Set address = CreateObject(&quot;Scripting.Dictionary&quot;)    address(&quot;city&quot;) = &quot;New York&quot;    address(&quot;country&quot;) = &quot;USA&quot;    Set jsonData(&quot;address&quot;) = address        &#x27; ???值?    Debug.Print &quot;Name: &quot; &amp; jsonData(&quot;name&quot;)    Debug.Print &quot;Age: &quot; &amp; jsonData(&quot;age&quot;)    Debug.Print &quot;City: &quot; &amp; jsonData(&quot;address&quot;)(&quot;city&quot;)    Debug.Print &quot;Country: &quot; &amp; jsonData(&quot;address&quot;)(&quot;country&quot;)End Sub\r\nVBA-JSON\r\n參考\r\n總結\r\n\r\n使用Streamlit和Google Sheets：\r\n\r\nStreamlit能快速生成前端介面，對不熟悉前端技術的開發者友好。\r\nGoogle Sheets作為雲端資料庫，結合Google Apps Script\r\n(GAS)實現資料操作。\r\n\r\nJSON格式的優勢：\r\n\r\nJSON是API資料交換中常用的格式，方便資料取用和組裝。\r\n文章介紹了在Python和GAS中如何進行JSON資料的解析和生成。\r\n\r\n多層資料結構處理技術：\r\n\r\n使用扁平化和反扁平化技術，方便處理和還原多層嵌套的資料結構。\r\n提供了Python和GAS中處理多層資料結構的範例。\r\n\r\n實際應用範例：\r\n\r\n展示了如何在Streamlit應用中將資料轉換為JSON格式，並通過HTTP\r\nPOST請求發送到GAS後端。\r\n在GAS後端接收並解析JSON資料，將其寫入Google Sheets的具體步驟。\r\n\r\nPython和GAS中的JSON操作方法：\r\n\r\n詳述了在Python中使用json.dumps()和json.loads()進行JSON格式轉換。\r\n說明了在GAS中使用JSON.stringify()和JSON.parse()處理JSON資料。\r\n\r\n\r\n","categories":["基本概念"],"tags":["Streamlit","GAS"]},{"title":"VBA橫斷面法面積批次處理","url":"/posts/2533511128/","content":"前言\r\n工程特性如為帶狀工程，比如:水溝、道路等等，通常會以橫斷面法作為土方計算的數量依據，此指土方計算不外乎為:挖方、填方、回填方、CLSM之類。\r\n在繪製土方基本資料時，面積的框選便會是決定數量很重要的部分，實務上的土方計算流程為:\r\n圖層設定:\r\n\r\n原地面線\r\n結構線\r\n開挖線\r\n填方線\r\n開挖面積\r\n挖方面積\r\n\r\n\r\n繪製挖方面積時，將原地面線與開挖線隔離顯示，透過BO或HATCH生成面積\r\n繪製填方面積時，將回填線、結構線、開挖線隔離顯示，透過BO或HATCH生成面積\r\n\r\n\r\n封閉聚合線\r\n\r\nCAD內建指令'BO'會出現一張介面，可以藉由點選內部點生成封閉聚合線，指令'-BO'則可以略過介面的程序直接點選，此時封閉聚合線會有'面積'屬性。\r\n\r\n填充線\r\n\r\nCAD內建指令'HATCH'可以點選內部點生成填充線，此時填充線會有'面積'屬性，須注意之前測試過HATCH可能會有些許的誤差，這個也不清楚原因為何...\r\n\r\nVBA批次處理流程\r\n正常的作業流程會將每一個樁號底下的面積逐筆紀錄作加總，算完的數據會修改到橫斷面上所記載的挖方面積數字、填方面積數字，後續再將這些數字填報到土方計算表，稍有恍神則容易出錯，也因此若這些內容都可以用CAD中對應圖元的面積屬性進行處理，並且將資料傳輸到土方計算表及回歸到圖面修訂記載數字，這會讓整個土方計算作業簡單很多。\r\n\r\n目標為希望能夠框選一次範圍，就將所有的面積計算完畢並且放置於對應的樁號，省下作業時間!!!\r\n\r\n要將圖面進行批次處理時，會需要進行下列步驟搭配VBA執行便能順利完成\r\n主要介面\r\n\r\n\r\n橫斷面圖範例\r\n\r\n\r\n\r\n資料庫介面\r\n\r\n建立樁號外框\r\n每一個橫斷面圖都會有它所代表的樁號名稱及橫斷面圖範圍(此處是指BORDER欄位)，將外框完成之後做適當的放大縮小，目標是讓所有與該樁號相關的土方面積'形心'都能被完整包覆在框框裡面，後續要判斷面積歸屬時可以順利執行。\r\n點選面積\r\n面積部分有兩種實作方式\r\n\r\n如前言所述用不同的圖層來預先定義面積歸屬項目(挖方、填方)並且透過BO或HATCH來點擊'內部點'，但這樣還是免不了會有手動處理的部分。\r\n用幾何數學方法來處理，原地面線是f(x)，開挖線是g(x)，開挖線先將兩端用CAD中的IntersectWith做延伸後，在用f(x)與g(x)的幾何關係計算面積，相關VBA程式碼實作如下:\r\n\r\n&#x27;===Main Function===Sub plotDigLine(ByVal EG As Object, ByVal EGVertices)Dim IsIntersect As BooleanCall CAD.GetBoundingBox(buttomCONC, MinX, MinY, MaxX, MaxY)Dim vertices(4 * 2 - 1) As Doublevertices(0) = MinX - 300 - 30vertices(1) = MinY + 100vertices(2) = MinX - 300vertices(3) = MinYvertices(4) = MaxX + 300vertices(5) = MinYvertices(6) = MaxX + 300 + 30vertices(7) = MinY + 100Set DL = CAD.AddLWPolyLine(vertices)Call CAD.setLayer(DL, &quot;CAL&quot;)&#x27;DL.Layer = &quot;CAL&quot; &#x27; &quot;橫斷面-挖方線&quot;retpt = myFunc.SortPTArray(CAD.IntersectWith(DL, EG, 1, IsIntersect))If IsIntersect = False Then Exit Subvertices(0) = retpt(0, 0)vertices(1) = retpt(0, 1)vertices(6) = retpt(UBound(retpt, 1), 0) &#x27;- 3 + 1)vertices(7) = retpt(UBound(retpt, 1), 1) &#x27;- 3 + 2)&#x27;========以邊界為基準================&#x27;vertices(0) = EGVertices(0)&#x27;vertices(1) = EGVertices(1)&#x27;vertices(6) = EGVertices(UBound(EGVertices) - 1)&#x27;vertices(7) = EGVertices(UBound(EGVertices))&#x27;====================================DL.DeleteSet DL2 = CAD.AddLWPolyLine(vertices)DL2.Layer = &quot;CAL&quot; &#x27;&quot;橫斷面-挖方線&quot;&#x27;============匯入挖方面積==================Dim stoneObj As New clsStoneDLArea = stoneObj.getDLArea(EG, DL2)With Sheets(&quot;中心線&quot;)        Set rng = .Columns(1).Find(loc)        If Not rng Is Nothing Then        r = rng.Row    .Cells(r, 5) = DLArea        End IfEnd WithEnd Sub&#x27;====clsCAD===Function IntersectWith(ByVal PL1, ByVal PL2, ByVal mode As Byte, ByRef IsIntersect As Boolean)IsIntersect = FalseDim coll As New CollectionIf CADVer = &quot;ICAD&quot; Then        On Error GoTo ERRORHANDLE &#x27;20210901 錯誤偵測    Set retpt = PL1.IntersectWith(PL2, mode) &#x27;acExtendThisEntity)        For Each it In retpt            coll.Add it.x        coll.Add it.y        coll.Add it.Z        Next        If coll Is Nothing ThenERRORHANDLE:        &#x27;intersectWith = &quot;EMPTY&quot;    Else        IntersectWith = myFunc.tranColl2Array(coll)        IsIntersect = True    End If    Else    retpt = PL1.IntersectWith(PL2, mode) &#x27;acExtendThisEntity)        If UBound(retpt) = -1 Then       &#x27; IntersectWith = &quot;EMPTY&quot;    Else        IntersectWith = retpt        IsIntersect = True    End IfEnd IfEnd Function&#x27;====clsStone===&#x27;TODO:&#x27;1.sort X coordinate&#x27;2.define border&#x27;3.decide X-valueFunction getDLArea(ByVal EG, ByVal DL)Set PLobj1 = RevisePL(EG)EG.DeletePL1_X = myFunc.tranColl2Array(getcoll(PLobj1, &quot;X&quot;))PL1_Y = myFunc.tranColl2Array(getcoll(PLobj1, &quot;Y&quot;))Set PLobj2 = RevisePL(DL)DL.DeletePL2_X = myFunc.tranColl2Array(getcoll(PLobj2, &quot;X&quot;))PL2_Y = myFunc.tranColl2Array(getcoll(PLobj2, &quot;Y&quot;))Call defineBorder(PL1_X, PL2_X, BL, BR)getDLArea = calculateArea_test(PL1_X, PL1_Y, PL2_X, PL2_Y, BL, BR)End FunctionFunction RevisePL(ByVal PLobj) &#x27;由左至右排序Dim coll As New Collectionco = 3If TypeName(PLobj) Like &quot;*LWPolyline&quot; Then co = 2  &#x27;IIcadLightWeightPolylinearr = CAD.tranIPoints(PLobj.coordinates)Debug.Print TypeName(PLobj)X1 = arr(0)Xn = arr(UBound(arr) - co + 1)If X1 &gt; Xn Then    Set RevisePL = CAD.ReverseLine(ByVal PLobj)Else    Set RevisePL = PLobjEnd IfFor i = 0 To UBound(arr) - co Step co    X1 = arr(i)    X2 = arr(i + co)        If X1 = X2 Then arr(i + co) = arr(i + co) + 0.001 &#x27;若為垂直則微調往右偏移NextSet RevisePL = CAD.AddLWPolyLine(arr)RevisePL.Layer = PLobj.LayerEnd FunctionFunction calculateArea_test(ByVal PL1_X, ByVal PL1_Y, ByVal PL2_X, ByVal PL2_Y, ByVal BL, ByVal BR)X_sort = myFunc.BubbleSort_array(myFunc.combineArray(PL1_X, PL2_X))For i = LBound(X_sort) To UBound(X_sort) - 1        X1 = X_sort(i)    X2 = X_sort(i + 1)        dx = X2 - X1        If X1 &gt;= BL And X2 &lt;= BR Then                Y1f = getYbyX(X1, PL1_X, PL1_Y)        Y2f = getYbyX(X1, PL2_X, PL2_Y)                dYf = Y1f - Y2f                Y1b = getYbyX(X2, PL1_X, PL1_Y)        Y2b = getYbyX(X2, PL2_X, PL2_Y)                dYb = Y1b - Y2b        If dYf &gt; 0 And dYb &lt; 0 Then &#x27;與基準線交叉(正到負)                    X_intersect = getIntersectX(X1, X2, Y1f, Y1b, Y2f, Y2b)            dA = dYf * (X_intersect - X1) / 2            &#x27;Set lineObj = CAD.AddLineCO(X1, Y1f, X1, Y2f)                    ElseIf dYf &lt; 0 And dYb &gt; 0 Then &#x27;與基準線交叉(負到正)                    X_intersect = getIntersectX(X1, X2, Y1f, Y1b, Y2f, Y2b)            dA = dYb * (X2 - X_intersect) / 2            &#x27;Set lineObj = CAD.AddLineCO(X2, Y1b, X2, Y2b)                    ElseIf dYf &gt;= 0 And dYb &gt;= 0 Then &#x27;皆在基準線下方                    dA = (dYf + dYb) * dx / 2            &#x27;Set lineObj = CAD.AddLineCO(X1, Y1f, X1, Y2f)            &#x27;Set lineObj = CAD.AddLineCO(X2, Y1b, X2, Y2b)                Else            dA = 0                End If                &#x27;Debug.Print &quot;dYf=&quot; &amp; dYf &amp; &quot;,dYb=&quot; &amp; dYb &amp; &quot;,dA=&quot; &amp; dA        sA = sA + dA            End If    NextcalculateArea_test = Round(sA / 1000000, 2)End FunctionFunction getIntersectX(ByVal X1 As Double, ByVal X2 As Double, _                        ByVal Y1f As Double, ByVal Y1b As Double, _                        ByVal Y2f As Double, ByVal Y2b As Double)dx = X2 - X1y1_slope = (Y1b - Y1f) / dxy2_slope = (Y2b - Y2f) / dxslope_change = Abs(y1_slope - y2_slope)dY_f = Abs(Y1f - Y2f)getIntersectX = X1 + dY_f / slope_changeEnd FunctionFunction getYbyX(ByVal x As Double, ByVal PL_X, ByVal PL_Y)For i = LBound(PL_X) To UBound(PL_X) - 1        X1 = PL_X(i)    X2 = PL_X(i + 1)    Y1 = PL_Y(i)    Y2 = PL_Y(i + 1)        If X1 = X2 Then X2 = X2 + 0.001: Stop        If x &gt;= X1 And x &lt;= X2 Then                s1 = x - X1        s2 = X2 - x        getYbyX = (s1 * Y2 + s2 * Y1) / (s1 + s2)                Exit For          End If    NextEnd Function\r\n判斷面積歸屬\r\n面積歸屬的判定方法為該封閉聚合線的形心點或填充線的形心點位於哪個樁號外框中，判定屬於哪個外框後取出面積並做挖方加總或填方加總(看取出的圖層是哪一種)，關於點與外框的位置判定關係請參考下列程式碼:\r\n此處範例是用HATCH的面積取出其值，ssetAreas先做好Hatch的篩選才進行後續內容，有需要者可以改用polyline\r\nSub CalcCABA() &#x27;20210720 updateSet ssetAreas = CAD.CreateSSET(&quot;HA&quot;, &quot;0&quot;, &quot;Hatch&quot;)For Each ssetArea In ssetAreas    &#x27;TODO:    &#x27;1.getMidPoint    &#x27;2.searchLoc    &#x27;3.getAreaCol    &#x27;4.keyinArea        r = getRowFromBorder(ssetArea)    c = getColFromLayerName(ssetArea)        If r &lt;&gt; &quot;&quot; And c &lt;&gt; &quot;&quot; Then shtCL.Cells(r, c) = ssetArea.area / 1000000NextEnd SubFunction getColFromLayerName(ByVal ha)With shtCL    CD = ha.Layer &#x27;橫斷面-挖方        targetColName = Split(CD, &quot;-&quot;)(1)    Set rng = .Rows(2).Find(targetColName)        getColFromLayerName = rng.ColumnEnd WithEnd FunctionFunction getRowFromBorder(ByVal ha)    Call CAD.GetBoundingBox(ha, MinX, MinY, MaxX, MaxY)    midX = (MinX + MaxX) / 2    midY = (MinY + MaxY) / 2    With shtCL        lr = .Cells(.Rows.Count, 1).End(xlUp).Row            For r = 3 To lr                    BorderPTs = Split(.Cells(r, 3), &quot;,&quot;)                        If UBound(BorderPTs) = 3 Then                        Border_minX = CDbl(BorderPTs(0))                Border_minY = CDbl(BorderPTs(1))                Border_maxX = CDbl(BorderPTs(2))                Border_maxY = CDbl(BorderPTs(3))                                If midX &gt;= Border_minX And midX &lt;= Border_maxX And midY &gt;= Border_minY And midY &lt;= Border_maxY Then                                        getRowFromBorder = r                    Exit For                                    End If                        End If                    Next    End WithEnd Function\r\n數據回歸圖面\r\n我這裡是採用屬性圖塊方式處理，如果不要那麼麻煩也可以用最簡單的text判定樁號的形心位置後，做相對文字偏移並且加入挖方填方面積文字就可以了，這樣可以有效避免沒有圖塊的問題。\r\nSub DrawCABA_Main() &#x27;將橫斷面說明的CL、CA、BA刪除後重整Set sset = CAD.CreateSSET(&quot;Title&quot;, &quot;8&quot;, &quot;TITLE&quot;)For Each it In sset            If TypeName(it) = &quot;IAcadBlockReference&quot; Then            myAttr = it.GetAttributes        HSecLoc = myAttr(0).TextString                s = returnCABA(HSecLoc)                tmp = Split(s, &quot;,&quot;)                myAttr(1).TextString = tmp(0)        myAttr(2).TextString = &quot;挖方=&quot; &amp; Round(tmp(1), 2) &amp; &quot; m2&quot;        myAttr(3).TextString = &quot;填方=&quot; &amp; Round(tmp(2), 2) &amp; &quot; m2&quot;        &#x27;myAttr(4).TextString = &quot;CLSM=&quot; &amp; Round(tmp(3), 2) &amp; &quot; m2&quot;                End IfERRORHANDLE:NextEnd SubPrivate Function returnCABA(ByVal HSecLoc As String)With shtCL    Set rng = .Cells.Find(HSecLoc)        r = rng.Row        deltaH = .Cells(r, 2 + 2)    CA = .Cells(r, 3 + 2)    BA = .Cells(r, 4 + 2)    RA = .Cells(r, 5 + 2)        returnCABA = deltaH &amp; &quot;,&quot; &amp; CA &amp; &quot;,&quot; &amp; BA &amp; &quot;,&quot; &amp; RAEnd WithEnd Function\r\n生成報告\r\n這裡就是單純的對格子塞資料計算總數而已，僅提供成果供參。\r\n\r\n\r\n土方報告成果\r\n\r\n更多細節\r\n有需要更多技術細節內容再請來信討論或LINE進行聯繫。\r\n","categories":["專案開發"],"tags":["AutoCAD VBA","Excel VBA"]},{"title":"VBA編輯器上的版本控制","url":"/posts/3829840047/","content":"前言\r\n在撰寫程式碼時，許多人習慣將程式與檔案綁定，並利用文件名稱來標記每次版本的修改。例如，將當天日期加在檔案名稱後來區隔版本，如\r\n縱斷面繪圖20230622.xls。這是我過去對版本控制的理解，然而，這樣做的問題是檔案數量快速增長，且檔案名稱無法清楚標示每次修改的具體內容。\r\n更糟的是，當這些檔案分散於不同的電腦和資料夾中，若同名的檔案有所不同，卻無法得知具體改動了哪些部分。這樣的管理方式會造成很大的困擾，也促使我開始尋找更有效的版本控制方法。\r\n因此，我開始探索如何在 VBA 中實現「真」版本控制，並結合\r\nGit 來管理程式碼。\r\n更新註記 (2024/05/19)\r\n當我將程式上傳至 GitHub 時，發現因為筆記本的預設編碼為\r\n\"ANSI\"，上傳的中文部分會顯示為亂碼。為了解決這個問題，我將編碼另存為\r\n\"UTF-8\"，這樣可以正常顯示。但是，若將 \"UTF-8\" 編碼匯入 Excel VBA IDE\r\n時，由於 Excel 預設支援 ANSI 編碼，中文會出現錯誤。\r\n\r\n編輯器開發環境\r\n在撰寫 VBA 程式碼時，主要會有以下幾個區域來放置程式碼：\r\n\r\nExcel 物件（如 ThisWorkbook, Worksheet）\r\n模組（Module）\r\n物件類別模組（Class）\r\n表單（Form）\r\n\r\n在這篇文章中，我假設程式碼並未直接寫在 Worksheet\r\n中，因為這樣的程式碼會帶來許多匯入上的麻煩。而 ThisWorkbook\r\n雖然屬於 doccls\r\n類型的一部分，但其中可能會有需要手動處理的特殊情況，開發者需根據需要自行處理這些內容。\r\nGIT 基本操作\r\n對於 GIT\r\n的基本操作，網路上有許多資源可以參考。感謝六角學院的Youtube教學。\r\n常見的 GIT 操作如下：\r\n\r\ngit init：初始化資料夾\r\ngit add：將檔案加入索引\r\ngit commit：提交版本註記\r\ngit push：將程式碼上傳至 GitHub\r\ngit clone：從 GitHub 下載程式碼\r\ngit fetch：從 GitHub 下載並更新至本地資料夾\r\ngit checkout：切換分支或版本\r\n\r\n操作步驟\r\n\r\n啟用 VBA 設定：在 Excel\r\n中，打開「開發者」選單，並選擇「信任存取 VBA 專案物件模型」。\r\n初始化 Git：打開 Git Bash，指定一個資料夾並執行\r\ngit init。\r\n匯入 Git 模組：在目前的 VBA IDE 中匯入\r\nGIT.bas 模組。\r\n導出程式碼：執行巨集\r\nExportCodesToFolder，並選擇第二步中指定的資料夾。\r\n確認版本：若確定無誤，繼續使用 Git\r\n進行版本控制。若有任何問題，回到第 4 步重新檢查。\r\n進行 Git 操作：使用 Git Bash 進行\r\ngit add、git commit、git push\r\n等操作。\r\n\r\n處理程式碼版本問題\r\n若發現開啟程式碼後發現有問題，可以執行以下步驟：\r\n\r\n在 VBA IDE 中匯入 GIT 模組。\r\n執行 DeleteCodes 來刪除舊有的程式碼。\r\n執行\r\nImportCodes，並選擇指定的資料夾來匯入最新版本的程式碼。\r\n\r\nVBA 程式碼範例\r\n以下是使用 Git 控制 VBA 程式碼版本的核心程式碼範例：\r\n&#x27;TODO:Export folder need to be killedSub ExportCodesToFolder()&#x27;Type: 1=bas,2=cls,3=frmmyFolder = getSavedFolderCall killFilesInFolder(myFolder)Set VBProj = ThisWorkbook.VBProjectFor Each VBComp In VBProj.VBComponents        Select Case VBComp.Type            Case 1: myExtension = &quot;.bas&quot;        Case 2: myExtension = &quot;.cls&quot;        Case 3: myExtension = &quot;.frm&quot;                Case 100: myExtension = &quot;.doccls&quot;        End Select        full_path = myFolder &amp; &quot;\\&quot; &amp; VBComp.Name &amp; myExtension        If myExtension &lt;&gt; &quot;&quot; Then            VBComp.Export (full_path)        End If        If myExtension = &quot;.doccls&quot; And CountFileLines(full_path) = 9 Then Kill full_path    Next VBComp    End SubSub killFilesInFolder(folderPath)Set coll_path = GetFilePathsInFolder(folderPath)For Each filePath In coll_path    Filename = mid(filePath, InStrRev(filePath, &quot;\\&quot;) + 1)    fileExtension = mid(Filename, InStrRev(Filename, &quot;.&quot;) + 1)        If fileExtension = &quot;frm&quot; Or fileExtension = &quot;bas&quot; Or fileExtension = &quot;cls&quot; Or fileExtension = &quot;doccls&quot; Then        Kill filePath    End IfNextEnd SubSub ImportCodes()myFolder = getSavedFolderSet coll_path = GetFilePathsInFolder(myFolder)Call DeleteCodesFor Each filePath In coll_path    Filename = mid(filePath, InStrRev(filePath, &quot;\\&quot;) + 1)    fileExtension = mid(Filename, InStrRev(Filename, &quot;.&quot;) + 1)        If fileExtension = &quot;frm&quot; Or fileExtension = &quot;bas&quot; Or fileExtension = &quot;cls&quot; Then        Call ImportCode(filePath, Filename)    End IfNextEnd SubSub ImportCode(ByVal filePath As String, ByVal Filename As String)extension = mid(Filename, InStrRev(Filename, &quot;.&quot;) + 1)CodeName = mid(Filename, 1, InStrRev(Filename, &quot;.&quot;) - 1)If CodeName = &quot;GIT&quot; Then Exit SubSet VBProj = ThisWorkbook.VBProject&#x27;If checkIfCodeExist(CodeName) = True Then&#x27;&#x27;    Set vbcomp = VBProj.VBComponents(CodeName)&#x27;    VBProj.VBComponents.Remove (vbcomp)&#x27;&#x27;End IfVBProj.VBComponents.Import (filePath)End SubSub DeleteCodes()&#x27;Type: 1=bas,2=cls,3=frmSet VBProj = ThisWorkbook.VBProjectFor Each VBComp In VBProj.VBComponents        Select Case VBComp.Type            Case 1: myExtension = &quot;.bas&quot;        Case 2: myExtension = &quot;.cls&quot;        Case 3: myExtension = &quot;.frm&quot;                Case 100: myExtension = &quot;.doccls&quot;        End Select        If VBComp.Type &lt;&gt; 100 And VBComp.Name &lt;&gt; &quot;GIT&quot; Then        VBProj.VBComponents.Remove (VBComp)            End If    Next VBCompEnd Sub&#x27;--------FUNCTION------------Function GetFilePathsInFolder(ByVal folderPath As String)    Dim coll As New Collection    Dim fso As Object    &#x27;Dim folderPath As String    Dim folder As Object    Dim file As Object    Set fso = CreateObject(&quot;Scripting.FileSystemObject&quot;)   &#x27; folderPath = getSavedFolder    Set folder = fso.GetFolder(folderPath)        For Each file In folder.Files        coll.Add file.Path            Next file        Set file = Nothing    Set folder = Nothing    Set fso = Nothing        Set GetFilePathsInFolder = coll    End FunctionFunction getSavedFolder()    Set fldr = Application.FileDialog(4)        With fldr        .Title = &quot;Select a Folder&quot;        .AllowMultiSelect = False        .InitialFileName = ThisWorkbook.Path        If .Show = -1 Then FolderName = .SelectedItems(1)    End WithgetSavedFolder = FolderNameEnd FunctionFunction checkIfCodeExist(ByVal checkName As String) &#x27;uselessSet VBProj = ThisWorkbook.VBProjectSet VBComps = VBProj.VBComponentscheckIfCodeExist = FalseFor Each it In VBComps    If it.Name = checkName Then                checkIfCodeExist = True: Exit Function            End IfNextEnd FunctionFunction CountFileLines(ByVal filePath)    Dim FileContent As String    Dim fileNumber As Integer    Dim lineCount As Long        &#x27; Open the text file    fileNumber = FreeFile    Open filePath For Input As fileNumber        &#x27; Read the file content line by line and count the lines    Do Until EOF(fileNumber)        Line Input #fileNumber, FileContent        lineCount = lineCount + 1    Loop        &#x27; Close the file    Close fileNumber        &#x27; Display the line count in cell A1    CountFileLines = lineCount    End Function&#x27;--------TMP_CODE-------------Function tmp_deleteCodes()Set VBProj = ThisWorkbook.VBProjectSet VBComps = VBProj.VBComponentsFor Each it In VBComps        If it.Name Like &quot;*2&quot; And it.Type &lt;&gt; 100 Then        CodeName = it.Name                Set VBComp = VBProj.VBComponents(CodeName)        VBProj.VBComponents.Remove (VBComp)            End If    NextEnd Function\r\n","categories":["基本原理"],"tags":["GIT","Github"]},{"title":"openpyxl照片處理筆記","url":"/posts/1384887565/","content":"前言\r\n目前在處理輸出報表的實務上會遇到要貼上照片的問題，有關python在處理Excel照片部分會需要透過openpyxl裡面相關的套件進行，希望能夠達成下列情況:\r\n給定照片之後可以依照儲存格的範圍貼上照片，儲存格可能是單一儲存格或者是合併儲存格，找出儲存格範圍寬度、儲存格範圍高度\r\n\r\n最適合的方式計算過程\r\n\r\n\r\n照片寬的，比例設定為儲存格範圍寬度/照片寬度，照片長寬同乘上這個比例放大縮小\r\n照片長的，比例設定為儲存格範圍高度/照片高度，照片長寬同乘上這個比例放大縮小\r\n\r\n\r\n照片貼上方式\r\n貼到一定範圍間\r\nhttps://openpyxl.readthedocs.io/en/latest/_modules/openpyxl/drawing/spreadsheet_drawing.html#TwoCellAnchor\r\nimport streamlit as stfrom openpyxl import load_workbookfrom openpyxl.drawing.image import Image as OpenpyxlImagefrom openpyxl.drawing.spreadsheet_drawing import AnchorMarker,TwoCellAnchorimport iodef is_merged_cell(ws, col, row):    for merged_range in ws.merged_cells.ranges:        if ws.cell(row=row+1, column=col+1).coordinate in merged_range:            return merged_range    return Nonedef insert_image(worksheet,img,target_row,target_col):    col1,row1,col2,row2=(is_merged_cell(worksheet, target_col,target_row).bounds)    marker1=AnchorMarker(col=col1-1, row=row1-1)    marker2=AnchorMarker(col=col2, row=row2)    img.anchor = TwoCellAnchor(_from=marker1, to=marker2)    worksheet.add_image(img)# Streamlit application titlest.title(&quot;Excel Image Insertion Tool&quot;)# File uploaduploaded_excel = st.file_uploader(&quot;Upload Excel file&quot;, type=[&quot;xlsx&quot;])uploaded_image = st.file_uploader(&quot;Upload image file&quot;, type=[&quot;png&quot;, &quot;jpg&quot;, &quot;jpeg&quot;])uploaded_image2 = st.file_uploader(&quot;Upload image file2&quot;, type=[&quot;png&quot;, &quot;jpg&quot;, &quot;jpeg&quot;])# Input for sheet name and cell locationsheet_name = st.text_input(&quot;Enter sheet name&quot;, &quot;概要表&quot;)cell_location = st.text_input(&quot;Enter cell location for image insertion&quot;, &quot;E3&quot;)if uploaded_excel and uploaded_image and uploaded_image2:    # Read Excel file    workbook = load_workbook(filename=uploaded_excel)        # Check if sheet exists    if sheet_name not in workbook.sheetnames:        st.error(f&quot;Sheet &#x27;&#123;sheet_name&#125;&#x27; does not exist!&quot;)    else:        worksheet = workbook[sheet_name]        # Load image        img = OpenpyxlImage(uploaded_image)        img2=OpenpyxlImage(uploaded_image2)        insert_image(worksheet,img,3,5) #E3        insert_image(worksheet,img2,14,5) #E14        # Save modified Excel file        output = io.BytesIO()        workbook.save(output)        output.seek(0)                # Provide download link        st.download_button(label=&quot;Download modified Excel file&quot;,                           data=output,                           file_name=&quot;modified_excel.xlsx&quot;)        st.success(&quot;Image successfully inserted into Excel file!&quot;)\r\n直接貼到左上角點\r\n目前openpyxl的套件只能透過OneCellAnchor處理，但是照片大小無從適應(也許是我還沒找到方法)。\r\n貼到左上角點之後進行偏移(目前施工照片是這樣處理)\r\nVBA 內容\r\ndblGap = 2#Count = 0For Each fleTmp In fldMain.Files    strTmp = UCase(fsoMain.GetExtensionName(fleTmp.path))    If strTmp = &quot;JPG&quot; Or strTmp = &quot;JPEG&quot; Then        Count = Count + 1        With shtAct            Set ranOri = .Range(.Cells(2 + (Count - 1) * 14, 4), .Cells(2 + (Count - 1) * 14, 4))            Set ranNum = ranOri.Offset(2, -2)            ranNum = Count        End With        Set picAct = shtAct.Pictures.Insert(fleTmp.path)        With picAct            .ShapeRange.LockAspectRatio = msoTrue &#x27;鎖定照片長寬比            If .Height &gt; .Width Then &#x27;直式                Set ranOri = ranOri.Resize(13, 1) &#x27;.Merge                ranOri.Merge            Else &#x27;橫式                Set ranOri = ranOri.Offset(4, -2).Resize(9, 3) &#x27;.Merge                ranOri.Merge            End If            dblRatioPic = .Width / .Height            dblRatioOri = ranOri.Width / ranOri.Height            If dblRatioPic &gt; dblRatioOri Then &#x27;寬度控制                .Width = ranOri.Width - 2 * dblGap                .Top = ranOri.Top + 0.5 * ranOri.Height - 0.5 * .Height                .Left = ranOri.Left + dblGap            Else                                &#x27;高度控制                .Height = ranOri.Height - 2 * dblGap                .Top = ranOri.Top + dblGap                .Left = ranOri.Left + 0.5 * ranOri.Width - 0.5 * .Width            End If        End With    End IfNext fleTmp\r\n開發小問題\r\nI/O operation on closed file\r\nSol:\r\n如果uploaded_file沒有先經過img_file進行儲存的話，會在OpenpyxlImage處理完畢之後就close\r\nimg1_file = io.BytesIO(st.session_state.uploaded_file1.getvalue())img1 = OpenpyxlImage(img1_file)img2_file = io.BytesIO(st.session_state.uploaded_file2.getvalue())img2 = OpenpyxlImage(img2_file)img3_file = io.BytesIO(st.session_state.uploaded_file3.getvalue())img3 = OpenpyxlImage(img3_file)# img1=OpenpyxlImage(st.session_state.uploaded_file1)insert_image(sheet,img1,3,5)# img2=OpenpyxlImage(st.session_state.uploaded_file2)insert_image(sheet,img2,14,5)# img3=OpenpyxlImage(st.session_state.uploaded_file3)insert_image(sheet,img3,14,8)\r\nref\r\nhttps://blog.csdn.net/chenliang1038/article/details/119410308\r\n","categories":["基本原理"],"tags":["python"]},{"title":"VBA自學心得","url":"/posts/3619695554/","content":"🙌前言\r\n因為工作的緣故，日常會接觸大量的Excel操作，過程不外乎都是一些重複又無趣的動作，也讓我起心動念要透過程式碼的方法來解決這些問題，我操作的軟體是Excel，那直接採用ExcelVBA的語言會是最佳的一個路徑。\r\n程式語言終究還是一種與電腦溝通的工具，重點是你有什麼生活中的問題要進行實作，能夠解決問題的語言就是好語言。\r\n以下是我在自學路上的一些心得，與各位做個分享。\r\n\r\n\r\n💭自學心態\r\n\r\n自學必須要有目標，達成目標之後才會有成就感。\r\n\r\n想當初在學階段，學習新的事物其實並不了解是為了什麼，僅認知到是為了考試而讀書，也因此學完的東西沒有被應用，久而久之就還給老師了。\r\n出社會的時候，生活上有各式各樣的問題等待被解決，而此時的目標便是找出解決問題的答案，無論是實體書、線上課程或網路上的資源，學習資源一直都有，此外還需要具備足夠探索的時間，否則在交卷期程的壓力下，你肯定會土法煉鋼趕緊交差了事。\r\n\r\n找出生活中的應用目標\r\n設定足夠找答案的時間\r\n\r\n找尋應用目標\r\n可以先朝著很常碰到、每次都花很多時間的方向去找題目，VBA的主要功能就是簡化流程、處理大量的重複性問題，包含資料的建檔、匯入、輸出報表...等，一個專案只要可以遵循20/80法則，先處理80%的麻煩事，對於整個專案的執行就會輕鬆很多了!\r\n\r\n🎯基本技巧\r\n程式碼只是一種溝通語言，不需要把整本字典拿出來一字一句去背，只需要挑選對你有幫助的語法來組成剛好可以解決你的問題的內容就好，對於VBA來說大部分的內容網路上都會有說明，以下會建議學習順序與參考資料\r\n資料庫概念\r\n在正統資料庫的設計上有所謂正規化的概念，目的是將資料庫的內容以最小單元的方式進行，通常是記錄文字內容而已，如有圖片或檔案則以外部連結進行替代。\r\nExcel的單元分類\r\n\r\n儲存格(cell)\r\n欄(column)、列(row)\r\n工作表(sheet)\r\n活頁簿(workbook)\r\n\r\n儲存格以每格存放一個資料為原則，避免跨格合併的方式進行資料存放。\r\n開發人員環境\r\nExcel預設會把開發環境關起來，先把開發環境開起來才有地方寫程式碼。\r\nVBA環境設定-GT\r\nWang\r\n開發單元\r\nSub的概念其實就是腳本執行的單元，可以透過按鈕指定巨集執行，也可以透過其他Sub來呼叫(call)執行，此外Function也是類似的概念，不過它還可以額外回傳結果。\r\nSub\r\nvs Function-GT Wang\r\n資料型態\r\n雖然VBA本身不太要求正確的資料型態，算是比較不嚴謹的語言，但了解一下double、string、integer、date、object之間的差異會比較好在程式碼最上層寫下Option\r\nExplicit，會使撰寫過程必須要宣告參數的資料型態，有助於達成良好的程式寫作習慣(未來轉換到別的語言比較不會那麼痛苦)。\r\nVBA資料型態-GT\r\nWang\r\n邏輯操作\r\n腳本執行過程通常會有條件判斷跟迴圈循環，根據實際需求演算，看範例才會清楚，不外乎就是\r\nif else、for i=1 to n、do loop ...\r\n等。此外關於如何加減乘除、等於不等於之類的運算子也是會被參雜在其中，這也是必須要知道的。\r\nVBA運算子-GT\r\nWang\r\nVBA條件判斷-GT\r\nWang\r\nVBA迴圈控制-GT\r\nWang\r\n除錯技巧\r\n程式撰寫過程必須要知道所設定的參數是不是有如想像中的執行，因此學會利用debug.print及查看區域變數視窗是最基本的要求，爾後再導入單元測試的概念即可。\r\nExcel\r\nVBA的眉眉角角-除錯技巧\r\n介面操作\r\n對於使用者而言，透過按按鈕來執行程式碼非常直觀，經過多年的使用習慣大部分的操作介面都是如此，若是在比較古老的程式也許會使用菜單進行。\r\n按鈕可以出現在工作表也可以在表單(Userform)，工作表本身也可以算是一個介面，很多人也會使用這樣的設計方法，在工作表上面按按鈕去執行相對應流程，然而表單的使用比較可以讓使用者照著自己的流程進行，不會跳來跳去\r\n\r\n表單屬於比較進階的部分，先讓程式可以按按鈕執行就好\r\n\r\nVBA按鈕執行-GT\r\nWang\r\n發布方式\r\n程式寫完之後，在本機可以直接開始使用通常沒有問題，怕就是會遇到巨集封鎖這類的安全性保護機制，對於一般使用者來說，看到這個就會心生疑慮，如果開發者是你可信任的就可以解除封鎖或者加入白名單就好。\r\n解除封鎖巨集\r\n加入白名單\r\n⚙️拆解單元\r\n解決問題的方法若能夠進行良好的拆解對於程式碼的撰寫過程會有極大的幫助，也有助於釐清思緒並在次單元的完成過程中獲得滿滿的成就感，每個案子都會有自己的心智圖，每一個分支都有自己要完成的事，光一個產生報表的行為，就能拆解成\r\n\r\n去哪裡找資料\r\n收到資料要如何篩選\r\n篩選資料要如何排序\r\n排序完要放入報表\r\n報表產出是什麼格式\r\n\r\n\r\n程式碼就是一連串的小流程，不斷的堆疊而成的專案\r\n\r\n不要太貪心一次想要完成全部的功能，透過sub或者function把每個階段要做的事情做良好的拆解並完成，比較不會中途放棄，之後在偵錯過程比較好了解哪邊有錯誤。\r\n\r\n🔎尋找答案\r\n\r\n尋找答案時，必須要了解如何清楚描述問題，沒有人有辦法回答不明確的內容。\r\n\r\n買書的必要?\r\n當初我為了學習這項語言買了不下10本工具書，發現其實都大同小異，初學者可以去圖書館找一本順眼的來看基本語法，有範例的那種最好。這一步是為了要讓你確定你喜不喜歡VBA，不建議一開始就花錢。\r\n若是覺得自己真的看得懂的時候，我建議買一本比較新的來當作工具書(畢竟書比較便宜?)，工具書的意義就是需要的時候再來查，查個幾次基本上熟悉了，此時也會有一些實作程式碼範例留存在電腦中，等之後遇到同樣的問題就會知道哪邊有寫過，直接複製貼上(?)。\r\nAI時代來臨\r\nAI時代的進步讓上述的流程又能更加精簡，當然上網google找答案還是需要的，有時問AI問題若不夠精確時會產生幻覺，複製貼上的程式碼動不起來就是動不起來，畢竟...程式碼會卡住那就是無效內容，為了讓他100%可以運作有時候還是需要人工介入。\r\n問問題的方法\r\n當你為了這項問題努力試著去找答案時發現真的無法解決，只要願意把你的範例、操作步驟、爬文內容給描述清楚，相信還是有願意幫助你的人(畢竟在社會上沒有人有義務回答你的問題，一切都是良心驅使)。\r\n範例\r\n可以是檔案、截圖、螢幕錄影\r\n操作步驟\r\n描述完整的操作過程，每一次過程預期會發生什麼事，但現在發生什麼問題\r\n爬文內容\r\n把目前遇到的問題問AI或Google搜尋，嘗試過哪些方法?\r\n好站連結\r\n🔗PAPAYA電腦教室-EXCEL基本教學\r\n🔗IT邦幫忙-ExcelVBA的眉眉角角\r\n🔗VBA程式設計-GT.Wang\r\n","categories":["專案開發"],"tags":["Excel VBA"]},{"title":"不同版本間的CAD開發","url":"/posts/2144300187/","content":"🙌前言\r\nCAD版本有非常多種，我目前有接觸過的就有AutoCAD、ZWCAD以及現在正在使用中的ProgeCAD。\r\n在使用VBA進行二次開發的過程，需要考量引用物件模型之間的差異，就目前開發經驗中，AutoCAD與ZWCAD可以透過修改引用名稱就可以有很好的轉換體驗，但是ProgeCAD的基底物件有比較不同的設計，故本篇要來解釋從AutoCAD的VBAcode如何透過我所撰寫的物件轉換函數進行相容，讓程式碼在ProgeCAD也可以順利動起來。\r\n🔗HanksVBA學習歷程-不同CAD版本間也可以引用的Library(clsACAD)\r\n\r\n🎯版本沿革\r\nAutoCAD\r\nAutoCAD為Autodesk公司旗下產品，產品比較沒有異常，程式碼範例豐富，社群支援完整度較高，同時也是最昂貴的軟體。\r\nZWCAD\r\nZWCAD為中望公司旗下產品，其實與AutoCAD都大同小異，費用比AutoCAD來的便宜，可惜政府機關不能接受中資，怕有資安疑慮。\r\nProgeCAD\r\nProgeCAD總部設立於義大利，採用IntelliCAD引擎驅動，就使用上不知怎麼說，就是覺得與AutoCAD少了一味，程式碼的運作比較緩慢，有些介面會跟AutoCAD有些許落差。\r\n📌開發差異\r\n之前的專案大多都是用於AutoCAD運作，自從機關買斷ProgeCAD之後，為了把程式碼移轉到ProgeCAD進行，需要了解一下程式碼開發之間的差異。\r\n公共變數\r\n公共變數的目的是為了能夠在各個function中相互傳遞變數使用\r\nPrivate mo As ObjectPrivate pa As ObjectPublic acadDoc As ObjectPublic CADVer As String\r\n連接應用程式\r\n這裡我在Sheets(\"總表\")上面做了一個選單，讓使用者可以挑選要啟用哪個後期繫結字串，strCAD為VBA呼叫CAD應用程式連接字串，CADVer為各function連接後的細微調整判斷。\r\nPrivate Sub Class_Initialize()If Sheets(&quot;總表&quot;).optAutoCAD = True Then    strCAD = &quot;AutoCAD.application&quot;    CADVer = &quot;AUTOCAD&quot;    ElseIf Sheets(&quot;總表&quot;).optZWCAD = True Then        strCAD = &quot;ZWCAD.Application&quot;    CADVer = &quot;ZWCAD&quot;    ElseIf Sheets(&quot;總表&quot;).optICAD = True Then    strCAD = &quot;ICAD.application&quot;    CADVer = &quot;ICAD&quot;End IfCall CADInit(strCAD)End SubPrivate Sub CADInit(ByVal strCAD As String)On Error Resume NextSet acadApp = GetObject(, strCAD) &#x27;查看安裝If Err &lt;&gt; 0 Then Set acadApp = CreateObject(strCAD)acadApp.Visible = TrueOn Error GoTo 0Set mo = acadApp.ActiveDocument.ModelSpaceSet pa = acadApp.ActiveDocument.PaperSpaceSet acadDoc = acadApp.ActiveDocumentEnd Sub\r\n🌟物件相容轉換函數\r\n\r\nAutoCAD的點物件是以一個陣列(array)儲存(0,1,2)double變數而成。\r\nAutoCAD的線物件則分為LightWeightPolyline跟3dPolyline\r\n\r\nLightWeigtPolyline是以一個陣列(vertice)至少儲存(0,1,2,3)生成，過程中不儲存高程，所以每2個值為一個點。\r\n3DPolyline是以一個陣列(vertice)至少儲存(0,1,2,3,4,5)生成，過程中儲存高程，所以每3個值為一個點。\r\n\r\nProgeCAD的點物件是以一個點物件(Point)，由X,Y,Z三個屬性儲存其變數而成。\r\nProgeCAD的線物件是以點群物件(Points)儲存點物件(Point)，取其變數而成。\r\n\r\nFunction tranPoint(ByVal CADpt)If CADVer &lt;&gt; &quot;ICAD&quot; Then tranPoint = CADpt: Exit FunctionSet tranPoint = Library.CreatePoint(CADpt(0), CADpt(1), CADpt(2))End FunctionFunction tranIPoint(ByVal ICADpt)If CADVer &lt;&gt; &quot;ICAD&quot; Then tranIPoint = ICADpt: Exit FunctionDim tmp(2) As Doubletmp(0) = ICADpt.Xtmp(1) = ICADpt.Ytmp(2) = ICADpt.ZtranIPoint = tmpEnd FunctionFunction tranPoints(ByVal vertices, Optional cnt As Byte = 3)If CADVer &lt;&gt; &quot;ICAD&quot; Then tranPoints = vertices: Exit FunctionIf vertices(2) = 0 Then cnt = 3Dim myPline, myPoints, pt    Set myPoints = Library.CreatePointsIf cnt = 2 Then    For i = 0 To UBound(vertices) Step cnt            Set pt = Library.CreatePoint(vertices(i), vertices(i + 1))            myPoints.Add        myPoints(myPoints.Count - 1).X = pt.X        myPoints(myPoints.Count - 1).Y = pt.Y        NextElse    For i = 0 To UBound(vertices) Step cnt            Set pt = Library.CreatePoint(vertices(i), vertices(i + 1), vertices(i + 2))            myPoints.Add        myPoints(myPoints.Count - 1).X = pt.X        myPoints(myPoints.Count - 1).Y = pt.Y        myPoints(myPoints.Count - 1).Z = pt.Z        NextEnd IfSet tranPoints = myPointsEnd FunctionFunction tranIPoints(ByVal myPoints)If CADVer &lt;&gt; &quot;ICAD&quot; Then tranIPoints = myPoints: Exit FunctionDim vertices()ReDim vertices(myPoints.Count * 3 - 1)For Each it In myPointsvertices(0 + j) = it.Xvertices(0 + j + 1) = it.Yvertices(0 + j + 2) = it.Zj = j + 3NexttranIPoints = verticesEnd Function\r\n基本物件\r\n畫點、畫圓、畫線、寫文字\r\nFunction AddPoint(pt) As ObjectIf CADVer = &quot;ICAD&quot; Then    Set AddPoint = mo.AddPointEntity(tranPoint(pt))Else    Set AddPoint = mo.AddPoint(tranPoint(pt))End IfEnd FunctionFunction AddCircle(cpt, r) As ObjectSet AddCircle = mo.AddCircle(tranPoint(cpt), r)End FunctionFunction AddLine(spt, ept) As ObjectSet AddLine = mo.AddLine(tranPoint(spt), tranPoint(ept))End FunctionFunction AddLineCO(X1, Y1, X2, Y2) As ObjectDim spt(2) As DoubleDim ept(2) As Doublespt(0) = X1: spt(1) = Y1ept(0) = X2: ept(1) = Y2Set AddLineCO = AddLine(spt, ept)End FunctionFunction AddPolyLine(vertices) As ObjectSet AddPolyLine = mo.AddPolyLine(tranPoints(vertices))End FunctionFunction Add3dPoly(vertices) &#x27;20210604 newSet Add3dPoly = mo.Add3dPoly(tranPoints(vertices))End FunctionFunction AddLWPolyLine(vertices) As ObjectSet AddLWPolyLine = mo.AddLightWeightPolyline(tranPoints(vertices, 2))End FunctionFunction AddArc(ByVal Center, Radius As Double, StartAngle As Double, EndAngle As Double)Set AddArc = mo.AddArc(tranPoint(Center), Radius, StartAngle, EndAngle)End FunctionFunction AddText(ByVal myText As String, ByVal txtpt, ByVal txtheight As Double, Optional alignmode As Byte = 1)    Dim mtextObj As Object &#x27;IntelliCAD.Text    Dim insPt        insPt = txtpt    Set txtobj = mo.AddText(myText, tranPoint(insPt), txtheight)    If CADVer = &quot;ICAD&quot; Then            Select Case alignmode                Case 1            txtobj.HorizontalAlignment = 0  &#x27; acAlignmentMiddleLeft        Case 2            txtobj.HorizontalAlignment = 4  &#x27; acAlignmentMiddleCenter        Case 3            txtobj.HorizontalAlignment = 2 &#x27; acAlignmentMiddleRight                End Select        Else            Select Case alignmode            Case 1            txtobj.Alignment = 9 &#x27; acAlignmentMiddleLeft        Case 2            txtobj.Alignment = 10 &#x27; acAlignmentMiddleCenter        Case 3            txtobj.Alignment = 11 &#x27; acAlignmentMiddleRight                    End Select        End If        txtobj.TextAlignmentPoint = tranPoint(insPt)    Set AddText = txtobjEnd Function\r\n通用類別(Util)\r\n通用類別用於與應用程式間的互動居多，包含取得點、取得文字。也包含CAD物件本身所提供的無法分類屬性，也會放入通用類別。\r\nFunction GetPoint(ByVal prompt As String)If CADVer = &quot;ICAD&quot; Then    Set o = IntelliCAD.ActiveDocument.Utility.GetPoint(, prompt)    GetPoint = tranIPoint(o)Else    GetPoint = acadDoc.Utility.GetPoint(, prompt)End IfEnd FunctionFunction GetString(ByVal prompt As String)GetString = acadDoc.Utility.GetString(False, prompt &amp; vbNewLine)End FunctionFunction GetBoundingBox(ByVal entobj, MinX, MinY, MaxX, MaxY)If CADVer = &quot;ICAD&quot; Then Call GetBoundingBox_ICAD(entobj, MinX, MinY, MaxX, MaxY): Exit FunctionCall entobj.GetBoundingBox(Min, Max)MinX = Min(0): MinY = Min(1)MaxX = Max(0): MaxY = Max(1)End FunctionFunction GetBoundingBox_ICAD(ByVal entobj, MinX, MinY, MaxX, MaxY)Dim Min As ObjectDim Max As ObjectCall entobj.GetBoundingBox(Min, Max)MinX = Min.X: MinY = Min.YMaxX = Max.X: MaxY = Max.YEnd Function\r\n🐞開發過程中的小問題\r\n填充線也是常用於標示圖形的功能之一，這裡的AddHatch我一直試不出來，當初猜測可能是常數的問題vicHatchPatternTypePreDefined，結果還是一樣...\r\n不同應用程式之間有時候常數設定會有所不同，包含排序的方式也可能會不同，像是在做selectionset(選擇集)的時候，AutoCAD可以很清楚知道順序，但是ProgeCAD似乎沒有一定的規則可言。\r\nSub Hatch(ByVal obj As Object, ByVal Ratio As Double, ByVal ptrName As String)&#x27;usually use &quot;SOLID&quot;,&quot;ANSI32&quot;,&quot;AR-CONC&quot;If CADVer = &quot;ICAD&quot; Then Exit SubDim hatchobj As Object &#x27;AcadHatchDim outerloop(0 To 0) As Object &#x27;AcadEntityPatternName = ptrNameSet hatchobj = mo.AddHatch(0, PatternName, True)&#x27;Set hatchobj = mo.AddHatch(vicHatchPatternTypePreDefined, PatternName, True)hatchobj.PatternScale = 1 / Ratio * 4Set outerloop(0) = objOn Error Resume Nexthatchobj.AppendOuterLoop (outerloop)End SubFunction AddMixText(ByVal s As String, ByVal txtpt, ByVal txtheight As Double, _                    Optional alignmode As Byte = 1, Optional dashmode As Integer = 0)Dim txtobj As Object &#x27;AcadTextDim circleobj As Object &#x27;AcadCircleSet AddMixText = AddText(s, txtpt, txtheight, alignmode)With mo    Dim vertices(5) As Double    If dashmode = 0 Then Exit Function        Call GetBoundingBox(AddMixText, MinX, MinY, MaxX, MaxY)        For i = 1 To dashmode            vertices(0) = MinX        vertices(1) = MinY - txtheight / 2 - txtheight / 2 * 0.5 * i                vertices(3) = MaxX        vertices(4) = vertices(1)                Set plineobj = AddPolyLine(vertices)                &#x27;******整體寬度尚未解決******                If CADVer &lt;&gt; &quot;ICAD&quot; Then plineobj.ConstantWidth = txtheight / 10        NextEnd WithEnd FunctionFunction CreateSSET(Optional ByVal sname As String = &quot;SS1&quot;, Optional ByVal ftypetmp As Variant = &quot;&quot;, Optional ByVal fdatatmp As Variant = &quot;&quot;)&#x27;****PorgeCAD中似乎沒辦法做到過濾的條件?*****&#x27;0:object type&#x27;2:object name&#x27;8:layer name&#x27;62:color number(0 to 256)Dim FilterType() As IntegerDim FilterData() As VariantOn Error Resume Next: acadDoc.SelectionSets(sname).Delete: On Error GoTo 0Set sset = acadDoc.SelectionSets.Add(sname)If ftypetmp = &quot;&quot; Then    sset.SelectOnScreen    Else    ft = Split(ftypetmp, &quot;,&quot;)    fd = Split(fdatatmp, &quot;,&quot;)        ReDim FilterType(0 To UBound(ft))    ReDim FilterData(0 To UBound(fd))        For i = 0 To UBound(ft)            FilterType(i) = ft(i)        FilterData(i) = fd(i)            Next        sset.SelectOnScreen FilterType, FilterData    End IfSet CreateSSET = ssetEnd FunctionSub SetXdataToObj(ByVal obj As Object, ByVal xdata As String) &#x27;提供綁入字串使用If CADVer = &quot;ICAD&quot; Then Exit Sub  &#x27;中心線樁無法提供&#x27;*****用Handle處理?!***Dim DataType(0 To 1) As IntegerDim Data(0 To 1) As VariantDataType(0) = 1001: Data(0) = xdataDataType(1) = 1000: Data(1) = &quot;&quot;obj.SetXData DataType, DataEnd Sub\r\n👉建議開發方向\r\n通用才是王道，不管使用哪種應用程式，只要可以彼此匯入、匯出，最後都只是差在介面使用的習慣以及各應用程式獨立提供的功能而已。\r\n如同前言所述，CAD版本有非常多種類型，在預算上若有所考量，其實也有FreeCAD、LibreCAD...等等開源選項。但若今天把大多數的開發時間都投在某一個CAD版本身上，未來如果公司要更換版本時，轉換成本會隨著你的開發時間而呈指數上升，程式碼越複雜問題越難查出來。\r\n當今天開發人員已經決定要投資在CAD的二次開發上，我有幾點建議\r\n\r\n確認文件是否豐富\r\n社群平台是否有良好的支援\r\n基底應用程式是否有細微bug\r\n產出內容盡量以dxf為主\r\n\r\n掌握好上面幾點，就差不多可以開始挑選CAD的題目，慢慢嘗試，遇到問題就看文件、不行就問別人，只要沒有本身的bug，基本上CAD的開發應該可以完成80%的工作流程，搭配dxf的產出內容，未來轉換也是沒有問題的。\r\n💡Python輸出DXF(題外話)\r\npython的ezdxf套件是我最近在使用streamlit開發時在使用，文件也算是相當詳細，這是一個單純用python所製作的CSV轉DXF專案，對於點資料轉成點物件應該有幫助，下載DXF之後只要匯入自己的CAD版本就可以進行後續使用了!\r\n🔗CSV轉DXF-Streamlit\r\n","categories":["基本概念"],"tags":["AutoCAD VBA","ProgeCAD VBA","Streamlit"]},{"title":"python製作工程設計簡圖","url":"/posts/3601177192/","content":"前言\r\n圖表跟圖片都是用來讓網頁元素更為豐富的手段，圖表為數據統計後的成果、圖片則為將抽象的文字轉換成圖片形式進行輸出(比如渠道的長相)，抽象的文字往往不比圖片的介紹來的容易接受許多，而這也是資料可視化的目標之一。\r\n使用情境\r\n在提報工程概要表時，會需要讓上面了解未來要施作的工程內容，因此會拍攝現場的照片及附上工程設計簡圖，而工程設計簡圖的製作過程非常繁瑣，操作過程如下:\r\n\r\n開啟CAD\r\n畫出渠道形狀、標示文字內容\r\n預覽列印\r\n截圖預覽列印內容另存成圖片檔\r\n圖片檔貼附到Excel上面\r\n\r\n因此本次專案預期會讓使用者輸入渠道的尺寸、周邊環境關係來製作一張簡圖，放置於\"工程概要表\"讓長官了解未來要施作的工程內容，利用python的PIL套件縮短繪製工程設計簡圖的流程。\r\n\r\n基本概念\r\nPIL全名為Pillow，是目前在開發python時常用的一項繪圖工具\r\n\r\n座標關係\r\n\r\nPIL以第二象限開始，X往右遞增，Y往下遞增。\r\nCAD以第一象限開始，X往右遞增，Y往上遞增。\r\n\r\n元素用法\r\n\r\n畫線\r\ndef draw_line(draw, start_point, end_point, fill=&#x27;black&#x27;, width=3):    draw.line([start_point, end_point], fill=fill, width=width)\r\n畫多段線\r\ndef draw_polyline(draw, points, fill=&#x27;black&#x27;, width=3):    draw.line(points, fill=fill, width=width)\r\n寫文字\r\ndef draw_text(draw, text, position, font_size, font_path, fill=&#x27;black&#x27;):    font = ImageFont.truetype(font_path, font_size)    draw.text(position, text, font=font, fill=fill)\r\n\r\n這裡的font_path如果是中文，可能會有出現亂碼的問題，可以先去Google\r\nfont之類先下載下來到開發目錄讓他引用。目前中文的部分我用NotoSansTC-Regular.ttf\r\n\r\n填充線\r\ndef draw_polygon(draw, points, outline=&#x27;black&#x27;, fill=None, width=3):    draw.polygon(points, outline=outline, fill=fill)    if fill:        draw.line(points + [points[0]], fill=outline, width=width)        def draw_gradient_polygon(draw, vertices, start_color, end_color):    &quot;&quot;&quot;    繪製漸層顏色的多邊形    :param draw: PIL.ImageDraw對象    :param vertices: 多邊形頂點座標列表 [(x1, y1), (x2, y2), ...]    :param start_color: 開始顏色 (r, g, b)    :param end_color: 結束顏色 (r, g, b)    &quot;&quot;&quot;    x_coords, y_coords = zip(*vertices)    min_y, max_y = min(y_coords), max(y_coords)    height = max_y - min_y    gradient_colors = create_gradient_color(start_color, end_color, height)    for i, color in enumerate(gradient_colors):        draw.line([(min(x_coords), min_y + i), (max(x_coords), min_y + i)], fill=color)        \r\n標註尺寸\r\ndef draw_dimension_line(draw, X1_DIM,Y1_DIM,X2_DIM,Y2_DIM, font_size, font_path,dim_space=20,arrow_length=10):    text_color=&#x27;#e85fd6&#x27;    # font_size=30    if Y1_DIM==Y2_DIM:        dim_txt=str(int(X2_DIM-X1_DIM))        draw_text(draw, dim_txt,((X1_DIM+X2_DIM)/2-font_size/2,(Y1_DIM+Y2_DIM)/2-font_size*2.5-dim_space), font_size, font_path, fill=text_color)        draw_line(draw, (X1_DIM, Y1_DIM-dim_space), (X1_DIM, Y1_DIM-arrow_length-dim_space), fill=text_color, width=1)        draw_line(draw, (X2_DIM, Y2_DIM-dim_space), (X2_DIM, Y2_DIM-arrow_length-dim_space), fill=text_color, width=1)        draw_line(draw, (X1_DIM, Y1_DIM-arrow_length/2-dim_space), (X2_DIM, Y2_DIM-arrow_length/2-dim_space), fill=text_color, width=1)        elif X1_DIM==X2_DIM:        dim_txt=str(int(Y2_DIM-Y1_DIM))        draw_text(draw, dim_txt,((X1_DIM+X2_DIM)/2-dim_space-2.5*font_size,(Y1_DIM+Y2_DIM)/2-font_size), font_size, font_path, fill=text_color)        draw_line(draw, (X1_DIM-dim_space, Y1_DIM), (X1_DIM-arrow_length-dim_space, Y1_DIM), fill=text_color, width=1)        draw_line(draw, (X2_DIM-dim_space, Y2_DIM), (X2_DIM-arrow_length-dim_space, Y2_DIM), fill=text_color, width=1)        draw_line(draw, (X1_DIM-arrow_length/2-dim_space, Y1_DIM), (X2_DIM-arrow_length/2-dim_space, Y2_DIM), fill=text_color, width=1)\r\n預期成果\r\n\r\n\r\nFig1.工程設計簡圖\r\n\r\n完整做法\r\nfrom PIL import Image, ImageDraw, ImageFontdef draw_text(draw, text, position, font_size, font_path, fill=&#x27;black&#x27;):    font = ImageFont.truetype(font_path, font_size)    draw.text(position, text, font=font, fill=fill)def draw_line(draw, start_point, end_point, fill=&#x27;black&#x27;, width=3):    draw.line([start_point, end_point], fill=fill, width=width)def draw_polygon(draw, points, outline=&#x27;black&#x27;, fill=None, width=3):    draw.polygon(points, outline=outline, fill=fill)    if fill:        draw.line(points + [points[0]], fill=outline, width=width)def draw_polyline(draw, points, fill=&#x27;black&#x27;, width=3):    draw.line(points, fill=fill, width=width)def create_gradient_color(start_color, end_color, height):    &quot;&quot;&quot;    創建垂直漸層顏色列表    :param start_color: 開始顏色 (r, g, b)    :param end_color: 結束顏色 (r, g, b)    :param height: 高度（漸層的總行數）    :return: 漸層顏色列表    &quot;&quot;&quot;    gradient = []    for i in range(height):        ratio = i / height        r = int(start_color[0] * (1 - ratio) + end_color[0] * ratio)        g = int(start_color[1] * (1 - ratio) + end_color[1] * ratio)        b = int(start_color[2] * (1 - ratio) + end_color[2] * ratio)        gradient.append((r, g, b))    return gradientdef draw_gradient_polygon(draw, vertices, start_color, end_color):    &quot;&quot;&quot;    繪製漸層顏色的多邊形    :param draw: PIL.ImageDraw對象    :param vertices: 多邊形頂點座標列表 [(x1, y1), (x2, y2), ...]    :param start_color: 開始顏色 (r, g, b)    :param end_color: 結束顏色 (r, g, b)    &quot;&quot;&quot;    x_coords, y_coords = zip(*vertices)    min_y, max_y = min(y_coords), max(y_coords)    height = max_y - min_y    gradient_colors = create_gradient_color(start_color, end_color, height)    for i, color in enumerate(gradient_colors):        draw.line([(min(x_coords), min_y + i), (max(x_coords), min_y + i)], fill=color)def draw_dimension_line(draw, X1_DIM,Y1_DIM,X2_DIM,Y2_DIM, font_size, font_path,dim_space=20,arrow_length=10):    text_color=&#x27;#e85fd6&#x27;    # font_size=30    if Y1_DIM==Y2_DIM:        dim_txt=str(int(X2_DIM-X1_DIM))        draw_text(draw, dim_txt,((X1_DIM+X2_DIM)/2-font_size/2,(Y1_DIM+Y2_DIM)/2-font_size*2.5-dim_space), font_size, font_path, fill=text_color)        draw_line(draw, (X1_DIM, Y1_DIM-dim_space), (X1_DIM, Y1_DIM-arrow_length-dim_space), fill=text_color, width=1)        draw_line(draw, (X2_DIM, Y2_DIM-dim_space), (X2_DIM, Y2_DIM-arrow_length-dim_space), fill=text_color, width=1)        draw_line(draw, (X1_DIM, Y1_DIM-arrow_length/2-dim_space), (X2_DIM, Y2_DIM-arrow_length/2-dim_space), fill=text_color, width=1)        elif X1_DIM==X2_DIM:        dim_txt=str(int(Y2_DIM-Y1_DIM))        draw_text(draw, dim_txt,((X1_DIM+X2_DIM)/2-dim_space-2.5*font_size,(Y1_DIM+Y2_DIM)/2-font_size), font_size, font_path, fill=text_color)        draw_line(draw, (X1_DIM-dim_space, Y1_DIM), (X1_DIM-arrow_length-dim_space, Y1_DIM), fill=text_color, width=1)        draw_line(draw, (X2_DIM-dim_space, Y2_DIM), (X2_DIM-arrow_length-dim_space, Y2_DIM), fill=text_color, width=1)        draw_line(draw, (X1_DIM-arrow_length/2-dim_space, Y1_DIM), (X2_DIM-arrow_length/2-dim_space, Y2_DIM), fill=text_color, width=1)# 相關參數def plot_Uchannel(B,H,T,env_left_txt,env_right_txt,env_left,env_right):    # B=200    # H=120    # T=25    X_left,X_right,Y_top,Y_bottom=150,150,150,100    X0=X_left+T+B/2    Y0=Y_top+H    # env_left_txt=&quot;路&quot;    # env_left=20    # env_right_txt=&quot;田&quot;    # env_right=60    env_left_body=H-env_left+T    env_right_body=H-env_right+T    # 設置圖像尺寸和解析度    width, height = X_left+X_right+2*T+B, Y_top+Y_bottom+H+T    dpi = 100  # 高 DPI 設置    # 創建圖像    image = Image.new(&#x27;RGB&#x27;, (width, height), &#x27;white&#x27;)    draw = ImageDraw.Draw(image)    # 字體設置    font_path = &quot;NotoSansTC-Regular.ttf&quot;  # 字體文件的路徑    font_size = 20    # 繪製文字    draw_text(draw, env_left_txt, (X0-B/2-T-X_left/2-20, Y0-H+env_left-font_size*2), font_size*1.2, font_path)    draw_text(draw, env_right_txt, (X0+B/2+T+X_right/2, Y0-H+env_right-font_size*2), font_size*1.2, font_path)    # 土體    polygon_points = [ (X0-B/2-T, Y0-H+env_left), (X0-B/2-T-X_left, Y0-H+env_left),  (X0-B/2-T-X_left, Y0-H+env_left+env_left_body), (X0-B/2-T, Y0-H+env_left+env_left_body)]    draw_gradient_polygon(draw, polygon_points, (51, 26, 0),(255, 255, 255))    # 土體    polygon_points = [ (X0+B/2+T, Y0-H+env_right), (X0+B/2+T+X_right, Y0-H+env_right), (X0+B/2+T+X_right, Y0-H+env_right+env_right_body), (X0+B/2+T, Y0-H+env_right+env_right_body)]    draw_gradient_polygon(draw, polygon_points, (51, 26, 0),(255, 255, 255))    # 面層    if env_left_txt==&quot;田&quot;:        draw_line(draw, (X0-B/2-T, Y0-H+env_left), (X0-B/2-T-X_left, Y0-H+env_left), fill=&#x27;green&#x27;, width=4)    else:        draw_line(draw, (X0-B/2-T, Y0-H+env_left), (X0-B/2-T-X_left, Y0-H+env_left), fill=(0, 26, 51), width=4)    if env_right_txt==&quot;路&quot;:        draw_line(draw, (X0+B/2+T, Y0-H+env_right), (X0+B/2+T+X_right, Y0-H+env_right), fill=(0, 26, 51), width=4)    else:        draw_line(draw, (X0+B/2+T, Y0-H+env_right), (X0+B/2+T+X_right, Y0-H+env_right), fill=&#x27;green&#x27;, width=4)    # 結構體    pts =[(X0,Y0),(X0-B/2,Y0),(X0-B/2,Y0-H),(X0-B/2-T,(Y0-H)),(X0-B/2-T,(Y0+T)),(X0+B/2+T,(Y0+T)),(X0+B/2+T,(Y0-H)),(X0+B/2,(Y0-H)),(X0+B/2,Y0),(X0,Y0)]    draw_polygon(draw, pts, outline=&#x27;black&#x27;, fill=&#x27;gray&#x27;, width=1)    ## 尺寸標註    ### 水平方向    X1_DIM,Y1_DIM=X0-B/2-T,Y0-H    X2_DIM,Y2_DIM=X0-B/2,Y0-H    draw_dimension_line(draw, X1_DIM,Y1_DIM,X2_DIM,Y2_DIM, font_size, font_path)    X1_DIM,Y1_DIM=X0-B/2,Y0-H    X2_DIM,Y2_DIM=X0+B/2,Y0-H    draw_dimension_line(draw, X1_DIM,Y1_DIM,X2_DIM,Y2_DIM, font_size, font_path)    X1_DIM,Y1_DIM=X0+B/2,Y0-H    X2_DIM,Y2_DIM=X0+B/2+T,Y0-H    draw_dimension_line(draw, X1_DIM,Y1_DIM,X2_DIM,Y2_DIM, font_size, font_path)    ### 垂直方向    X1_DIM,Y1_DIM=X0-B/2-T,Y0-H    X2_DIM,Y2_DIM=X0-B/2-T,Y0    draw_dimension_line(draw, X1_DIM,Y1_DIM,X2_DIM,Y2_DIM, font_size, font_path)    X1_DIM,Y1_DIM=X0-B/2-T,Y0    X2_DIM,Y2_DIM=X0-B/2-T,Y0+T    draw_dimension_line(draw, X1_DIM,Y1_DIM,X2_DIM,Y2_DIM, font_size, font_path)    # 保存高解析度圖像    image.save(&quot;high_quality_drawing.png&quot;, dpi=(dpi, dpi))    image.show()if __name__ == &quot;__main__&quot;:    # 給定尺寸    plot_Uchannel(300,200,30,&quot;田&quot;,&quot;田&quot;,20,50)\r\n","categories":["專案開發"],"tags":["Python"]},{"title":"內部網路帳號密碼權限控制實作","url":"/posts/3389672383/","content":"前言\r\n當網站寫好後，依照公司內部組織分層負責，權限分為編輯、讀取、拒絕，每個分頁通常都會有指派的人員進行編輯，相關人員進行讀取，不相干人等禁止進入(同時也是為了避免資訊外流)，故在進入網站之前，會要求用戶提供帳號密碼，這時候公司內部如果有AD(Active\r\nDirectory)管理帳號密碼會非常方便。\r\n\r\n舉例:工程審查系統，可編輯者為設計股，可讀取者為工事股。\r\n\r\n操作流程\r\n\r\n網站入口要求提供帳號密碼\r\n根據該帳號密碼到AD確認名稱、組織資訊\r\n根據組織資訊開啟相對應的頁面\r\n\r\n\r\n程式碼解釋\r\n環境參數\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n變數名稱\r\n說明\r\n中文解釋\r\n\r\n\r\n\r\n\r\nAD_SERVER_NAME\r\nActive Directory server name\r\nAD 伺服器名稱\r\n\r\n\r\nAD_DOMAIN\r\nActive Directory domain\r\nAD 網域名稱\r\n\r\n\r\nAD_ADMIN_USER\r\nAD administrator username\r\nAD 管理員帳號\r\n\r\n\r\nAD_ADMIN_PASSWORD\r\nAD administrator password\r\nAD 管理員密碼\r\n\r\n\r\nBASE_DN\r\nBase Distinguished Name\r\n查詢的起點\r\n\r\n\r\n\r\n登入驗證\r\ndef check_ad_credentials(username, password):    # 設定值（從你的 C# 註解轉換過來）    user_upn = f&quot;&#123;username&#125;@&#123;AD_DOMAIN&#125;&quot;    try:        print(f&quot;🔐 嘗試用 &#123;user_upn&#125; 登入 AD 伺服器 &#123;AD_SERVER_NAME&#125; ...&quot;)        server = Server(AD_SERVER_NAME, get_info=ALL)        conn = Connection(server, user=user_upn, password=password, authentication=&#x27;SIMPLE&#x27;, auto_bind=True)        print(&quot;✅ 登入成功！&quot;)        conn.unbind()        return True    except LDAPException as e:        print(f&quot;❌ LDAP 驗證錯誤: &#123;e&#125;&quot;)        return False    except Exception as ex:        print(f&quot;❌ 其他錯誤: &#123;ex&#125;&quot;)        return False\r\n取得用戶資訊\r\ndef get_user_info_one(s_type, s_data):    try:        print(f&quot;🔍 查詢條件: (&#123;s_type&#125; = &#123;s_data&#125;)&quot;)        # 建立連線        server = Server(AD_SERVER_NAME, get_info=ALL)        conn = Connection(server, user=AD_ADMIN_USER, password=AD_ADMIN_PASSWORD,authentication=&#x27;SIMPLE&#x27;, auto_bind=True)        # 建立搜尋 Filter        search_filter = f&quot;(&amp;(objectCategory=user)(&#123;s_type&#125;=&#123;s_data&#125;))&quot;        # 執行搜尋        conn.search(            search_base=BASE_DN,            search_filter=search_filter,            search_scope=SUBTREE,            attributes=[                &#x27;displayName&#x27;,                &#x27;description&#x27;,                &#x27;userPrincipalName&#x27;,                &#x27;sAMAccountName&#x27;,                &#x27;distinguishedName&#x27;            ]        )        if not conn.entries:            print(&quot;❌ 查無此人&quot;)            return None        entry = conn.entries[0]        # 回傳模擬 C# DataTable 的字典        result = &#123;            &#x27;USR_NAME&#x27;: entry.displayName.value or &#x27;&#x27;,            &#x27;TITLE&#x27;: entry.description.value or &#x27;&#x27;,            &#x27;EMAIL&#x27;: entry.userPrincipalName.value or &#x27;&#x27;,            &#x27;DP_STR&#x27;: entry.distinguishedName.value or &#x27;&#x27;        &#125;        conn.unbind()        return result    except LDAPException as e:        print(f&quot;❌ LDAP 錯誤: &#123;e&#125;&quot;)        return None    except Exception as ex:        print(f&quot;❌ 其他錯誤: &#123;ex&#125;&quot;)        return None\r\n取得各個層次的資訊\r\ndef parse_dn(dn):    # 分割 DN，取得各個層次的資訊    parts = dn.split(&#x27;,&#x27;)        user_name = None    ou_list = []    dc_list = []        for part in parts:        if part.startswith(&#x27;CN=&#x27;):            user_name = part.replace(&#x27;CN=&#x27;, &#x27;&#x27;)        elif part.startswith(&#x27;OU=&#x27;):            ou_list.append(part.replace(&#x27;OU=&#x27;, &#x27;&#x27;))        elif part.startswith(&#x27;DC=&#x27;):            dc_list.append(part.replace(&#x27;DC=&#x27;, &#x27;&#x27;))        # 返回解析結果    return &#123;        &#x27;user_name&#x27;: user_name,        &#x27;organization_units&#x27;: ou_list,        &#x27;domain_components&#x27;: dc_list    &#125;\r\n白名單及權限給予\r\ndef white_list(ou_list):    accept_ou = [&quot;010&quot;, &quot;020&quot;, &quot;030&quot;, &quot;051&quot;, &quot;052&quot;, &quot;053&quot;, &quot;054&quot;, &quot;1C0&quot;, &quot;1CH&quot;, &quot;2D0&quot;, &quot;2DD&quot;, &quot;3E0&quot;, &quot;3EC&quot;, &quot;4F0&quot;, &quot;4FD&quot;, &quot;5G0&quot;, &quot;5G4&quot;,&quot;081&quot;]    edit_ou =[&quot;051&quot;]    # 統一轉成 list 處理    if isinstance(ou_list, str):        ou_list = [ou_list]    # 先檢查是否為編輯者    for ou in ou_list:        if ou.strip() in edit_ou:            return &quot;EDITOR&quot;    # 再檢查是否為接受者    for ou in ou_list:        if ou.strip() in accept_ou:            return &quot;VIEWER&quot;    # 其他都不是    return &quot;NONE&quot;\r\n入口邏輯\r\nst.subheader(&quot;請輸入EIP帳號密碼&quot;)with st.form(&quot;login_form&quot;, clear_on_submit=False):    username = st.text_input(&quot;👤 帳號&quot;)    password = st.text_input(&quot;🔑 密碼&quot;, type=&quot;password&quot;)    login_btn = st.form_submit_button(&quot;登入&quot;)    if login_btn:        if check_ad_credentials(username, password):            # 登入成功，取得使用者資訊            user_info = get_user_info_one(&quot;sAMAccountName&quot;, username)            res=parse_dn(user_info[&#x27;DP_STR&#x27;])            st.toast(f&quot;🎉 登入成功 &#123;user_info[&#x27;USR_NAME&#x27;]&#125; ...&quot;)            myrole=white_list(res[&#x27;organization_units&#x27;][0][0:3])            st.session_state.role = myrole            if myrole == &quot;NONE&quot;:                st.error(&quot;❌ 權限不足，請聯絡---設計股林宗漢。&quot;)            time.sleep(3)            st.rerun()        else:            st.error(&quot;❌ 帳號或密碼錯誤，請再試一次。&quot;)\r\n實際畫面\r\n\r\n\r\nFig1. 帳號密碼入口\r\n\r\n\r\n\r\nFig2. 授權通過後畫面\r\n\r\n錯誤紀錄\r\n\r\n在check_ad_credentials中的conn = Connection(server, user=user_upn, password=password, authentication='SIMPLE', auto_bind=True)如果用conn = Connection(server, user=user_upn, password=password, authentication='NTLM', auto_bind=True)會報錯。\r\n\r\nNTLM是比較加強的驗證格式，簡單的可以用SIMPLE就好。\r\n\r\n\r\n","categories":["基本原理"],"tags":["Python"]},{"title":"工程招標文件線上套印作法","url":"/posts/169262062/","content":"前言\r\n公部門工程案要上網招標之前都會需要製作招標文件及投標表單，其內容包含:\r\n\r\n招標文件\r\n\r\n\r\n工程採購契約\r\n投標須知\r\n\r\n\r\n投標表單\r\n\r\n\r\n標單\r\n標封\r\n投標文件審查表\r\n退還押標金申請單\r\n押標金查詢同意書\r\n使用印章授權書\r\n投標廠商聲明書\r\n投標切結書\r\n身分揭露表\r\n\r\n既有作法是利用WordVBA搭配Excel內容套印，但若招標文件有版本更迭時，需要將每個同仁的檔案進行更換才能進行正確的內容輸出，這對於版本控管有相當大的難度。\r\n為了減少版本更迭的問題，目前設計直接將最新的內容推送到伺服器位置，前端則利用網頁進行資料填寫，自此就能夠及時輸出最正確的資料，希望透過這樣的設計能夠減少招標文件產製的版本疏漏。\r\n\r\n概略作法\r\n\r\n儲存預計要取代的文字內容及標籤名稱。\r\n將範本word複製一份出來進行修改。\r\n檢查word中是否有標籤名稱。\r\n如果有找到，將標籤名稱進行取代後輸出。\r\n輸出內容打包成ZIP，讓使用者下載使用。\r\n\r\n必要知識點\r\n\r\nStreamlit\r\npython-docx\r\n\r\n操作網頁\r\n🔗\r\n工程招標文件V1.2.3\r\n標籤\r\n目前的實作用 %%\r\n當作標籤的偵測點，演算過程會針對整個段落進行，偵測到後才會將標籤名稱進行文字取代。\r\n\r\n\r\nFig1. 標籤範例\r\n\r\n多執行緒\r\n以前是使用 Word VBA\r\n進行檔案的處理，礙於VBA為單執行緒的處理，即便CPU有很多顆，但他一次只能夠處理一份文件，沒有辦法發揮多顆CPU的效果，導致文件在生成過程都會需要排隊，消耗不少時間。\r\nPython可以藉由多執行緒的演算法來同時併發檔案的處理，讓整體產製招標文件過程時間下降，甚至瞬間就完成，對於時間相當寶貴的現代來說相當有幫助!\r\nimport concurrent.futuresimport time# 模擬任務: 假設處理時間為隨機數值的延遲def task(task_id):    print(f&quot;任務 &#123;task_id&#125; 開始處理...&quot;)    time.sleep(2)  # 模擬處理延遲    print(f&quot;任務 &#123;task_id&#125; 處理完成！&quot;)    return f&quot;結果: 任務 &#123;task_id&#125;&quot;def main():    # 使用 ThreadPoolExecutor 來並行處理多個任務    with concurrent.futures.ThreadPoolExecutor(max_workers=4) as executor:        # 提交任務給執行緒池        tasks = [executor.submit(task, i) for i in range(5)]        # 等待所有任務完成並獲取結果        for future in concurrent.futures.as_completed(tasks):            result = future.result()            print(result)if __name__ == &quot;__main__&quot;:    main()\r\n\r\n本篇為採用Streamlit，仍然屬於單執行緒的並不原生支持多執行緒，上方範例程式碼僅說明python有支持多執行緒的撰寫方式，於DOS指令上可以發揮其效果。\r\n\r\n後續發展\r\n目前的介面仍賴於使用者進行資料填寫後點選按鈕輸出，然而身為一名程式設計師，要填寫的資料越少越好，因此讓填寫資料這件事情給送審預算書的同事進行，針對預算書審查的內容進行填報。\r\n預算書審查\r\n資料盡可能重複利用，讓了解詳情的人員進行填寫最有效率，Streamlit好處是他可以自動適應各種裝置，所以手機部分也可以進行填寫，版型上也不至於太難看，在此可以將部屬的網頁做成QRCODE貼在辦公室主機旁，讓送審人員直接掃描填寫。\r\n\r\n\r\nFig2. 預算書審查畫面\r\n\r\n工程案件總覽\r\n目前發展剛起步，未來可以做儀表板控制目前進度及預算分配情形。\r\n\r\n\r\nFig3. 工程案件總覽畫面\r\n\r\n載入招標文件\r\n選擇已送審預算書內容，將其所填寫的資料依序導入到投標文件的欄位中，此處需要填寫的只有押標金金額及履約保證金。\r\n\r\n\r\nFig4. 載入招標文件畫面\r\n\r\n後記\r\n礙於公部門有資料外洩的疑慮，在此僅能提供招標文件產製網頁供使用，未來如有需要建立資料庫可再引用原始碼至貴單位進行使用，資料庫的建置又是另外一個課題了，本篇不再贅述。\r\n","categories":["專案成果"],"tags":["Streamlit","Python-docx"]},{"title":"公司行號發函VBA系統","url":"/posts/675663677/","content":"🚩使用者情境\r\n\r\n想請問有沒有可能用VBA\r\n去做一般公司行號發函的系統，因為目前公司是土法煉鋼用WORD去打，但是每次都要做兩個檔案正本跟副本，因為有時候發文是需要發給業主跟PCM，甚至是發文編號也能系統根據日期自動整理產生\r\n\r\n🛒需求分析\r\n基本流程\r\n\r\ngraph TD;\r\n    A[接獲單位來文] --> B{開始進行公文填寫};\r\n    B -->|手動填寫| C[取得公文文號];\r\n    B -->|匯入範本| C;\r\n    C --> D[輸入主旨、說明];\r\n    D --> E[選取附件內容];\r\n    E --> F[選擇正副本收文對象];\r\n    F --> G[提送表單];\r\n    G --> H{是否為通用類型?};\r\n    H -->|是| I[建立為範本] --> J[列印公文];\r\n    H -->|否| J[列印公文];\r\n\r\n使用者畫面\r\n \r\n資料庫\r\n\r\n\r\nFig3. 工作表規劃\r\n\r\n報表\r\n最終成品\r\n\r\n\r\nFig4. 報表最終長相\r\n\r\n資料夾架構\r\n於Excel的同個目錄下會出現三個資料夾\r\n\r\n發文PDF:存放公文PDF，根據不同的正本副本機關皆進行儲存!\r\n發文原始檔:存放印製成PDF的Excel檔\r\n附件資料夾:根據各個不同公文編號提送表單時的附件內容拉取至該資料夾存放\r\n\r\n🐞錯誤紀錄\r\n1. 說明格式\r\n說明內容有很多點時，Excel產製的格式無法像Word有縮行段落。\r\n發生原因\r\n原本的設計是將說明欄位的內容直接代入套版的某一儲存格。\r\n解決方法\r\n在表單上要輸入資料時，如有分行需求，用shift+Enter讓內容跳至下個段落，程式在判斷時就能找到vbCrLf\r\n這個關鍵字進行拆分，拆分就能得知順序，再將順序編號代入到B欄位、順序內容代入到C欄位，就能製作出類似Word的縮行段落。\r\n\r\n\r\nFig5. 模擬Word縮行的套版位置\r\n\r\n2. 內容消失\r\n儲存格欄位無法自動跟著內容的自動換行進行放大，導致部分內容會被儲存格的列高限制其顯示內容。\r\n發生原因\r\n在程式碼中設定\r\nrows.autofit，但如果遇到合併儲存格時就會失效。\r\n解決方法\r\n取得合併儲存格的各個欄位寬度，在不進行列印的單儲存格設定其寬度等同合併儲存格的各個欄位寬度總和，並且自動換行、字型大小都需要一致，未來在進行自動列高調整時就會去抓取該單儲存格的屬性自行調整。\r\n\r\n\r\nFig6.\r\n列高自動調整標的位置(紅=主旨，藍=說明)\r\n\r\n3. 列印成果\r\nExcel中的版型看起來的畫面與預覽畫面相符，但是輸出成PDF的時候就會有些許落差。\r\n發生原因\r\n不明，猜測是檢視設定為分頁模式?\r\n解決方法\r\n將檢視調整為整頁模式則可以正常列印，版型不會有變化，文字也會如預覽時的位置。\r\n4. 附件選取\r\n附件夾帶時無法選擇不同目錄下的檔案內容。\r\n發生原因\r\nApplication.FileDialog(msoFileDialogFilePicker)\r\n天生限制只能在同一個目錄下進行選擇多個檔案路徑。\r\n解決方法\r\n讓使用者能有機會表達我還要選擇檔案，詳細程式碼如下所示:\r\nFunction SelectFiles() As String    Dim fd As FileDialog    Dim filePath As String    Dim selectedItem As Variant    Dim response As VbMsgBoxResult        &#x27; 建立 FileDialog 物件 (選擇檔案模式)    Set fd = Application.FileDialog(msoFileDialogFilePicker)        &#x27; 設定允許多選    fd.AllowMultiSelect = True    fd.Title = &quot;請選擇檔案&quot;        &#x27; 初始化檔案路徑變數    filePath = &quot;&quot;        &#x27; 進入循環，允許用戶多次選擇檔案    Do        &#x27; 顯示對話框        If fd.Show = -1 Then            &#x27; 遍歷所有選取的檔案            For Each selectedItem In fd.SelectedItems                filePath = filePath &amp; selectedItem &amp; &quot;;&quot;            Next selectedItem        End If                &#x27; 問用戶是否還想選擇更多檔案        response = MsgBox(&quot;是否選擇更多檔案?&quot;, vbYesNo)                &#x27; 如果選擇「否」，則退出循環        If response = vbNo Then Exit Do    Loop        &#x27; 移除最後一個 &quot;;&quot;    If Len(filePath) &gt; 0 Then filePath = Left(filePath, Len(filePath) - 1)        &#x27; 回傳選取的檔案路徑（如果未選取則回傳空字串）    SelectFiles = filePath        &#x27; 清除物件    Set fd = NothingEnd Function\r\n","categories":["專案開發"],"tags":["ExcelVBA"]},{"title":"施工抽查紀錄表管控系統","url":"/posts/304659370/","content":"前言\r\n抽查紀錄表帶去現場寫完後會掃描留存成電子檔，抽查過程通常會拍攝佐證照片檢附於後方，以利呈現給委員檢視抽查過程是否詳實登載，但相信有做過的朋友肯定會覺得這份文件製作過程可說是相當繁雜，筆者本身監造過程也是受了不少苦難，刻骨銘心。\r\n痛點\r\n\r\n抽查記錄表常被要求手寫紀錄，不能用電子檔簽名甚至謄打內容。\r\n抽查照片上傳至LINE群組，會有過期問題，必須常常下載歸檔，資料夾分類過程也滿麻煩的。\r\n抽查照片要做成施工抽查表照片報表時，要花很多時間貼照片+撰寫描述文字。\r\n抽查報表PDF分散，如果要列印很多內容的時候不好找。\r\n抽查照片雖然分類了，但如果要找到指定的抽查表編號相關照片可能不好找。\r\n\r\n\r\n如果沒有每天做一些活，到了查核或督導的時候會很可怕的...\r\n\r\n解決方案\r\n開發一套全端的系統，可以做到下列事項\r\n\r\n管理各個專案(工程名稱)\r\n管理各個專案下的抽查表及照片\r\n從抽查表清單列印指定的抽查表範圍\r\n找到指定的抽查表的第幾次的照片\r\n\r\n預期成果\r\n\r\n\r\nFig1. 報表成果\r\n\r\n\r\n\r\n影片成果\r\n\r\n\r\n\r\n\r\n使用須知\r\n\r\n貴單位如果想要導入公司內部系統，可提供程式碼打包服務部署到所指定主機空間，這樣就不會有儲存空間的限制，也不會與他人共用資源。\r\n抽查表照片報表PDF先暫時用這個版型，考量各個單位可能都有所差異，再提供版面洽我修改調整。\r\n目前是用Google帳號控制權限，個人版只能編輯個人生成的專案，要客製成多人共同編輯同一份專案也OK。\r\n\r\n本地佈署方式\r\n(0607更新)在自己的主機部署方式:\r\n\r\n下載 Docker，詳情請參考IT幫幫忙\r\n下載 Git，詳情請參考IT幫幫忙\r\n找某一個資料夾輸入指令\r\n\r\n\r\ngit clone https://github.com/HankLin1995/st_eng.git\r\n\r\n\r\n移動至 st_eng 資料夾中，輸入指令\r\n\r\n\r\ndocker-compose up --build -d\r\n\r\n\r\n打開瀏覽器輸入 localhost:8501 應該就看的到了!\r\n\r\nPS:如果嫌安裝GIT太麻煩，也可以直接到原始碼頁面下載ZIP，解壓縮後再移動進去也可\r\n相關畫面\r\n\r\n\r\nFig2. 新增抽查表畫面\r\n\r\n\r\n\r\nFig3.\r\n新增抽查表畫面(照片可多張)\r\n\r\n\r\n\r\nFig4.\r\n抽查表清單畫面，勾選後可列印成報表成果\r\n\r\n\r\n\r\nFig5.\r\n照片圖廊，如要增加照片可在這裡新增\r\n\r\n","categories":["專案成果"],"tags":["Streamlit","FastAPI","監造"]},{"title":"批次轉換doc到pdf","url":"/posts/1066861632/","content":"🙌前言\r\n\r\n交通部的部頒規範下載下來之後會變成很多細碎的檔案，包含PDF跟DOC，在進行檔案內容搜尋的時候時常需要跨檔案比對，無法在同個檔案中一次到位。\r\n有些規範有進行修改的內容需要先修改doc後再輸出PDF，乾脆將所有PDF都先進行刪除，後續再針對資料夾批次轉檔成PDF後再做合併。\r\n\r\n解決目標:將doc修改完畢後輸出為pdf，丟到pdf_merge中進行合併，這實在是很麻煩。\r\n\r\n本篇介紹如何撰寫程式碼來簡化製作公路橋梁設計規範的流程，有興趣請繼續閱讀\r\n\r\n\r\n檔案來源\r\n\r\n原始檔案下載連結 \r\n原始檔案下載內容 \r\n預先處理內容 \r\n\r\n\r\n👉Python的解決方案\r\n預計使用工具為docx2pdf進行轉檔\r\ndocx2pdf\r\n使用時所輸出的內容一直出現空白頁，而且可以接受的內容也只有docx\r\n可能是我還沒研究透徹...?\r\nfrom docx2pdf import convertimport osdef convert_docx_to_pdf(input_folder, output_folder):    # 確保輸入文件夾存在    if not os.path.exists(input_folder):        print(&quot;輸入文件夾不存在！&quot;)        return    # 確保輸出文件夾存在    os.makedirs(output_folder, exist_ok=True)    # 遍歷輸入文件夾中的所有文件    for filename in os.listdir(input_folder):        if filename.endswith(&quot;.docx&quot;) :#or filename.endswith(&quot;.doc&quot;):            print(f&quot;&#123;filename&#125; found&quot;)            input_path = os.path.join(input_folder, filename)            output_filename = filename.replace(&quot;.docx&quot;, &quot;.pdf&quot;)            output_path = os.path.join(output_folder, output_filename)            # 將 Word 文件轉換為 PDF                        convert(input_path, output_path)            print(f&quot;&#123;filename&#125; 轉換完成&quot;)if __name__ == &quot;__main__&quot;:    input_folder = r&quot;D:\\GoogleDrive-參考手冊\\公路橋梁設計規範&quot;  # 輸入文件夾的路徑    output_folder = r&quot;D:\\Python\\pdf_output&quot;  # 輸出文件夾的路徑    convert_docx_to_pdf(input_folder, output_folder)\r\n後來還是想別的辦法去轉檔。\r\n\r\n👍最終選擇\r\n身為忠臣的VBA用戶，如果能夠用VBA處理會是比較得心應手的，突然想起\r\nExcel VBA 本身可以呼叫 Word VBA 執行PDF轉檔。\r\n&#x27;以下內容來自與ChatGPT之間的對話+我自己稍微修改Sub ConvertDocToPDF()    Dim WordApp As Object    Dim WordDoc As Object    Dim FolderPath As String    Dim FileName As String    Dim PDFFileName As String        &#x27; ?置 Word ?用?象    On Error Resume Next    Set WordApp = GetObject(, &quot;Word.Application&quot;)    If WordApp Is Nothing Then        Set WordApp = CreateObject(&quot;Word.Application&quot;)    End If    On Error GoTo 0        &#x27; ?置 Word ?用?不可?    WordApp.Visible = False        &#x27; ?置文件?路?    FolderPath = &quot;D:\\GoogleDrive-參考手冊\\公路橋梁設計規範&quot; &#x27; 更改?你的文件?路?        &#x27; 遍?文件?中的所有 Word 文件    FileName = Dir(FolderPath &amp; &quot;\\*.doc*&quot;)    Do While FileName &lt;&gt; &quot;&quot;        &#x27; 打? Word 文?        Set WordDoc = WordApp.Documents.Open(FolderPath &amp; &quot;\\&quot; &amp; FileName)                &#x27; 构建 PDF 文件名        PDFFileName = Replace(FolderPath &amp; &quot;\\&quot; &amp; FileName, &quot;.doc&quot;, &quot;.pdf&quot;)                &#x27; 保存? PDF        WordDoc.ExportAsFixedFormat OutputFileName:=PDFFileName, ExportFormat:=17 &#x27; 17 表示 PDF 格式                &#x27; ?? Word 文?        WordDoc.Close False                &#x27; ??下一?文件        FileName = Dir    Loop        &#x27; ?? Word ?用    WordApp.Quit        &#x27; ?放?象    Set WordDoc = Nothing    Set WordApp = Nothing        MsgBox &quot;列印完成！&quot;End Sub\r\n\r\n暫時結果\r\n經過轉檔之後，原本是doc或docx的檔案都會依照原本名稱變成pdf的副檔名\r\n下一步就是要進行pdf合併了!!\r\n\r\n\r\nFig4.暫時生成結果\r\n\r\n\r\n列印順序\r\n因為PDF文件的名稱不一定是我所需要的順序\r\n希望能夠依循下列步驟\r\n\r\n列出該檔案夾中的檔案名稱順序成為CSV檔案\r\n根據我所指定的順序進行選取合併\r\n\r\n\r\n生成CSV順序\r\nimport osimport csvdef list_pdf_files_to_csv(input_folder, output_csv):    # 打开 CSV 文件以写入模式    with open(output_csv, &quot;w&quot;, newline=&#x27;&#x27;, encoding=&#x27;utf-8-sig&#x27;) as csv_file:        # 创建 CSV writer 对象        csv_writer = csv.writer(csv_file)        csv_writer.writerow([&#x27;順序&#x27;,&#x27;檔案名稱&#x27;,&#x27;檔案路徑&#x27;])        order=1        # 遍历输入文件夹中的所有文件        for filename in os.listdir(input_folder):            # 检查文件名是否以 &quot;.pdf&quot; 结尾            if filename.lower().endswith(&quot;.pdf&quot;):                # 将文件信息写入 CSV 文件                file_path = os.path.join(input_folder, filename)                csv_writer.writerow([order,filename, file_path])                # 更新顺序号                order += 1if __name__ == &quot;__main__&quot;:    input_folder =r&quot;D:\\GoogleDrive-參考手冊\\公路橋梁設計規範&quot;  # 输入文件夹的路径    output_csv = r&quot;D:\\Python\\pdf_doc\\pdf_files.csv&quot;  # 输出 CSV 文件的路径    list_pdf_files_to_csv(input_folder, output_csv)\r\n生成之後可以藉由Excel的幫助進行順序排序，再另存為csv檔案的格式就可以備用。\r\n根據CSV順序進行合併\r\nimport osimport csvfrom PyPDF2 import PdfMergerdef read_csv_to_pdf_files(csv_file):    pdf_files = []    # 打开 CSV 文件并读取内容    #with open(csv_file, &quot;r&quot;, newline=&#x27;&#x27;,errors=&#x27;replace&#x27;) as file:#有出現問題的話用這行    with open(csv_file, &quot;r&quot;, newline=&#x27;&#x27;,encoding=&#x27;utf-8-sig&#x27;) as file:#全新虛擬環境用這行        reader = csv.reader(file)        next(reader)  # 跳过标题行        for row in reader:            order = row[0]#第一列是顺序            filename = row[1]  # 第二列是文件名            pdf_path = row[2]  # 第三列是 PDF 文件的绝对路径            pdf_files.append((order, filename, pdf_path))    return pdf_filesdef merge_pdfs_directly(pdf_files,output_folder):    # 创建一个 PdfMerger 对象    merger = PdfMerger()    # 遍历列表中的每个元素 這個不能亂改會報錯    for order, filename,pdf_path in pdf_files:        # 将 PDF 文件添加到合并器中        merger.append(pdf_path)    # 确保输出文件夹存在    os.makedirs(output_folder, exist_ok=True)    # 将合并后的 PDF 保存到文件    output_path = os.path.join(output_folder, &quot;merged_pdf.pdf&quot;)    merger.write(output_path)    # 关闭合并器    merger.close()if __name__ == &quot;__main__&quot;:    csv_file = r&quot;D:\\Python\\pdf_doc\\pdf_files.csv&quot;  # CSV 文件的路径    pdf_files = read_csv_to_pdf_files(csv_file)    output_folder = r&quot;D:\\Python\\pdf_doc&quot;  # 输出文件夹的路径    merge_pdfs_directly(pdf_files,output_folder)\r\n最終成果\r\n藉由vba的轉檔及python的合併處理成的檔案，總共有432頁的PDF 🔗\r\n🔗完整版-公路橋梁設計規範成果下載\r\n\r\n\r\n👻開發過程的問題\r\n操作CSV的過程曾經出現一些奇怪的問題，記錄一下比較不會忘記\r\n檔案名稱為中文，要收集匯入csv檔案的時會變成亂碼\r\n需要將編碼由utf-8改為utf-8-sig\r\nwith open(output_csv, &quot;w&quot;, newline=&#x27;&#x27;, encoding=&#x27;utf-8-sig&#x27;) as csv_file: \r\nCSDN參考\r\n要將CSV的內容匯入到python進行後續運用時會出現'UnicodeDecodeError'\r\n將原本的讀取內容中的encoding換成\r\nerrors='replace' 即可\r\nwith open(&#x27;some.csv&#x27;, newline=&#x27;&#x27;, encoding=&#x27;utf-8&#x27;) as f:  reader = csv.reader(f)  for row in reader:    print(row)\r\nwith open(&#x27;some.csv&#x27;, newline=&#x27;&#x27;, errors=&#x27;replace&#x27;) as f:   reader = csv.reader(f)   for row in reader:    print(row)\r\nStack\r\noverflow參考資料\r\n開啟一個全新的環境，要將CSV的內容匯入到python進行後續運用時會出現\r\nFileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\\\GoogleDrive-������������\\\\��祈楝璈�璇�閮剛��閬� 蝭�\\\\蝚砌��蝡� 蝮賢��1090103.pdf\r\n原本第二點可以解決編譯問題的程式碼調整 errors='replace'\r\n已經無法作用，我把encoding='utf-8-sig'重新加上去，然後就好了(?)\r\n\r\n猜測是新的環境中還沒有預設的encoding，所以中文還沒有辦法被知道要怎麼編譯。\r\n\r\nwith open(&#x27;some.csv&#x27;, newline=&#x27;&#x27;, encoding=&#x27;utf-8-sig&#x27;) as f:  reader = csv.reader(f)  for row in reader:    print(row)\r\n","categories":["專案開發"],"tags":["python","ExcelVBA"]},{"title":"施工日誌VBA-V3.6.0系列更新說明","url":"/posts/3015163677/","content":"前言\r\n本篇文章延伸於 施工日誌VBA-V3.5.0\r\n版本操作教學，非常感謝各路好友提供寶貴意見，本篇下方會詳列各版本修改進程供各位做參考。\r\n\r\n新功能\r\n\r\n\r\n後處理工具匯入\r\n契約項目搜尋\r\n不計工期\r\n自動換行\r\n\r\n\r\n錯誤修復\r\n\r\n\r\n欄位寬度摺疊顯示\r\n工料設定自動編號\r\n\r\n\r\n主要功能說明\r\n[契約設定]後處理工具匯入\r\n\r\n\r\nFig1. 匯入畫面\r\n\r\n考量有些專案不一定會用PCCES來處理預算書內容，可能只是一個很像的EXCEL檔，故提供\"契約設定模板\"範本供使用者手動填寫再進行匯入，需注意填寫過程項次不能重複。\r\n[日報填寫]契約項目搜尋\r\n\r\n\r\nFig2. 填寫畫面\r\n\r\n契約項目的下拉式選單組成為\"契約項次&gt;&gt;契約項目\"，故可以進行契約項目關鍵字的搜尋或者契約項次的關鍵字搜尋。\r\n\r\n舉例: \r\n\r\n\r\n\r\n如要進行契約項次的搜尋，輸入關鍵字「甲.壹」，則會列出所有甲.壹開頭的契約項目\r\n如要進行契約項目的搜尋，輸入關鍵字「安全圍籬」，則會列出所有名稱具有安全圍籬的契約項目。\r\n\r\n\r\n不計工期功能\r\n\r\n\r\nFig4. 進度設定畫面\r\n\r\n建立不計工期工作表，如為不計工期的日期時，進度與前日有計工期時相同\r\n\r\n\r\nFig5. 範例\r\n\r\n自動換行\r\n輸出施工日誌時，如有契約項目比較長的情況，以往採用欄位內文字大小自動縮放進行處理，然而如文字長度過長時，會讓契約項目變得無法肉眼識別，因此改用自動換行搭配列高自動調整處理。\r\n\r\n主要錯誤說明\r\n欄位寬度摺疊顯示\r\n\r\n\r\nFig6. 欄位摺疊範例\r\n\r\n欄位寬度不足以顯示日期時，EXCEL內建的搜尋功能會失效，故在進行搜尋前先針對預計要搜尋的工作表進行欄寬自動適應。\r\n工料設定自動編號\r\n原工料設定過程在編號時會透過計算同性質的個數做加總後加一換算，如果有先進行刪除再自動編號的話會有編號重疊的問題，導致報表輸出時的搜尋功能異常，故改為自動編號之前先針對同性質的內容排序後取最大值加一換算。\r\n\r\n版本細節\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n版本號\r\n型態\r\n內容\r\n\r\n\r\n\r\n\r\nV3.6.6\r\nFeature\r\n數量計算表頁尾加入第O頁/共O頁\r\n\r\n\r\n\r\nFix\r\n修正工料設定自動編號重複問題\r\n\r\n\r\nV3.6.5\r\nFix\r\n調整各表欄位自動縮放，避免出現###影響搜尋\r\n\r\n\r\nV3.6.4\r\nFix\r\n列印報表時預設為第一個報表項目\r\n\r\n\r\nV3.6.3\r\nFix\r\n第六項列高自動調整\r\n\r\n\r\nV3.6.2\r\nFix\r\n修復clsInfo查找欄位問題、列印日報前會先進行進度重整\r\n\r\n\r\nV3.6.1\r\nFix\r\n修復呈現竣工日期欄位找尋問題(clsReport)\r\n\r\n\r\nV3.6.0\r\nFeature\r\n第二大項跟第三大項數量沒有就增列一行空白列\r\n\r\n\r\n\r\nFeature\r\n施工日誌成果依照日期呈現(原本設計為按照編號)\r\n\r\n\r\n\r\nFeature\r\n機具、人力、材料按照類別排序\r\n\r\n\r\nV3.5.12\r\nFix\r\n數量計算表原呈現0.00修正為-\r\n\r\n\r\n\r\nFix\r\n前期完成數量公式修正\r\n\r\n\r\n\r\nFix\r\n數量計算表表報編號欄位補上錯誤控制\r\n\r\n\r\nV3.5.11\r\nFix\r\n工料設定下拉式選單更新，修改生效日控制，可以進行刪除\r\n\r\n\r\n\r\nFeature\r\nfrmData剩餘數量提醒紅字增加警告視窗!\r\n\r\n\r\n\r\nFeature\r\n表單顯示修改成\"不\"強制響應\r\n\r\n\r\n\r\nFix\r\nP008 列高自動調整\r\n\r\n\r\nV3.5.10\r\nFeature\r\n加入搜尋功能，可以搜尋項目或搜尋項次，空白則全顯\r\n\r\n\r\n\r\nFeature\r\n加入新報表，建築物施工日誌(不含項次)，修復本日不施工欄位\r\n\r\n\r\n\r\nFix\r\n新增數量計算表，工作表名為建築物施工日誌(月底)\r\n\r\n\r\n\r\nFix\r\n施工項目呈現的數量到小數點後第2位，Numberformatlocal\r\n\r\n\r\n\r\nFix\r\n表報編號顯示修改為&lt;&gt;，使用字串格式\r\n\r\n\r\nV3.5.9\r\nFeature\r\n加入新報表，建築物施工日誌(月底)，為數量計算表\r\n\r\n\r\n\r\nFeature\r\n輸出報表時字體大小設置10pt為自動換行，做AutoFit顯示\r\n\r\n\r\n\r\nFix\r\n調整契約項目主項大類判定欄位為\"單位\"=空白\r\n\r\n\r\n\r\nFeature\r\n加入契約項目標記\"H\"為折疊項目\r\n\r\n\r\nV3.5.8\r\nFix\r\n修復eng_pgs&lt;&gt;1的錯誤，如果為double需要先做round(x,6)\r\n\r\n\r\n\r\nFeature\r\n加入不計工期功能，功能位於frmPgs的右下角\r\n\r\n\r\nV3.5.7\r\nFix\r\n加入\"本日無施工\"項目，預設進度為前日累計進度\r\n\r\n\r\nV3.5.6\r\nFix\r\n列印報表時隱藏空白列位材料名稱偵測修復(hideEmptyRow)\r\n\r\n\r\nV3.5.5\r\nFeature\r\n基本操作權限控管加入clsFetchURL\r\n\r\n\r\nV3.5.4\r\nFix\r\n契約項目中主項目判定修復(IsMainItems(cont))\r\n\r\n\r\n\r\nFeature\r\n契約項目可以引入後處理工具產生之excel\r\n\r\n\r\n\r\nFix\r\n不計入進度項目仍提供給使用者進行填寫\r\n\r\n\r\nV3.5.3\r\nTODO\r\n新增監造報表(管理處)版本-尚未完成\r\n\r\n\r\n\r\nFix\r\n變更設計後其契約數量為0的監造日報顯示文字修正\r\n\r\n\r\n\r\nFeature\r\n新增getRangeByKey，優化adjustRow、hideEmptyRow\r\n\r\n\r\nV3.5.2\r\nFix\r\n資料要進入各表時，先做好欄位格式處理(日期)\r\n\r\n\r\nV3.5.1\r\nFix\r\n當編輯日報引入資料至frmData時，再進行新增無法清空(clearFrmDataInfo)\r\n\r\n\r\n\r\nFix\r\n日報表單原本預設非是即無，新增空白項目並設定為預設\r\n\r\n\r\n\r\n","categories":["專案開發"],"tags":["ExcelVBA","施工日誌"]},{"title":"施工日誌VBA-列印篇","url":"/posts/997099184/","content":"前言\r\n本篇文章延伸於 施工日誌VBA-V3.5.0\r\n版本操作教學\r\n版面格式有可能因為業主的要求或委員的要求而有些許不同，難以千篇一律的內容應付所有的機關，當初在設計軟體時就有考量到這個部分，故讓報表生成的過程盡可能的彈性，能夠在這個說A改B的環境下好好適應各種狀況，本篇文章主要介紹施工日誌VBA可供輸出的報表格式及微調版型的方法，盡可能以公版作為預設，真的需要再來調整。\r\n以下相關設定按鈕皆需透過工作表\"版本說明\"點選按鈕【功能主要畫面】後進行。\r\n\r\n報表格式\r\n\r\n\r\nFig1. 列印日報介面\r\n\r\n契約項目分類\r\n\r\n累積數量不為0(曾經施作的工項)\r\n本日數量不為0(今天施作的工項)\r\n全部契約項目\r\n\r\n版型分類\r\n\r\n公共工程施工日誌(第一聯)\r\n公共工程施工日誌(第二聯)\r\n建築物施工日誌(第一聯)\r\n建築物施工日誌(第二聯)\r\n監造報表(第一聯)\r\n\r\n\r\n如果契約項目分類採用本日數量不為0除每日固定要輸出的第一聯外，會在每月或每周再另外製作第二聯，頻率視機關規定而定。\r\n\r\n微調版型\r\n每個檔案都會有固定的版型，其範本位於工作表名稱:\r\n\r\n公共工程施工日誌\r\n建築物施工日誌\r\n公共工程施工日誌(第二聯)\r\n建築物施工日誌(第二聯)\r\n監造日報\r\n\r\n\r\n\r\nFig2. 版型工作表\r\n\r\n主要關鍵字\r\n範本中由&lt;&lt;&gt;&gt;包住的儲存格文字不能改變，舉例:&lt;&gt;\r\n文字大小微調\r\n如果列印時發現文字太大或大小，都可以直接修改，不要影響到原本的文字內容即可。\r\n額外加註文字\r\n可以在不影響原本的儲存格文字內容下，額外加入註記事項到版面中，惟須注意不能落在原本要生成清單的路線上。\r\n舉例:公共工程施工日誌的第二項、工地材料管理概況(列號108~128)雖然都是空白的，但它屬於材料的清單明細路線，不能再插入其他關鍵字使用。\r\n\r\n\r\nFig3. 不能額外加註之清單明細\r\n\r\n列印成果\r\n測試版\r\n\r\n預設列印成pdf(有加入浮水印，僅供測試功能使用)\r\n\r\n\r\n\r\nFig4. 測試版成品\r\n\r\n\r\n正式版\r\n\r\n預設列印成xls(可以直接批次輸出，列印時可以選擇列印整本活頁簿)\r\n\r\n\r\n\r\nFig5. 正式版成品\r\n\r\n相關連結\r\n🔗\r\n施工日誌VBA-設定篇\r\n🔗\r\n施工日誌VBA-記錄篇\r\n","categories":["專案開發"],"tags":["Excel VBA","施工日誌"]},{"title":"施工日誌VBA-版本說明","url":"/posts/1512537146/","content":"版本內容比較\r\n\r\n\r\n\r\n項目\r\n訂閱版\r\n\r\n\r\n\r\n\r\n基本功能\r\nO\r\n\r\n\r\n錯誤修復\r\nO\r\n\r\n\r\n技術支援\r\nO\r\n\r\n\r\n原始碼\r\n\r\n\r\n\r\n使用期限\r\n工程期間\r\n\r\n\r\n\r\n備註事項\r\n\r\n施工日誌舊版(社群版)正在使用中的朋友仍可使用到2024年底，如需轉換至新版請聯繫作者協助。\r\n如欲購置施工日誌新版(V3.5.0)系列後之訂閱包套服務(包含變更設計、展延工期、契約項目導入)，請提供以下資料並聯繫作者\r\n\r\n\r\n工程名稱\r\n契約金額\r\n工程日數\r\n\r\n\r\n聯繫方式\r\n\r\n\r\nLINE(ID:@903qzhwa)\r\n電子郵件(apple84026113@gmail.com)\r\n\r\n\r\n\r\n基本功能\r\n\r\n公共工程施工日誌(第一聯、第二聯)\r\n建築物施工日誌(第一聯、第二聯)\r\n監造日報\r\n\r\n錯誤修復\r\n\r\n修復重大系統錯誤\r\n\r\n技術支援\r\n\r\n公版報表微調\r\n客製功能擴充(按工時另計)\r\n變更設計異動\r\n展延工期調整\r\n\r\n法規來源\r\n建築物施工日誌\r\n公共工程施工日誌\r\n相關連結\r\n🔗\r\n施工日誌VBA-V3.5.0\r\n🔗\r\n施工日誌VBA-設定篇\r\n🔗\r\n施工日誌VBA-記錄篇\r\n🔗\r\n施工日誌VBA-列印篇\r\n","categories":["專案成果"],"tags":["Excel VBA","施工日誌"]},{"title":"施工日誌VBA-記錄篇","url":"/posts/426352985/","content":"前言\r\n本篇文章延伸於 施工日誌VBA-V3.5.0\r\n版本操作教學\r\n從前篇第1步驟開始進行的朋友，會發現有一個生效日是空白的，這就是讓使用者要開始填寫日報前的最後確認，確認無誤後便會將生效日加註(第一次加註會與開工日相同)，此時才能開始填寫日報，填寫日報後需要點選\"儲存日報\"資料才會生效，取消填寫時只能透過按鈕\"取消填寫\"，不能點選右上角的X。\r\n填寫日報的過程，可以在版本說明中的\"功能主要畫面\"裡面對日報進行新增、編輯、刪除，有關日報填寫內容分為以下幾種內容:\r\n\r\n基本資訊\r\n契約項目\r\n材料\r\n人力\r\n機具\r\n其他備註\r\n監造部分\r\n\r\n\r\n基本資訊\r\n日期\r\n日期在進行新增日報的時候便會要求輸入，如果有重複則會警示已經有填寫過了，本篇旨在介紹工程專案類型，而非開口契約類型，原則每日會有一篇日報作為紀錄使用。\r\n我有預留一日多表的擴充程式碼，如果有需要請聯絡我進行修改。\r\n天氣\r\n天氣部分分為上午跟下午，內容有晴、陰、雨，未來預定會提供一個參考測站，透過中央氣象局API去取得相對時段的自動測報內容。\r\n契約項目\r\n項目\r\n\r\n\r\nFig1. 項目\r\n\r\n契約項目填寫來源為契約設定的項目，有關契約項目有兩項特別要注意的事項:\r\n\r\n設定為不列入進度項目，則不會被計入進度換算時的分母。\r\n設定為發包工作費外的項目，則不會顯示於下拉式選單中。\r\n\r\n選取契約項目後，會同步呈現該項目之契約數量、累計數量，填寫施作數量時，會同時於右側顯示剩餘數量，如出現紅色表示剩餘數量為負值、綠色表示仍有剩餘數量可以使用。\r\n輸入完畢點選\"新增\"，項目將會列於下方暫存區域，可以等所有項目(包含後續內容皆完成後)在一併點選\"儲存日報\"，此時資料才會正式匯入日報中。\r\n進度\r\n進入畫面時，會預先取得累積至前日之金額及進度，當填寫項目後，系統會自動換算本日金額與本日進度呈現於左下角，兩樣數值加總後取得本日累積實際進度，同時會根據實際進度與預定進度的差異呈現紅色或綠色。\r\n材料、人力、機具\r\n項目來源為工料設定，這裡比較單純沒有其他內容，僅作為紀錄使用，於工料設定中如有填寫其相關單價，未來可以加入功能輸出統計長表，讓管理者清楚目前所支出的內容，包含人力費用、材料費用、機具費用，方便與估驗請款後的現金流做比對評估財務支出收入狀況。\r\n\r\n\r\nFig2. 工料設定畫面\r\n\r\n其他備註\r\n\r\n\r\nFig3. 其他備註\r\n\r\n有關其他比較長的文字紀錄部分皆會在此進行，之前委員有說過格子不能塗黑，要打勾，這裡有提供選項給使用者選取，如果讓電腦打勾也不行，請選取兩邊都是空白框框。\r\n另關於施工取樣試驗紀錄與重要事項紀錄未來預計會與收發文系統、品管系統作為綁定使用，請再稍等下!\r\n監造部分\r\n如果只有單純要做施工日誌的使用者，可以跳過這一個步驟。\r\n\r\n\r\nFig4. 監造部分\r\n\r\n有關其他比較長的文字紀錄部分皆會在此進行，打勾情況一樣有做考量，同樣提供三種情況供使用者選取。\r\n目前工程進行情況，可以自行填寫或者是透過前面填寫之契約項目做百分比換算呈現(如下圖)。\r\n\r\n\r\nFig5. 百分比範例\r\n\r\n另關於檢驗停留點及抽查系統作為綁定使用，查核材料規格及品質與品管系統作為綁定使用，請再稍等下!\r\n相關連結\r\n🔗\r\n施工日誌VBA-設定篇\r\n🔗\r\n施工日誌VBA-列印篇\r\n","categories":["專案開發"],"tags":["Excel VBA","施工日誌"]},{"title":"施工日誌VBA-設定篇","url":"/posts/1990910755/","content":"前言\r\n本篇文章延伸於 施工日誌VBA-V3.5.0\r\n版本操作教學\r\n取得主程式時，會預設存在範例資料，可先由範例資料大致了解未來使用過程中資料的模樣會如何，更重要的是可以先試行輸出報表，確認是否符合貴司需求。\r\n如欲開始進行使用，建議依照下列順序進行，除基本設定會另外做重置行為需優先設定外，其餘設定不一定要按照順序。\r\n以下相關設定按鈕皆需透過工作表\"版本說明\"點選按鈕【功能主要畫面】後進行。\r\n\r\n1.基本設定\r\n\r\n設定基本資料\r\n\r\n步驟\r\n\r\n點選按鈕【1.基本設定】\r\n請確認是否清除既有資料並建立新的工程專案?(是/否)\r\n(是)自動執行備份，備份路徑為同目錄下的【backup】資料夾\r\n備份完成後會將資料清空\r\n\r\n基本設定、其他設定\r\n數量表、材料表、機具表、人力表、其他表\r\n\r\n請輸入工程名稱\r\n請輸入承攬廠商\r\n請輸入施工地點\r\n請輸入契約編號\r\n請輸入牌照號碼\r\n\r\n成果\r\n資料會儲存於工作表\"基本設定\"，有關個別欄位介紹請參考下表\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n欄位名稱\r\n內容\r\n用途\r\n\r\n\r\n\r\n\r\n生效日\r\n(空白)\r\n新增日報前確認設定後自動註記，與開工日期同\r\n\r\n\r\n工程名稱\r\nOOOO改善工程\r\n\r\n\r\n\r\n承攬廠商\r\nOO營造有限公司\r\n同承造人\r\n\r\n\r\n施工地點\r\nOO縣OO市\r\n\r\n\r\n\r\n契約編號\r\nA123456\r\n\r\n\r\n\r\n開工日期\r\n(空白)\r\n進度設定後自動註記，為首日日期\r\n\r\n\r\n竣工日期\r\n(空白)\r\n進度設定後自動註記，為末日日期\r\n\r\n\r\n牌照號碼\r\n府建管字第OOOOO號\r\n建/雜/拆照號碼使用\r\n\r\n\r\n契約金額\r\n(空白)\r\n契約設定後自動註記\r\n\r\n\r\n進度金額\r\n(空白)\r\n契約設定後自動註記，為進度計算時之分母\r\n\r\n\r\n\r\n2.契約設定\r\n\r\n設定契約項目，這一步會比較重要且繁瑣，有需要可來信討論或代工\r\n\r\n設定原則\r\n\r\n項次不能重複\r\n複價總和為契約金額\r\n分類為P不納入進度計算分母\r\n分類為N為發包工作費外項目\r\n\r\n步驟\r\nPCCES的XLS\r\n\r\n點選按鈕【2.契約設定】\r\n點選按鈕【引入PCCES】\r\n選擇PCCES產出之XLS檔案\r\n如有舊資料存在，則跳提醒\"你有舊資料存在，確定要刪除?\"\r\n(是)清空資料及分類，並將XLS內容導入\r\n挑選發包工作費外的項目\r\n挑選不計入進度計算的項目\r\n關閉後會自動將\"契約金額\"、\"進度金額\"代入到\"基本設定\"\r\n\r\n備註\r\n選擇PCCES產出之XLS之前，可以先將決標單價修改到XLS的預算單價，未來才不用逐個修正。\r\nPCCES的XML\r\n基本上能取得XML也就能將它匯入到PCCES後輸出XLS了，除非真的沒有辦法，才會採行下列後處理工具進行。\r\n另詳 Excel\r\nVBA @ PCCES契約項目後處理\r\n其他XLS\r\n可以複製貼上到工作表\"契約設定\"或其他任何方式\r\n成果\r\n\r\n\r\n\r\n欄位名稱\r\n內容\r\n用途\r\n\r\n\r\n\r\n\r\n項次\r\n壹.一.1\r\n項次不能重複\r\n\r\n\r\n項目\r\n施工告示牌\r\n\r\n\r\n\r\n單位\r\n片\r\n\r\n\r\n\r\n數量\r\n2\r\n\r\n\r\n\r\n單價\r\n2500\r\n\r\n\r\n\r\n複價\r\n5000\r\n\r\n\r\n\r\n分類\r\n(空白)\r\nP不納入進度、N為發包工作費外\r\n\r\n\r\n\r\n\r\n主項大類如沒有細項，建議將單價、複價皆歸0，避免影響契約金額總和。\r\n\r\n3.工料設定\r\n\r\n設定契約項目\r\n\r\n步驟\r\n新增\r\n\r\n點選按鈕【3.工料設定】\r\n選擇屬性分類(材料)\r\n輸入項目、單位、數量、單價\r\n點選按鈕\"新增\"\r\n\r\n刪除\r\n\r\n點選按鈕【3.工料設定】\r\n選擇屬性分類(材料)\r\n點選要刪除的項目反白後\r\n點選按鈕\"刪除\"\r\n\r\n編輯\r\n\r\n點選按鈕【3.工料設定】\r\n選擇屬性分類(材料)\r\n挑選要編輯的項目後快點兩下\r\n輸入正確數量\r\n輸入正確單價\r\n\r\n成果\r\n\r\n\r\n\r\n欄位名稱\r\n內容\r\n用途\r\n\r\n\r\n\r\n\r\n項次\r\nE0001\r\n\r\n\r\n\r\n項目\r\n挖土機\r\n項目名稱不能重複\r\n\r\n\r\n單位\r\n天\r\n\r\n\r\n\r\n數量\r\n200\r\n\r\n\r\n\r\n單價\r\n1000\r\n\r\n\r\n\r\n\r\n\r\nE開頭為機具\r\nL開頭為人力\r\nM開頭為材料\r\n\r\n4.進度設定\r\n\r\n設定進度項目，包含開工日期、竣工日期、預定進度\r\n\r\n正確設定進度流程是採用拆項目、金額的方式安排起訖日進行，這樣會比較符合實際所需，如要採用較簡便的方式，可以將施工計畫書中的預定進度表取每半月或每月之預定累積進度做內插換算。\r\n步驟\r\n自行輸入\r\n\r\n點選按鈕【4.進度設定】\r\n選取要使用哪個方法引入(1.自行輸入,2.引入甘特圖工具)\r\n(選擇1)\r\n輸入日期、該日預定累積進度後加入\r\n點選按鈕【進度計算】\r\n\r\n引入甘特圖工具\r\n\r\n詳細操作步驟blog Streamlit工程進度甘特圖\r\n工具網頁 工程進度甘特圖工具\r\n\r\n\r\n根據上述內容製作完成後留存XLS備用\r\n點選按鈕【4.進度設定】\r\n選取要使用哪個方法引入(1.自行輸入,2.引入甘特圖工具)\r\n(選擇2)\r\n選取步驟1之XLS\r\n\r\n成果\r\n\r\n\r\n\r\n欄位名稱\r\n內容\r\n用途\r\n\r\n\r\n\r\n\r\n日期\r\n2024/9/25\r\n\r\n\r\n\r\n預定進度\r\n0.00%\r\n\r\n\r\n\r\n實際進度\r\n(空白)\r\n填寫日報儲存後自動註記\r\n\r\n\r\n上午天氣\r\n(空白)\r\n填寫日報儲存後自動註記\r\n\r\n\r\n下午天氣\r\n(空白)\r\n填寫日報儲存後自動註記\r\n\r\n\r\n\r\n相關連結\r\n🔗\r\n施工日誌VBA-記錄篇\r\n🔗\r\n施工日誌VBA-列印篇\r\n","categories":["專案開發"],"tags":["Excel VBA","施工日誌"]},{"title":"施工日誌VBA-V3.5.0正式發佈","url":"/posts/1000661249/","content":"前言\r\n自2018年發布監造日報表VBA及2022年發布公共工程施工日誌資料庫VBA後，陸續有收到很多朋友的回饋，經過一次又一次的迭代修改，該遇到的問題差不多也已經解決了，對於檔案中長期累積的程式碼或許因為在下的功力不夠深厚，遺留下大量的技術債，每次的程式碼編輯會耗費不少時間，而且也需要做大量的測試，為了不要債留子孫，特地花了一些時間通盤檢討進行一次完整的重構，也就是本篇文章的主角-施工日誌VBA-V3.5.0.。\r\n\r\n\r\nFig1.選單內容\r\n\r\n\r\n影片操作\r\n\r\n\r\n首頁\r\n\r\n\r\nFig2.主要進入點\r\n\r\n功能\r\n主要架構可分為設定、紀錄表、格式及資料備份，概述如下\r\n設定相關\r\n\r\n基本設定\r\n\r\n綜理各機關範本所需之基本資料，所需大致為\r\n\r\n工程名稱\r\n承攬廠商(承造人)\r\n施工地點\r\n契約編號\r\n契約金額\r\n開工日期\r\n竣工日期\r\n建/雜/拆照號碼\r\n\r\n\r\n契約設定\r\n\r\n契約項次不能重複，可引入PCCES或後處理工具\r\n\r\n\r\nFig3.契約設定畫面\r\n\r\n\r\n工料設定\r\n\r\n人機料名稱不能重複\r\n\r\n\r\nFig4.工料設定畫面\r\n\r\n\r\n進度設定\r\n\r\n可以透過日期與預定累積進度換算或匯入甘特圖工具之成果\r\n\r\n\r\nFig5.進度設定畫面\r\n\r\n紀錄表相關\r\n\r\n新增日報\r\n編輯日報\r\n刪除日報\r\n列印日報\r\n\r\n紀錄內容包含契約項目、天氣狀況、人機料、備註及監造部分\r\n\r\n\r\nFig6.契約項目編輯畫面\r\n\r\n\r\n\r\nFig7.施工日誌備註編輯畫面\r\n\r\n\r\n\r\nFig8.監造報表備註編輯畫面\r\n\r\n格式相關\r\n\r\n\r\nFig9.列印日報畫面\r\n\r\n\r\n公共工程施工日誌\r\n公共工程施工日誌(第二聯)\r\n建築物施工日誌\r\n建築物施工日誌(第二聯)\r\n監造報表\r\n\r\n\r\n\r\nFig10.公共工程施工日誌成果\r\n\r\n\r\n\r\nFig11.公共工程施工日誌(第二聯)成果\r\n\r\n\r\n\r\nFig12. 公共工程施工日誌成果\r\n\r\n\r\n\r\nFig13. 監造報表成果\r\n\r\n備份還原\r\n啟動時點\r\n\r\n清空資料庫\r\n版本更新\r\n\r\n將設定與紀錄表匯出成新的活頁簿，如版本更新時，可將該活頁簿還原進去。\r\n結語\r\n開發目標盡量以通用為主，但難免有機關會有自己的格式，但這都是可以處理的，當初在開發時已經將擴充的欄位甚至是報表的生成皆已進行考量，有特殊需求的人可以透過左側資訊欄聯繫我(LINE或Email)，舊版本的施工日誌VBA預計只維護到今年年底，明年1/1起將不再提供維護，皆會採用新版進行，如有購置使用的朋友可協助轉換至新版。\r\n\r\n施工日誌VBA相關版本內容請參考版本說明\r\n\r\n⭐\r\n有需要請LINE(ID:@903qzhwa)聯繫或電子郵件(apple84026113@gmail.com)聯繫\r\n相關連結\r\n🔗\r\n施工日誌VBA-設定篇\r\n🔗\r\n施工日誌VBA-記錄篇\r\n🔗\r\n施工日誌VBA-列印篇\r\n🔗\r\n施工日誌VBA-V3.6.0系列更新說明\r\n","categories":["專案成果"],"tags":["Excel VBA","施工日誌","監造報表"]},{"title":"施工照片VBA-實作流程","url":"/posts/144473154/","content":"前言\r\n工程進行階段因為業主、監造不一定都會在現場，無論施工抽查、品質管理、隱蔽部分尺寸紀錄、督導會勘...等等內容，大多數文件都會需要照片作為佐證資料，尤其是假設工程、隱蔽部分更是需要，因此整個工程案進行過程可能會累積大量的照片，後續的請款報表照片貼附、照片檔案查找，會是讓內業人員相當花費時間的一環。\r\n實務上大多會採用LINE群組進行照片上傳，照片說明會出現在畫面中的小白板，再由內業人員自行下載備存，放在本機硬碟中或者是放在公司的NAS裡面，未來需要利用時再去自己所分類的資料夾中比對、下載、貼附，因此對於處理照片的檔案管理、報表輸出我想需要有方法來完成大量、繁複、簡單的工作流程，節省時間來做其他業務內容。\r\n因此，施工照片VBA誕生了，於2023年1月發布給大眾使用運行至今，該修復的內容大概已經完成，以下為目前所釋出的施工照片VBA部分內容，完整內容請參考施工照片VBA完整原始碼。\r\n\r\nDEMO\r\n\r\n\r\n\r\n第一章節 資料夾\r\n1-1 取得資料夾\r\n\r\n學習如何透過VBA內建的資料夾選擇視窗將照片存放路徑放置到工作表\r\n\r\nSub SelectFolder()Dim objDialog As FileDialogSet objDialog = Application.FileDialog(msoFileDialogFolderPicker)With objDialog    If .Show = True Then            Sheets(&quot;Main&quot;).Range(&quot;B2&quot;) = objDialog.SelectedItems(1)        End IfEnd WithEnd Sub\r\n1-2 查看資料夾\r\n\r\n學習如何透過Shell的方法來開啟指定資料夾\r\n\r\nSub showFolder()main_path = Sheets(&quot;Main&quot;).Range(&quot;B2&quot;)Shell &quot;explorer.exe &quot; &amp; main_path, vbNormalFocusEnd Sub\r\n第二章節 照片基本資料\r\n2-1 照片檔案管理\r\n\r\n\r\n資料庫介面\r\n\r\nSub getDataFromFolder()Dim clsInf As New clsInformationDim objFile As New clsmyFileWith Sheets(&quot;Main&quot;)&#x27;If MsgBox(&quot;是否要貼上縮圖?&quot;, vbYesNo) = vbYes ThenIf clsInf.IsPasteIMG = True Then    objFile.IsPaste = True    mywidth = CInt(clsInf.getIMGwidth) &#x27;  CInt(InputBox(&quot;請輸入縮圖寬度:&quot;))    objFile.photo_width = mywidth / 4    objFile.photo_height = mywidth    End IfobjFile.main_path = .Range(&quot;B2&quot;)objFile.delRng &#x27;刪除既有欄位objFile.getAllFolder &#x27;循環取得指定資料夾中所有照片路徑objFile.PastePictures  &#x27;依序貼上到操作介面End WithCall extractNames &#x27;由檔名萃取至介面欄位Call ApplyFilterToAllUsedCells &#x27;End Sub\r\n\r\n刪除既有欄位\r\n\r\nSub delRng()tmp = split(main_path, &quot;\\&quot;)main_folder = tmp(UBound(tmp))With shtResult&#x27;.Range(&quot;A1:F1&quot;) = Array(&quot;ID&quot;, &quot;縮圖&quot;, &quot;全路徑&quot;, &quot;資料夾(&quot; &amp; main_folder &amp; &quot;)&quot;, &quot;檔名&quot;, &quot;更改檔名&quot;).Range(&quot;D1&quot;) = &quot;資料夾(&quot; &amp; main_folder &amp; &quot;)&quot;Set rng_last = .Cells.SpecialCells(xlCellTypeLastCell)lr = .Cells(.Rows.Count, 1).End(xlUp).Rowlc = .Cells(1, .Columns.Count).End(xlToLeft).ColumnIf lr &gt; 1 Then .Range(&quot;A2&quot;).Resize(rng_last.Row, rng_last.Column).ClearFor Each Shape In .Shapes        &#x27;Debug.Print Shape.Address        If Shape.TopLeftCell.Row &lt;&gt; 1 Then Shape.DeleteNextEnd WithEnd Sub\r\n\r\n取得指定資料夾下所有照片路徑\r\n\r\nSub getAllFolder()Dim objFolder As ObjectSet objFolder = objFso.GetFolder(main_path)Call getAllFile(objFolder)End SubPrivate Sub getAllFile(ByVal objFolder As Object)If objFolder.Files.Count &lt;&gt; 0 Then    For Each objFile In objFolder.Files        s = objFso.GetExtensionName(objFile)            If IsPhoto(s) Then coll_photo_path.Add objFile.path            NextEnd IfIf objFolder.subFolders.Count &lt;&gt; 0 Then    For Each objSubFolder In objFolder.subFolders            Call getAllFile(objSubFolder)        NextEnd IfEnd Sub\r\n\r\n貼上照片到操作介面\r\n\r\nSub PastePictures()With shtResult        lr = .Cells(1, 1).End(xlDown).Row    lc = .Cells(1, 1).End(xlToRight).Column - 1        Set rng_last = .Cells(lr, lc)        &#x27;Set rng_last = .Cells.SpecialCells(xlCellTypeLastCell)        r = 2        For Each photo_path In coll_photo_path            If IsPaste = True Then                Set objTargetCell = .Cells(r, 2)                objTargetCell.ColumnWidth = photo_width            objTargetCell.RowHeight = photo_height                    Set pic = .Pictures.Insert(photo_path)            &#x27;Set pic = .Pictures.Insert(imagePath).ShapeRange.PictureFormat.Compression = 75            &#x27;Set pic = .Shapes.AddPicture(photo_path) &#x27;, True, True, objTargetCell.Left + 2, objTargetCell.Top + 2, objTargetCell.Width - 4, objTargetCell.Height - 4)            &#x27;pic.LockAspectRatio = msoFalse                    With pic                            dblGap = 2#                            .ShapeRange.LockAspectRatio = msoTrue &#x27;鎖定照片長寬比                                Set ranOri = objTargetCell                dblRatioPic = .Width / .Height                dblRatioOri = ranOri.Width / ranOri.Height                                If dblRatioPic &gt; dblRatioOri Then &#x27;寬度控制                    .Width = ranOri.Width - 2 * dblGap                    .Top = ranOri.Top + 0.5 * ranOri.Height - 0.5 * .Height                    .Left = ranOri.Left + dblGap                Else                                &#x27;高度控制                    .Height = ranOri.Height - 2 * dblGap                    .Top = ranOri.Top + dblGap                    .Left = ranOri.Left + 0.5 * ranOri.Width - 0.5 * .Width                                    End If                        End With                End If                        .Cells(r, 1) = r - 1        .Cells(r, 3) = photo_path        .Cells(r, 4) = getParentFolder(photo_path) &#x27;取得上層目錄        .Cells(r, 5) = getFileName(photo_path) &#x27;取得檔案名稱                .Cells(r, 1).Resize(1, rng_last.Column).Borders.LineStyle = 1        .Cells(r, 6).Resize(1, rng_last.Column).HorizontalAlignment = xlLeft                &#x27;Call getMarkDetail(.Cells(r, 5), r)                                r = r + 1        NextEnd WithEnd Sub&#x27;====取得上層目錄路徑=====Function getParentFolder(ByVal path As String)tmp_folder = Replace(path, main_path, &quot;&quot;)tmp = split(tmp_folder, &quot;\\&quot;)tmp_filename = tmp(UBound(tmp))getParentFolder = Replace(tmp_folder, tmp_filename, &quot;&quot;)End Function&#x27;====取得檔案名稱=====Function getFileName(ByVal path As String)tmp = split(path, &quot;\\&quot;)getFileName = tmp(UBound(tmp))End Function\r\n2-2 基本資料登錄\r\n\r\n\r\n操作介面表單化\r\n\r\n&#x27;InitializePrivate Sub UserForm_Initialize()With Sheets(&quot;Result&quot;)    lr = .Cells(.Rows.Count, 1).End(xlUp).Row    Me.Label2.Caption = &quot;共&quot; &amp; lr - 1 &amp; &quot;張&quot;        Me.Label3.Caption = .Cells(1, 7)    Me.Label4.Caption = .Cells(1, 8)    Me.Label5.Caption = .Cells(1, 9)    Me.Label6.Caption = .Cells(1, 10)    Me.Label7.Caption = .Cells(1, 11)        Me.TextBox1 = &quot;1&quot;        Me.ComboBox1.AddItem &quot;施工抽查&quot;    Me.ComboBox1.AddItem &quot;品質管制&quot;    Me.ComboBox1.AddItem &quot;缺失改善&quot;    Me.ComboBox1.AddItem &quot;施工中&quot;End WithEnd Sub&#x27;節錄照片內容Private Sub TextBox1_Change()Dim clsI As New clsInformation&#x27;If clsI.IsShowEditForm = False Then Exit SubOn Error Resume NextIf TextBox1.Value &lt;&gt; &quot;0&quot; Thens = Cells(TextBox1.Value + 1, 3)&#x27;On Error Resume NextImage1.Picture = LoadPicture(s)ImageTmp.TextBox2 = Cells(TextBox1.Value + 1, 7)ImageTmp.TextBox3 = Cells(TextBox1.Value + 1, 8)ImageTmp.TextBox4 = Cells(TextBox1.Value + 1, 9)ImageTmp.ComboBox1 = Cells(TextBox1.Value + 1, 10)&#x27;ImageTmp.TextBox5 = Cells(TextBox1.Value + 1, 10)ImageTmp.TextBox6 = Cells(TextBox1.Value + 1, 11)End IfEnd Sub\r\n第三章節 報表版型\r\n3-1 報表基本版型\r\nSub getReportShts()Dim coll As New CollectionFor Each sht In Sheets    If sht.Name Like &quot;*-*&quot; Then        coll.Add sht.Name        End IfNextFor Each it In coll    j = j + 1    p = p &amp; j &amp; &quot;.&quot; &amp; it &amp; vbNewLineNextAGAIN:mode = InputBox(&quot;請選擇列印版型:&quot; &amp; vbNewLine &amp; p)Sheets(coll(CInt(mode))).PrintPreviewmsg = MsgBox(&quot;這是您要的版型嗎?&quot;, vbYesNo)If msg = vbYes Then    Sheets(&quot;Main&quot;).Range(&quot;B4&quot;) = coll(CInt(mode))Else    GoTo AGAINEnd IfSheets(&quot;Main&quot;).ActivateEnd Sub\r\n3-2 報表客製版型⭐\r\n學習如何從既有版型調整標籤塊到指定位置並調整數量，批次代入工作表\r\n\r\n&lt;&gt; 引入照片\r\n&lt;&gt; 對應H欄\r\n&lt;&gt; 對應G欄\r\n&lt;&gt; 對應I欄\r\n\r\nSub checkReportFormat()    Dim coll As New Collection    &#x27; 遍歷報表中的所有儲存格    For Each rng In Sheets(getReportShtName).UsedRange        &#x27; 如果儲存格的值匹配 &quot;&lt;&lt;*&gt;&gt;&quot;        If rng.Value Like &quot;&lt;&lt;*&gt;&gt;&quot; Then            &#x27; 去掉 &lt;&lt; 和 &gt;&gt;            tmp = Replace(rng.Value, &quot;&lt;&lt;&quot;, &quot;&quot;)            tmp = Replace(tmp, &quot;&gt;&gt;&quot;, &quot;&quot;)            &#x27; 將結果加入到 coll 集合中            coll.Add tmp        End If    Next    Dim coll_unique As New Collection    &#x27; 檢查報表中每個標註項目的對應表頭名稱    For Each it In coll        &#x27; 將 coll 中的每個項目按 &quot;-&quot; 拆分，取得關鍵字 ky        s = Split(it, &quot;-&quot;)        ky = s(0)                &#x27; 在 &quot;Result&quot; 表的第一行查找這個關鍵字        Set rng = Sheets(&quot;Result&quot;).Rows(1).Find(ky)                &#x27; 如果找不到，且關鍵字不等於 &quot;照片&quot;，顯示錯誤訊息並選中報表中的對應位置        If rng Is Nothing And ky &lt;&gt; &quot;照片&quot; Then            Sheets(getReportShtName).Activate            MsgBox &quot;【&quot; &amp; it &amp; &quot;】:對應不到Result的表頭名稱&quot;            Set rng_focus = Sheets(getReportShtName).Cells.Find(&quot;&lt;&lt;&quot; &amp; it &amp; &quot;&gt;&gt;&quot;)            rng_focus.Select            End        End If                &#x27; 將唯一的編號 num 添加到 coll_unique 集合中        num = s(1)        On Error Resume Next        coll_unique.Add num, CStr(num)        On Error GoTo 0    Next    Dim coll_count As New Collection    &#x27; 計算每個唯一編號出現的次數    For Each it_unique In coll_unique        cnt = 0        For Each it In coll            s = Split(it, &quot;-&quot;)            num = s(1)            If num = it_unique Then                cnt = cnt + 1            End If        Next        &#x27; 將結果以 &quot;編號-次數&quot; 的格式添加到 coll_count 集合中        coll_count.Add it_unique &amp; &quot;-&quot; &amp; cnt    Next    &#x27; 檢查每個唯一編號的出現次數是否一致    For i = 1 To coll_count.Count - 1        s_cnt = Split(coll_count(i), &quot;-&quot;)(1)        e_cnt = Split(coll_count(i + 1), &quot;-&quot;)(1)        If s_cnt &lt;&gt; e_cnt Then            MsgBox &quot;報表位置註記項目，不同編號應具有相同數量!&quot; &amp; vbNewLine &amp; _            &quot;請檢核第&quot; &amp; Split(coll_count(i), &quot;-&quot;)(0) &amp; &quot;次與第&quot; &amp; Split(coll_count(i + 1), &quot;-&quot;)(0) &amp; &quot;次!&quot;, vbCritical            End        End If    NextEnd Sub\r\n3-3 文字細節調整\r\n\r\n日期是否出現於右下角的浮水印文字塊，調整其文字顏色及網底顏色\r\n\r\nSub AddText(ByVal txtX, ByVal txtY, ByVal txtHeight, ByVal txtWidth, ByVal txtStr, Optional ByVal RGB_Selector As Integer = 0)Dim o As New clsInformationDim r As LongDim g As LongDim b As LongDim r2 As LongDim g2 As LongDim b2 As LongIf o.IsPrintDate = False Then Exit SubRGB_Interior = o.getInteriorColorCall o.VBLongToRGB(RGB_Interior, r, g, b)RGB_Font = o.getFontColorCall o.VBLongToRGB(RGB_Font, r2, g2, b2)With ThisWorkbook.Sheets(report_shtname)    .Activate    ActiveSheet.Shapes.AddTextbox(msoTextOrientationHorizontal, txtX, txtY, txtHeight * Len(txtStr) * 0.33, txtHeight).Select    Selection.ShapeRange(1).TextFrame2.TextRange.Characters.text = txtStr            Selection.ShapeRange.Fill.Visible = msoFalse    Selection.ShapeRange.Line.Visible = msoFalse    Selection.ShapeRange.ZOrder msoBringToFront        With Selection.ShapeRange(1).TextFrame2.TextRange.Characters.Font        .Bold = msoTrue        .Fill.ForeColor.RGB = RGB(r2, g2, b2)        .Size = txtHeight * 0.5            End With        If o.IsPrintDateBack = True Then            With Selection.ShapeRange(1).Fill            .Visible = msoTrue            .ForeColor.RGB = RGB(r, g, b)        End With    End IfEnd WithEnd Sub\r\n第四章節 報表輸出\r\n4-1 報表輸出方法 ⭐\r\n\r\n建立列印群組，根據版型決定每幾張要換頁，由工作表未隱藏的列決定列印順序，未來亦可建立自己的列印規則，將備註欄的資料篩選併入作為列印的觸發擴充項目(比如設定改善編號、頁次來將工作表的順序進行重新調整)。\r\n\r\nSub getPrintGroups()Call checkDateFormatCall checkReportFormatDim f As New clsMyfunctionDim coll_rows_final As New Collection    Set coll_rows = getRowsUnHidden        folder_name = Format(Now(), &quot;YYYYMMDD-HHMMSS &quot;)        For Each r In coll_rows            With Sheets(&quot;Result&quot;)                If .Cells(r, .Columns.Count).End(xlToLeft).Column &gt; 5 Then                    coll_rows_final.Add r                        End If            End With        Next        If coll_rows_final.Count &gt; 0 Then Call printFilesByRows(coll_rows_final, True, folder_name)        Set coll_rows_final = NothingSheets(&quot;Main&quot;).ActivateWorkbooks(Workbooks.Count).ActivateEnd Sub\r\n\r\n列印相關代碼，包含列印成PDF跟列印成XLS\r\n\r\nSub printFilesByRows(ByVal coll_rows, ByVal IsXLS As Boolean, ByVal folder_name As String)Dim o As New clsReportDim f As New clsMyfunctionDim coll_recover As New Collectionreport_shtname = Sheets(&quot;Main&quot;).Range(&quot;B4&quot;)Set coll_key = getKeyWords &#x27;第G欄開始Set wb = Workbooks.AddThisWorkbook.ActivateFor Each r In coll_rowsKeepPrint:    i = i + 1        For Each s In coll_key                myKey = split(s, &quot;,&quot;)(0)        col = split(s, &quot;,&quot;)(1)            myAddress = getAddressByKeyWord(myKey, CStr(i))        &#x27;        If i = 4 Then Stop            If myAddress &lt;&gt; &quot;&quot; Then                        If myKey = &quot;照片&quot; Then                            file_name = file_name &amp; r &amp; &quot;-&quot;                &#x27;paste photo                Call o.PastePhoto_giveRng(Sheets(getReportShtName).Range(myAddress), Sheets(&quot;Result&quot;).Cells(r, &quot;C&quot;), Sheets(&quot;Result&quot;).Cells(r, CInt(col)))                        ElseIf myKey = &quot;日期&quot; Then                                Sheets(getReportShtName).Range(myAddress) = f.tranStrToDate(Sheets(&quot;Result&quot;).Cells(r, CInt(col)))                        Else                            Sheets(getReportShtName).Range(myAddress) = Sheets(&quot;Result&quot;).Cells(r, CInt(col))                        End If                        coll_recover.Add &quot;&lt;&lt;&quot; &amp; myKey &amp; &quot;-&quot; &amp; CStr(i) &amp; &quot;&gt;&gt;;&quot; &amp; myAddress            IsPrinted = False                    Else                        IsPrinted = True            If IsXLS = False Then                Call printReportPDF(file_name)            Else                Call printReportToWb(wb, file_name)            End If                        Call clearReport(coll_recover)            file_name = &quot;&quot;            i = 0            GoTo KeepPrint                    End If            NextNextIf IsPrinted = False Then    If IsXLS = False Then        Call printReportPDF(file_name)    Else        Call printReportToWb(wb, file_name)    End If        Call clearReport(coll_recover)    End IfIf IsXLS = True Then Call printReportToWb_Save(wb, folder_name)End Sub\r\n4-2 照片歸檔\r\n\r\n將工作表上手動紀錄的資料內容依照指定方式批次針對照片原始檔案進行檔名更改，未來引入時會先判定檔名內容引入工作表相對應資料。\r\n\r\nSub ChangeAllFileName()If Sheets(&quot;Result&quot;).AutoFilterMode Then    Sheets(&quot;Result&quot;).AutoFilterMode = FalseEnd IfCall getCombineNamesDim objFile As New clsmyFileWith Sheets(&quot;Main&quot;)    objFile.main_path = .Range(&quot;B2&quot;)    objFile.changeFileNameEnd WithCall getDataFromFolder &#x27;reloadingEnd SubSub getCombineNames()Dim clsInf As New clsInformationSet coll = clsInf.getCollStructure(clsInf.getReNameStruc)With Sheets(&quot;Result&quot;)    lr = .Cells(.Rows.Count, 1).End(xlUp).Row        For r = 2 To lr            If .Cells(r, .Columns.Count).End(xlToLeft).Column &gt; 5 Then                    p = &quot;&quot;                    For Each col In coll                            p = p &amp; .Cells(r, col) &amp; &quot;_&quot;                        Next                        .Cells(r, &quot;F&quot;) = mid(p, 1, Len(p) - 1)                End If        NextEnd WithEnd Sub\r\n\r\n改名部分\r\n\r\nSub changeFileName()With shtResult    lr = .Cells(.Rows.Count, 1).End(xlUp).Row        For r = 2 To lr            oldname = .Cells(r, 3)                If .Cells(r, 6) Like &quot;*.jp*&quot; Then            newname = main_path &amp; .Cells(r, 4) &amp; .Cells(r, 6)        Else            newname = main_path &amp; .Cells(r, 4) &amp; .Cells(r, 6) &amp; &quot;.jpg&quot;        End If            If .Cells(r, 6) &lt;&gt; &quot;&quot; Then                        Debug.Print &quot;old:&quot; &amp; oldname            Debug.Print &quot;new:&quot; &amp; newname                        Name oldname As newname                    End If    NextEnd WithEnd Sub\r\n\r\nQA\r\n目前有網友表示，輸出的報表照片會變形，經查為以下該段程式碼的原因，可以將這段程式碼蓋掉本來的內容就好。\r\n&#x27;位置:物件類別模組/clsReport/PastePhoto_giveRngSub PastePhoto_giveRng(ByVal rng As Object, ByVal photo_path As String, ByVal checkday As String)&#x27;額外接入checkday當作text基底文字With shtReport    &#x27;Set rng = .Range(coll_rng_address(Count))    If rng.MergeCells Then            myMergeArea = rng.MergeArea        dy = UBound(myMergeArea, 1)        dx = UBound(myMergeArea, 2)        End If        Set LastRng = .Cells(rng.Row + dy - 1, rng.Column + dx - 1).Offset(1, 1)        X0 = rng.Left    Y0 = rng.Top        X1 = LastRng.Left    Y1 = LastRng.Top    targetWidth = X1 - X0 - 4    targetHeight = Y1 - Y0 - 4      &#x27; 加入圖片，先放大一點    Set pic = .Shapes.AddPicture(photo_path, True, True, X0 + 2, Y0 + 2, -1, -1)                                         &#x27; 鎖定比例不變    pic.LockAspectRatio = msoTrue        &#x27; 根據原始比例決定是縮放寬還是高    If (pic.Width / pic.Height) &gt; (targetWidth / targetHeight) Then        &#x27; 圖片比較寬，以寬度為主        pic.Width = targetWidth    Else        &#x27; 圖片比較高，以高度為主        pic.Height = targetHeight    End If        &#x27; 根據調整後寬度重新置中 (optional)    pic.Left = X0 + ((X1 - X0) - pic.Width) / 2        Call AddText(X1 - 100, Y1 - 30, 25, 40, tranDate(checkday), 3) &#x27;額外接入之checkday要顯示於照片右下角    End WithEnd Sub\r\n","categories":["專案開發"],"tags":["Excel VBA","施工照片"]},{"title":"施工照片VBA-常見問題","url":"/posts/823675137/","content":"資料夾照片順序與檔案順序不一致\r\n\r\n從LINE相簿下載的照片名稱雖然上面有順序，但是匯入施工照片VBA之後卻不會按照原本的順序進行排列?\r\n\r\n\r\n\r\nFig1.\r\n原本的順序是(1).(2).(3)...(10)...(100)...\r\n\r\n\r\n\r\nFig2.\r\n當引入之後會變成(1).(10).(100)...\r\n\r\n發生原因\r\n對於數字而言，1.2.3...10.11...100.101...這樣排序會正常運作，但是在excel中，名稱所有的數字都會變成文字來處理，所以1的後面是10，再來是100\r\n解決方案\r\n把原本是數字的部分通通變成3碼，001.002.003.....010.011.....100，他就會照這樣排序上去了。\r\n可想而知，如果各位要這樣一筆一筆手動修改也是很累人的一件事，所以此時就可以寫個VBA工具將檔案名稱做關鍵字拆分，取出最後的編號部分，用格式化選項作成三碼的數字，重新併回去產製新的照片名稱。\r\n一般來說，LINE是存放檔案的最大宗，從相簿下載回電腦的名稱為LINE_ALBUN_相簿名稱_相簿日期_流水號.jpg，此時就能透過這個方式先將流水號拆出來，再將流水號修改為固定三位數的流水號。\r\nSub renameFiles()    Dim main_path As String    Dim fileName As String    Dim newFileName As String    Dim pos As Long    Dim posDot As Long    Dim numPart As String    Dim ext As String        &#x27; 取得資料夾路徑    main_path = Sheets(&quot;Main&quot;).Range(&quot;B2&quot;).Value        If Right(main_path, 1) &lt;&gt; &quot;\\&quot; Then        main_path = main_path &amp; &quot;\\&quot;    End If        fileName = Dir(main_path &amp; &quot;*.*&quot;)        Do While fileName &lt;&gt; &quot;&quot;        pos = InStrRev(fileName, &quot;_&quot;)      &#x27; 找到最後一個 &quot;_&quot;        posDot = InStrRev(fileName, &quot;.&quot;)   &#x27; 找到最後一個 &quot;.&quot;                If pos &gt; 0 And posDot &gt; pos Then            numPart = mid(fileName, pos + 1, posDot - pos - 1)                        If IsNumeric(numPart) Then                numPart = Format(CLng(numPart), &quot;000&quot;)                                newFileName = Left(fileName, pos) &amp; numPart &amp; mid(fileName, posDot)                Name main_path &amp; fileName As main_path &amp; newFileName                                Debug.Print &quot;Rename: &quot; &amp; fileName &amp; &quot; -&gt; &quot; &amp; newFileName            End If        End If                fileName = Dir    Loop        MsgBox &quot;重新編號完成!&quot;, vbInformationEnd Sub\r\n\r\n\r\n相關連結\r\n施工照片VBA-實作流程\r\n","categories":["基本原理"],"tags":["Excel VBA","施工照片"]},{"title":"明渠水理計算","url":"/posts/3021870975/","content":"🙌前言\r\n明渠輸水渠道的設計重點大概羅列如下幾點:\r\n\r\n排水渠道要注意流量是否可以提供農田排水10年重現期距1日排出。\r\n灌溉渠道要確認灌溉計畫所需計畫流量。\r\n設計的最小容許流速不能低於水草生長速度或淤沙速度。\r\n設計的最大容許流速不能高於規範所限制的速度。\r\n設計時需注意不能太接近臨界流況，動水壓力對構造物較容易不穩定。\r\n挑選合宜的出水高度提高其他因素所致之額外流量。\r\n檢討各田區所需灌溉水頭是否足夠，盡量減少制水汴版的使用。\r\n\r\n有關農田排水的流量可以參考農田排水工程規劃設計原則參考手冊(108版)進行推算\r\n\r\n演算流程可以利用Python中的Streamlit套件進行，從參數設定&gt;檢核流程&gt;報表產製都交給電腦\r\n\r\n\r\n主要操作畫面\r\n\r\n\r\n圖1.Streamlit 操作介面\r\n\r\n計算依據\r\n\r\n中國農業工程手冊-農業水利之部(下稱農工手冊)\r\n農田水利會技術人員訓練教材灌溉排水工程類合訂本(下稱合訂本)\r\n\r\n\r\n基本參數\r\n\r\n\r\n\r\n名詞\r\n代號\r\n數值\r\n單位\r\n\r\n\r\n\r\n\r\n計畫流量\r\nq\r\n{q}\r\ncms\r\n\r\n\r\n曼寧係數\r\nn\r\n{n}\r\n\r\n\r\n\r\n渠寬\r\nb\r\n{B}\r\nm\r\n\r\n\r\n填角\r\nF\r\n{F}\r\nm\r\n\r\n\r\n坡度\r\ns\r\n1/{s}\r\n\r\n\r\n\r\n\r\n\r\n計算過程\r\n相關計算公式如下:\r\n\\[ P = (b - 2 \\cdot F) + 2\r\n\\sqrt2 \\cdot F + 2 \\cdot (y - F) \\]\r\n\\[ A = b \\cdot y -  F ^2 \\]\r\n\\[ R = \\frac{A}{P} \\]\r\n\\[ V = \\frac{1}{n} \\cdot R^\\frac{2}{3}\r\n\\cdot s ^ \\frac{1}{2} \\]\r\n\\[ Q = A \\cdot V \\]\r\n\\[ Fr^2 = \\frac{Q^2T}{gA^3} \\]\r\n\r\n\r\n\r\n名詞\r\n代號\r\n\r\n\r\n\r\n\r\n潤周\r\nP\r\n\r\n\r\n通水面積\r\nA\r\n\r\n\r\n水力半徑\r\nR\r\n\r\n\r\n流速\r\nV\r\n\r\n\r\n流量\r\nQ\r\n\r\n\r\n\r\n\r\n計算結果\r\n檢算等速流況\r\n\r\n設計流量Q需大於計畫流量q\r\n\r\n經試誤法後得到\r\n\r\n\r\n\r\n名詞\r\n代號\r\n數值\r\n單位\r\n\r\n\r\n\r\n\r\n水深\r\ny\r\n{y}\r\nm\r\n\r\n\r\n設計流量\r\nQ\r\n{Q}\r\ncms\r\n\r\n\r\n流速\r\nV\r\n{V}\r\nm/s\r\n\r\n\r\n福祿數\r\nFr\r\n{Fr}\r\n\r\n\r\n\r\n\r\n\r\n檢算臨界流況\r\n\r\n設定條件為 Fr=1\r\n\r\n經試誤法後得到\r\n\r\n\r\n\r\n名詞\r\n代號\r\n數值\r\n單位\r\n\r\n\r\n\r\n\r\n臨界水深\r\nyc\r\n{yc}\r\nm\r\n\r\n\r\n臨界流速\r\nVc\r\n{Vc}\r\nm/s\r\n\r\n\r\n\r\n\r\n水理特性檢討\r\n最小容許流速\r\n\r\n水草生長速度 0.7 m/s\r\n泥沙淤積速度\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n最小容許流速(m/s)\r\n0.19\r\n0.30\r\n0.38\r\n0.45\r\n0.56\r\n0.65\r\n0.69\r\n0.70\r\n0.77\r\n0.82\r\n\r\n\r\n\r\n\r\n水深\r\n0.3\r\n0.6\r\n0.9\r\n1.2\r\n1.5\r\n1.8\r\n2.1\r\n2.4\r\n2.7\r\n3.0\r\n\r\n\r\n\r\n最大容許流速\r\n\r\n農工手冊建議\r\n\r\n\r\n\r\n\r\n材質\r\n最大容許流速(m/s)\r\n\r\n\r\n\r\n\r\n厚混凝土(&gt;18cm)\r\n3.00\r\n\r\n\r\n薄混凝土(&lt;10cm)\r\n1.50\r\n\r\n\r\n\r\n\r\n排水路、退水路、側溢道 可以乘1.5倍進行分析\r\n\r\n\r\n合訂本建議\r\n\r\n\r\n\r\n\r\n材質\r\n最大容許流速(m/s)\r\n\r\n\r\n\r\n\r\n混凝土\r\n4.00\r\n\r\n\r\n\r\n\r\n考量動水壓力\r\n應避免接近臨界流速(水面易起激盪)\r\n農工手冊建議:\r\n\\[ V_\\text &lt;\r\n\\frac23 V_c \\]\r\n合訂本計算例(P.450)建議:\r\n\\[ V_\\text &lt; 0.8\r\n\\cdot V_c \\]\r\n\r\n出水高度檢核\r\n為考量以下情況予以調整\r\n\r\n渠道糙率係數之變動\r\n流速水頭變換為靜水頭水面之上升\r\n對水面波動等所需增加之高度\r\n\r\n合訂本建議:\r\n\r\n計畫最高水深之1/3(但不能少於15cm)\r\n重要渠道可增至最大水深之1/2\r\n彎曲處需考量水面超高\r\n\\[ F_b = \\frac{B \\cdot V^2}{g \\cdot r}\r\n\\]\r\n\r\nB=水面寬度(m)\r\nr=彎曲半徑(m)\r\ng=9.81\r\n\r\n\r\n農工手冊建議:\r\n\r\n純挖渠道或內面工渠道\r\nFb=0.05d+hv+(0.05~0.15)\r\n座槽或渡槽\r\nFb=0.07d+hv+(0.05~0.15)\r\n有洪水流入時 最小Fb=0.1\r\n暗渠及隧道 A,B取大值 (A)按計畫流量估算\r\nd/D=0.80~0.83(但至少為0.30m)\r\n(B)有洪水流入時 d/D=0.90~0.93\r\n\r\nd=水深=y\r\nD=暗渠高度或隧道直徑\r\n\r\n\r\n\r\n","categories":["基本概念"],"tags":["Python","Streamlit","明渠計算"]},{"title":"監造報表-數量計算-引用來源","url":"/posts/3212778286/","content":"🙌前言\r\n工程價格資料庫作業辦法有明定，新台幣1000萬元以上之公共工程於決標日起30日內必須將資料傳輸到主管機關，資料內容:\r\n\r\n得標廠商之契約單價\r\n經機關核定之預算單價\r\n其他經主管機關指定者\r\n\r\n包含詳細價目表、單價分析表及資源統計表。\r\n最容易達成的方式便是透過公共工程經費電腦估價系統(PCCES)進行預算書與契約編制。\r\n因為大家都使用同一套系統，那麼輸出格式就能夠通用，後續要將契約內容彙整到公司內部所開發的報表系統只需要做一次工就可以了，然而非公共工程的內容會就因為個案不同而需要做細微調整。\r\n\r\n📔預算書範例\r\n一般在公共工程設計階段，需要製作以下表格\r\n\r\n預算總表\r\n預算詳細表\r\n預算單價分析表\r\n預算資源統計表(一定規模才要)\r\n\r\n承攬廠商得標後，契約項目、數量、單位基本上會按照設計階段內容，僅單價部分會依照標比進行調整。\r\n\r\n成立契約後所得到的內容便是後續辦理數量填寫、變更設計、估驗計價等程序的依據。\r\n\r\n公共工程\r\n大多都是採用公共工程經費電腦估價系統(PCCES)進行，以編碼正確率40%為推動目標並加以列管，若是用前人留下來的Excel進行模仿，通常都比較會難以達成最低編碼正確率的要求，建議還是學習PCCES如何使用比較好。\r\n在將項目移轉至內部報表的過程，會遇到欄位名稱比較長的出現跳列的情況，此時要將項目搬移至內部報表系統時會需要做先行處理，否則會有項目名稱不完整的狀況，而這通常會在日後會出現一些問題，先行處理雖然麻煩但還是不可免。\r\n\r\n\r\nFig2.契約項目跳列\r\n\r\n非公共工程\r\n非公共工程雖然未強制要求編碼正確率，因此所輸出的預算書格式比較會千奇百怪，但通常也是不脫離公共工程的基本概念，有關契約總表、契約詳細表、契約單價分析表通常都會出現。\r\n在將項目移轉至內部報表的過程，當然也可以用手動的方式把資料PASS到內部報表系統上面，但若像是建築工程有幾百幾千項的，建議透過VBA進行處理會比較理想，只要是Excel應該都有機會找出編製的脈絡進行程式撰寫，這就需要看個案而定，找出契約上的規律，透過迴圈、判別式一一找出脈絡並進行項目萃取。\r\n契約項目\r\n在監造報表上要執行數量計算時，為控制報表長度，通常會以契約詳細表中的內容為主，其中會有以下幾種型態\r\n\r\n可量化型態\r\n\r\n鋼筋(Unit=T)、模板(Unit=m2)、混凝土(Unit=m3)...等具備明確單位、可被量化且編列於詳細表上的內容\r\n\r\n一式型態\r\n\r\n因特定工程項目之價格或數量編列不易，無法以明確單位加以計量，難以估計的內容會以概估的方式給定一式的費用，例如擋抽排水費\r\n\r\n百分比型態\r\n\r\n環境保護費、職業安全衛生費、品管作業費、廠商管理費、營業稅...等，依據預算編列內容後經換算比例而得到的費用。\r\n匯入內容\r\nXML\r\nPCCES可以輸出XML或XLS\r\nXML是一種半結構化資料，以&lt;...&gt;開始、&lt;/...&gt;結束，中間所夾的內容有屬性(attribute)跟文字(text)，屬性為一健值對，可針對屬性值進行操作，也可針對文字進行使用。\r\n\r\n節錄自PCCES產出的XML檔案\r\n\r\n&lt;PayItem itemKey=&quot;7&quot; itemNo=&quot;一&quot; refItemCode=&quot;       &quot; itemKind=&quot;mainItem&quot;&gt;        &lt;Description language=&quot;zh-TW&quot;&gt;主體工程&lt;/Description&gt;        &lt;Description language=&quot;en&quot;&gt;&lt;/Description&gt;        &lt;Unit language=&quot;zh-TW&quot;&gt;          &lt;/Unit&gt;        &lt;Unit language=&quot;en&quot;&gt;          &lt;/Unit&gt;        &lt;Quantity&gt;1&lt;/Quantity&gt;        &lt;Price fixed=&quot;false&quot; calculateDecimal=&quot;0&quot;&gt;11824021&lt;/Price&gt;        &lt;Amount fixed=&quot;true&quot; calculateDecimal=&quot;0&quot;&gt;11824021&lt;/Amount&gt;        &lt;Remark&gt;[發包]&lt;/Remark&gt;        &lt;Percent&gt;0&lt;/Percent&gt;        &lt;PayItem itemKey=&quot;15&quot; itemNo=&quot;1&quot; refItemCode=&quot;02300C00\r\nXLS\r\nXLS就是指Excel的活頁簿，大家應該很常見，不多做解釋。\r\nPCCES契約項目後處理\r\n跟眾多網友交流下來，發現最多人在使用監造報表VBA或施工日誌VBA時都是卡在契約項目的建立，當契約項目無法正常建立時，確實對於整個報表就會是一大阻礙，因此我針對公共工程的預算書有做了一個後處理的轉換工具(XML到XLS)，之後再將轉換所得的資料貼到自訂的VBA工具即可正常使用。\r\n詳情請參考 ExcelVBA@PCCES契約項目後處理工具\r\n","categories":["專案開發"],"tags":["Excel VBA","監造報表"]},{"title":"Streamlit打造工程估算系統","url":"/posts/2910899188/","content":"前言\r\n\r\n工程估算為提報計畫前的必要內容，所提報的概估經費關乎於計畫核定後是否會造成實際所需經費是否足夠、執行率會不會有問題。\r\n\r\n工程估算方法有兩種:材料及類別\r\n\r\n材料是將單元拆分為鋼筋、模板、混凝土...等等可以從標準斷面計算而得的內容。\r\n類別是將工程拆分為渠道工程、道路工程、橋梁工程...等可以明確分類的內容。\r\n\r\n本篇文章希望能夠藉由雲端介面的操作來達成以下幾點需求\r\n\r\n工程估算方法將以往的材料導向為類別。\r\n各類別單元內容計算由程式接手，減少人力調配參數。\r\n輸出報表採用最新版本號，避免各地版本不一造成困擾。\r\n手機也能在工區現場獲得經費估算成果。\r\n\r\n\r\n工程估算方法\r\n工程估算方法不同是目前在處理計畫提報時常常造成提報經費與實際經費有落差的主因，經查發現原來是大多數人都用材料作為品項而非用工程類別作為品項，導致在估算過程容易忽略道路鋪面、擋土設施這類內容。\r\n估太少\r\n設計過程會需要東扣西扣，為了主體工程能夠收尾必須要捨棄掉某些也是很重要的項目。\r\n估太多\r\n會被檢討為什麼當初黑白估造成執行率不高，很多人都是因為被刁難過經費不能超過上限，所以就給他用力估下去，造成這樣的結果。\r\n類別計算內容\r\n渠道工程、版橋工程\r\n\r\n給定渠道長寬及長度，回推牆厚及所需鋼筋\r\n給定版橋長寬及座數，回推版厚及所需鋼筋\r\n\r\n擋土牆\r\n\r\n懸臂式擋土牆\r\n重力式擋土牆\r\n\r\n道路工程、版樁工程\r\n分為AC、再生AC、碎石級配、CLSM的各種排列組合，透過新增的方式來逐行增加，也可以進行刪除。\r\n雜項及其他\r\n將前述內容加總後乘上雜項費用係數(預設為0.1)\r\n間接費用\r\n為前幾項的加總後乘上間接費用係數(預設為0.3)，這部分包含職安、環保、廠商利潤、工程管理費等\r\n輸出報表\r\n工作時如有需要輸出報表的時候，不外乎會採用word或者excel之類的工具，當版本有更新的時候會需要請同事重新下載使用，並在報表的某處壓一個版本號作為辨識，然而往往頒布適用的時候，還是會有不少同事以舊的版本提送報表。\r\n為解決上述版本差異問題，這次選擇利用雲端網頁作為可及時更新的報表輸出媒介，一旦計算規則改變或報表格式變化就能夠在同事輸入完基本資料之後，確保輸出的內容會是正確版的。\r\n實作成果\r\n\r\n\r\n系統操作流程\r\n\r\n\r\n\r\n\r\n工程基本資料\r\n\r\n\r\n\r\n\r\n工程施作位置\r\n\r\n\r\n\r\n\r\n工程內容概要\r\n\r\n","categories":["專案成果"],"tags":["Streamlit"]},{"title":"監造報表規劃-數量計算","url":"/posts/1952534825/","content":"🙌前言\r\n契約項目、單價、數量、單位是整個工程進行中的數量計算核心。\r\n契約項目的起源於設計階段會成立預算書便開始，招標階段會以標單的形式讓廠商進行填列投標，決標時再以標比調整契約單價，爾後成立契約後便以此當計價依據。\r\n工程進行要做到完全不變更設計實在相當困難，因為現場條件改變、居民特殊需求、甚至編制預算書的錯誤未被發現都可能導致變更設計的發生，此時變更設計需求項目沒有列於契約項目，則會伴隨新增項目新增單價程序同步進行。\r\n工程執行一定比例後，廠商可提出估驗計價，此時也是以當期契約項目、單價、實際數量作為付款依據，配合累積進度相互勾稽，避免超估發生。\r\n\r\n📔引用來源\r\n公共工程所使用的PCCES可以生成XML或XLS，可以透過VBA的方式匯入成監造報表的契約項目，在引入過程中，對於監造報表中的契約項目欄位規劃，需要特別注意結構性與擴充性才會方便作業。\r\n契約項目欄位規劃\r\n\r\n結構性\r\n\r\n在資料庫的設計上有所謂正規化的概念，儲存格以每格存放一個資料為原則，避免跨格合併的方式進行資料存放，通常資料庫只紀錄文字內容而已，圖片或檔案則紀錄外部連結路徑替代。\r\n\r\n擴充性\r\n\r\n工作表則是以不同類別做拆分，例如:契約項目、施作數量、試驗統計、基本資料放於不同工作表，各工作表由上而下發展，以第一列為表頭進行記錄。(如果要放置按鈕則另當別論)\r\n\r\n\r\nFig1.預算詳細表範例\r\n\r\n🚸進度依據\r\n工地現場會有當日施作項目，施工廠商會另製作一份施工日誌及自主檢查表，達抽查頻率時會提出檢驗停留點申請單會同監造前往抽查，並將已抽查完成的數量填報上去監造日報作為施作數量，此時的數量則為換算實際進度的依據。\r\n當初在預算書階段時以比例計算之項目則歸類為百分比項目(職業安全、環境保護、品管作業費、廠商利潤、營業稅)，會依照當初在換算比例時的契約項目之實作數量占契約數量之金額比例填寫。\r\n\r\nEX:環境保護費用會依(主體工程+雜項工程)之實作金額/(主體工程+雜項工程)之契約金額填列\r\n\r\n\r\n\r\nFig2.百分比項目範例\r\n\r\n✂️變更設計\r\n當工程需要改動契約項目或提供新的契約項目時，會辦理變更設計或新增項目新增單價，提報概估表及變更設計預算書來完成變更設計流程，如有新增契約項目時則須先行辦理新增項目新單價。\r\n若預算書階段有先敘明，實作數量計價則會在工程完工前辦理一次修正預算，依照契約項目填列實作數量等候竣工結算，若已經有發生變更設計，則後續皆已變更設計程序進行，不再以修正預算程序辦理。\r\n同時會需要依照變更前後的數量差異、金額差異另製成變更設計總表、變更設計明細表，這些報表內容都是與契約項目、單價有很高的關聯性。\r\n\r\n\r\nFig3.變更設計介面\r\n\r\n💰估驗計價\r\n工程執行一定比例後，廠商可以提出估驗計價來支付工程款，監造此時需要對照契約項目、數量、單價，估驗數量不得超過日報施作數量，並且累積估驗進度亦不得超過累積實際進度。\r\n需要依照該期別的工程估驗內容另製成工程估驗總表、工程估驗詳細表，這些報表內容也都是與契約項目、單價有很高的關聯性。\r\n\r\n\r\nFig4.估驗計價介面\r\n\r\n🐞開發中遇過的小問題\r\n\r\n引入項目時引到重覆項目\r\n實際進度的計算分母需將廠商利潤、營業稅進行排除\r\n變更設計未將試驗數量同步變更\r\n變更設計後進度不升反降\r\n估驗計價的以前估驗價值因為變更設計而更動\r\n\r\n","categories":["專案開發"],"tags":["Excel VBA","監造報表"]},{"title":"監造報表-數量計算-數量填寫","url":"/posts/2699779571/","content":"🙌前言\r\n監造報表的數量填寫為施工紀錄時最重要的基本功，填寫方式可分為以儲存格填寫、使用者表單填寫，如果掌管工地現場的工地主任對資訊比較不了解的，也很有可能會將內容寫在紙本或白板上拍照上傳群組回報，再由內業工程人員進行資料登打，無論哪種方式，填寫內容都還是以契約項目為依據，只在數量部分做琢磨而已。\r\n契約項目以可量化型態、一式型態、百分比型態為主，這部分請參考前文，不再另外闡述，本篇內容主要介紹填寫時透過單元的概念進行組合項目的過程，當內容以單元進行時，除了工地主任的回報會比較明確，同時也可以針對單元的進行輔以相對的檢核機制與防呆機制，會省下很多麻煩。\r\n\r\n✒️填寫方式\r\n儲存格填寫\r\n儲存格可能是文字、數字、日期...等，除非有先修改儲存格格式，否則他會根據當下的狀況自動判斷要以哪種方式存在，這通常會造成一些奇怪的問題，例如原本輸入日期2023/2/5顯示卻變成44962，還有輸入手機號碼的時候，最前面的0會被去掉，此時就需要將數字變成字串(在手機號碼最前面打上')才能正確顯示。\r\n即便可以將儲存格的格式問題排除，建議複雜資料還是不要讓使用者直接用儲存格進行填寫，你永遠不知道使用者他們會怎麼亂給資料，後續的資料再利用會有很多限制。\r\n使用者表單填寫\r\n使用者表單為VBA所提供的介面，透過拖曳的方式將控制項放入表單畫面，並且針對各控制項的事件進行邏輯判斷與後續處理，需要一點VBA的基本功才有辦法掌握，以下介紹用的到的控制項、事件名稱、用途說明，關於使用者表單的教學再另開一篇專文說明。\r\n\r\n\r\n\r\n控制項目\r\n用途說明\r\n\r\n\r\n\r\n\r\nLable\r\n顯示內容\r\n\r\n\r\nTextBox\r\n提供使用者填寫內容\r\n\r\n\r\nComboBox\r\n提供既有內容讓使用者選擇\r\n\r\n\r\nCheckBox\r\n註記功能是否進行\r\n\r\n\r\nCommandButton\r\n執行功能\r\n\r\n\r\n\r\n好處是可以有效控制使用者填寫內容的正確性，後續資料再利用時比較不會有困擾，盡可能在收集複雜資料的過程都採用這種方式，簡單資料還是可以透過直接填寫儲存格完成沒有關係。\r\n\r\n\r\nFig1. 填寫施作資料介面\r\n\r\n紙本填寫\r\n當工程資料大多都以紙本進行時，如果要進行統計分析時會消耗很多人力，這也是為什麼EXCEL這類的試算表會被發展出來的原因，也因此紙本資料轉換對於資料電腦化會是一件很痛苦的事情，每次的資料搬遷都可能會有資料丟失跟資料誤繕的可能，但營建產業這樣的情況可說是很常見。\r\n對於不太會使用電腦的工地人員而言，人人有一隻有網路的手機，也是滿合情合理的，只要有網路就可以將手機作為表單的填寫媒介先送到雲端上面，再由內業人員將資料彙整出來，字太小可以用平板電腦克服，甚至用響應式網站的方式進行調整，資料能夠減少一次搬遷對於後續都會是一件好事。\r\n\r\n\r\nFig2. Google表單+Sheets\r\n\r\n📔契約項目\r\n一般項目\r\n透過直接採用契約項目之可量化型態、一式型態進行填寫，百分比型態則後續報表產製時根據比例進行換算。\r\n監造報表-數量計算-引用來源\r\n組合項目\r\n在進行經費估算時，數量計算表的產製為降低錯誤，通常會給圖說上出現的組合構件進行編號，對於帶狀工程則會有每進行米的概念，因為不管在哪個樁號其實都長得差不多，只要算出每進行米有多少材料，計算時乘上總長度即可得到答案。\r\n\r\n單元構件\r\n\r\n建築工程常見的構件是柱梁板牆，橋梁工程常見的構件是墩柱、節塊，單元可以自行定義，主要是為了方便撿料及工班說明而已。\r\n\r\n每進行米\r\n\r\n灌溉排水工程會以矩型溝作為每進行米的撿料標準，道路工程則會以鋪面剖面或擋土構造物(重力式擋土牆、懸臂式擋土牆...等)為每進行米的撿料標準，整體會考慮漸變段，採用平均值計算，工程細節如要再進行拆分，則又會分成襯底、渠底、鋼筋組立、左右牆身...等進行每進行米的填寫依據。\r\n☑️檢核機制\r\n將圖面內容轉為單元去進行分析，最大的好處就是可以進行單元統計了解與數量計算表之間的差異、透過計算樁號區段繪製條狀圖理解目前施工工序及預測下階段施作樁號、達成樁號重覆填寫的防呆，更重要的是藉由工項更正可以批次調整已經紀錄的內容，即時修正單元的數量計算。\r\n單元統計\r\n當發生單元填寫完畢卻與契約數量不符時，可以使用單元統計，先將所有單元名稱材料進行總計，確認契約數量與單元統計總計所得之總數量是否相符，如果不相符則是當初在切分單元的時候就已經存在錯誤。\r\n確定是切分單元的時候的錯誤後，可以根據不同單元名稱作為分類，將該合計內容總數量與數量計算表的相關工項名稱逐行列表進行比對，從最小單元進行錯誤查找，通常都會抓到一些問題，可以進行後續的工項更正。\r\n\r\n\r\nFig3. 單元統計範例\r\n\r\n工項更正\r\n工項更正則是利用單元名稱於施工紀錄表上的註記，將正確的單元材料回推至施工紀錄表上的數量，藉此更新資訊並提示使用者更正明細。\r\n有些內業人員會擔心工項更正後會影響已經製作的日報內容，希望可以透過錯誤暫存的方式，在未來填寫新的日報時做些微的增刪來調整，要點選這顆按鈕時要慎思，當然也可以在工程剛開始就先全部紀錄上去試試，有發現與契約數量不符時馬上更正，但若是遇到變更設計就沒轍，變更設計還是有可能會更改到單元材料。\r\n\r\n\r\nFig4. 工項更正範例\r\n\r\n條狀圖查看\r\n透過施工進程的拆分、進行樁號區間的繪製，搭配樁號防呆機制，能夠有效檢核施工進程的合理性，通常以灌溉排水工程為例，工序為襯底&gt;鋼筋組立&gt;大底&gt;左右牆身，此外因應施工規範要求需要以隔段施工進行，並預留模板拆除時間，從施工進度條狀圖上所登載的日期與單元名稱便可掌握整體施工順序。\r\n\r\n\r\nFig5. 條狀圖範例\r\n\r\n樁號防呆\r\n帶狀工程最容易出現的問題就是重複紀錄樁號區間，在單元統計的時只能知道目前總長度為多少，但卻無法知道區間是否重疊，尤其當工序相當複雜時，沒有將區間進行可視化更是難以判別，因此最方便的方式便是在填寫樁號時就先判定是否有重複，重複的原因可能是起始樁號位於既設樁號區間(A)、結束樁號位於既設樁號區間(B)、起訖樁號包含既設樁號區間(C)。\r\n\r\n\r\nFig6. 樁號區間衝突情境\r\n\r\n\r\n程式碼運作上會先把樁號轉成數字再進行區間判斷，節錄自我的Github\r\n\r\nFunction TranLoc(ByVal Data As String) As Double&#x27;樁號型態轉成可計算之樁號tmp = split(Data, &quot;+&quot;)If UBound(tmp) = -1 Or Data = &quot;&quot; Then Exit Function &#x27; TranLoc = CDbl(Data): Exit Functiontloc = tmp(0) &#x27;千位數dloc = tmp(1)If dloc Like &quot;*(*&quot; Then    tmp2 = split(dloc, &quot;(&quot;)    If tmp2(0) Like &quot;*.*&quot; Then        tmp3 = split(tmp2(0), &quot;.&quot;)        dloc = tmp3(0) + tmp3(1) / 10        Else            dloc = tmp2(0)        End If        If dloc &gt; 1000 Then Exit Function    End IfFor i = 1 To Len(tloc)    loc_ch = mid(tloc, i, 1)    If IsNumeric(loc_ch) Then ref = ref &amp; loc_chNextTranLoc = CDbl(ref) * 1000 + CDbl(dloc)    End FunctionFunction IsRecLocPass(ByVal rec_loc As String, ByVal item_loc As String) &#x27;, ByVal r As Integer)IsRecLocPass = FalseDim myfunc As New clsMyfunctiontmp = split(rec_loc, &quot;~&quot;)rec_sloc = myfunc.TranLoc(tmp(0))rec_eloc = myfunc.TranLoc(tmp(1))tmp2 = split(item_loc, &quot;~&quot;)item_sloc = myfunc.TranLoc(tmp2(0))item_eloc = myfunc.TranLoc(tmp2(1))If item_sloc &gt;= rec_sloc And item_sloc &lt; rec_eloc Then    err_prompt = &quot;第&quot; &amp; r &amp; &quot;列衝突=&gt;紀錄起點【&quot; &amp; tmp2(0) &amp; &quot;】已包含於本次填報【&quot; &amp; rec_loc &amp; &quot;】&quot;    If err_prompt &lt;&gt; &quot;&quot; Then p = p &amp; err_prompt &amp; vbNewLineEnd IfIf item_eloc &gt; rec_sloc And item_eloc &lt;= rec_eloc Then    err_prompt = &quot;第&quot; &amp; r &amp; &quot;列衝突=&gt;紀錄終點【&quot; &amp; tmp2(1) &amp; &quot;】已包含於本次填報【&quot; &amp; rec_loc &amp; &quot;】&quot;    If err_prompt &lt;&gt; &quot;&quot; Then p = p &amp; err_prompt &amp; vbNewLineEnd IfIf rec_sloc &gt;= item_sloc And rec_sloc &lt; item_eloc Then    err_prompt = &quot;第&quot; &amp; r &amp; &quot;列衝突=&gt;填報起點【&quot; &amp; tmp(0) &amp; &quot;】已包含於舊有紀錄【&quot; &amp; item_loc &amp; &quot;】&quot;    If err_prompt &lt;&gt; &quot;&quot; Then p = p &amp; err_prompt &amp; vbNewLineEnd IfIf rec_eloc &gt; item_sloc And rec_eloc &lt;= item_eloc Then    err_prompt = &quot;第&quot; &amp; r &amp; &quot;列衝突=&gt;填報終點【&quot; &amp; tmp(1) &amp; &quot;】已包含於舊有紀錄【&quot; &amp; item_loc &amp; &quot;】&quot;    If err_prompt &lt;&gt; &quot;&quot; Then p = p &amp; err_prompt &amp; vbNewLineEnd IfIf p = &quot;&quot; Then IsRecLocPass = TrueEnd Function\r\n","categories":["專案開發"],"tags":["Excel VBA","監造報表"]},{"title":"縱斷面插旗文字重疊問題","url":"/posts/2767553795/","content":"🙌前言\r\n👉縱斷面發展來源\r\nAutoCAD VBA\r\n縱斷面繪製自動化\r\n🐞開發過程中的小問題\r\n縱斷面繪製時會針對需要文字說明的樁號進行插旗繪製，可能會造成插旗文字出現重疊的原因有兩個\r\n\r\n插旗說明樁號距離太近(0+200、0+205)\r\n繪製X軸比例太小(1:1000 vs 1:5000)\r\n\r\n繪製過程會考量圖紙輸出的舒適度，最小字高通常會以3.4.5為原則，文字說明會固定以30度呈現\r\n\r\n當距離太近時可以透過調整X軸比例讓間距拉開，橫向會重疊的時候就進行上下位移，方便讀者觀看。\r\n\r\n因此本篇就是要透過VBA抓取說明文字的外框及下線，自動調整文字重疊內容，以下進行說明:\r\n\r\n\r\n📌範例說明\r\n\r\n\r\nFig1. 插旗文字說明\r\n\r\n🔷流程解說\r\n一般插旗文字都是屬於旋轉至第一象限的內容(0度~90度)\r\n\r\n透過CAD VBA內建指令GetBoundingBox找到邊界點。\r\n透過幾何圖形學及三角函數關係進行列式。\r\n用一元二次聯立方程式解析參數。\r\n代回原本第一象限的正確點位。\r\n引入clsACAD進行LINE物件繪製。\r\n\r\n\r\n🌟幾何關係\r\n\\[ Hcos\\theta+Lsin\\theta=Y_1-Y_0=const.\r\n\\] \\[\r\nHsin\\theta+Lcos\\theta=X_1-X_0=const. \\]\r\n正確角點:\r\n\r\n\r\n\r\n點名\r\nX座標\r\nY座標\r\n\r\n\r\n\r\n\r\n左下\r\n\\[ X_0+Hsin\\theta \\]\r\n\\[ Y_0 \\]\r\n\r\n\r\n右下\r\n\\[ X_1 \\]\r\n\\[ Y_1-Hcos\\theta \\]\r\n\r\n\r\n左上\r\n\\[ X_0 \\]\r\n\\[ Y_0+Hcos\\theta \\]\r\n\r\n\r\n右上\r\n\\[ X_1-Hsin\\theta \\]\r\n\\[ Y_1 \\]\r\n\r\n\r\n\r\n\r\n\r\nFig2. 文字外框、點位幾何關係\r\n\r\n\r\n\r\n\r\nFig3. 上下底線繪製成果\r\n\r\n⚡程式碼\r\n模組(module)\r\nSub test_getBoundingBox()    &#x27;適用於第一象限    Dim CAD As New clsACAD    Dim L As Double    Dim H As Double    Set sset2 = CAD.CreateSSET()    Set entobj = sset2(0)        rotate_degree = entobj.Rotation * 180 / 3.14        Call entobj.GetBoundingBox(Min, Max)        X0 = Min(0)    Y0 = Min(1)    X1 = Max(0)    Y1 = Max(1)        Call CAD.AddPoint(Min)    Call CAD.AddPoint(Max)        &#x27;---一元二次聯立方程式---        a1 = Sin(rotate_degree / 180 * 3.14)    b1 = Cos(rotate_degree / 180 * 3.14)    c1 = Y1 - Y0        a2 = Cos(rotate_degree / 180 * 3.14)    b2 = Sin(rotate_degree / 180 * 3.14)    c2 = X1 - X0        Call SolveLinearEquations(a1, b1, c1, a2, b2, c2, L, H)        &#x27;------底線------        Xpt_LD = X0 + H * Sin(rotate_degree / 180 * 3.14)    Ypt_LD = Y0        Xpt_RD = X1    Ypt_RD = Y1 - H * Cos(rotate_degree / 180 * 3.14)        Call CAD.AddLineCO(Xpt_LD, Ypt_LD, Xpt_RD, Ypt_RD)        &#x27;-------頂線------        Xpt_LU = X0    Ypt_LU = Y0 + H * Cos(rotate_degree / 180 * 3.14)        Xpt_RU = X1 - H * Sin(rotate_degree / 180 * 3.14)    Ypt_RU = Y1        Call CAD.AddLineCO(Xpt_LU, Ypt_LU, Xpt_RU, Ypt_RU)    End SubFunction SolveLinearEquations(ByVal a1 As Double, ByVal b1 As Double, ByVal c1 As Double, ByVal a2 As Double, ByVal b2 As Double, ByVal c2 As Double, ByRef x As Double, ByRef y As Double) As Boolean    Dim determinant As Double        determinant = a1 * b2 - a2 * b1        If determinant = 0 Then        SolveLinearEquations = False    Else        x = (c1 * b2 - c2 * b1) / determinant        y = (a1 * c2 - a2 * c1) / determinant        SolveLinearEquations = True            End If    End Function\r\n物件類別模組(clsACAD)\r\nPrivate mo As ObjectPrivate pa As ObjectPublic acadDoc As ObjectPublic CADVer As StringPrivate Sub Class_Initialize()strCAD = &quot;AutoCAD.application&quot;CADVer = &quot;AUTOCAD&quot;Call CADInit(strCAD)End SubPrivate Sub CADInit(ByVal strCAD As String)On Error Resume NextSet acadApp = GetObject(, strCAD) &#x27;查看安裝If Err &lt;&gt; 0 Then Set acadApp = CreateObject(strCAD)acadApp.Visible = TrueOn Error GoTo 0Set mo = acadApp.ActiveDocument.ModelSpaceSet pa = acadApp.ActiveDocument.PaperSpaceSet acadDoc = acadApp.ActiveDocumentEnd SubFunction CreateSSET(Optional ByVal sname As String = &quot;SS1&quot;, Optional ByVal ftypetmp As Variant = &quot;&quot;, Optional ByVal fdatatmp As Variant = &quot;&quot;)&#x27;****PorgeCAD中似乎沒辦法做到過濾的條件?*****&#x27;0:object type&#x27;2:object name&#x27;8:layer name&#x27;62:color number(0 to 256)Dim FilterType() As IntegerDim FilterData() As VariantOn Error Resume Next: acadDoc.SelectionSets(sname).Delete: On Error GoTo 0Set sset = acadDoc.SelectionSets.Add(sname)If ftypetmp = &quot;&quot; Then    sset.SelectOnScreen    Else    ft = Split(ftypetmp, &quot;,&quot;)    fd = Split(fdatatmp, &quot;,&quot;)        ReDim FilterType(0 To UBound(ft))    ReDim FilterData(0 To UBound(fd))        For i = 0 To UBound(ft)            FilterType(i) = ft(i)        FilterData(i) = fd(i)            Next        sset.SelectOnScreen FilterType, FilterData    End IfSet CreateSSET = ssetEnd FunctionFunction AddPoint(pt) As ObjectIf CADVer = &quot;ICAD&quot; Then    Set AddPoint = mo.AddPointEntity(tranPoint(pt))Else    Set AddPoint = mo.AddPoint(tranPoint(pt))End IfEnd FunctionFunction AddLineCO(X1, Y1, X2, Y2) As ObjectDim spt(2) As DoubleDim ept(2) As Doublespt(0) = X1: spt(1) = Y1ept(0) = X2: ept(1) = Y2Set AddLineCO = AddLine(spt, ept)End FunctionFunction AddLine(spt, ept) As ObjectSet AddLine = mo.AddLine(tranPoint(spt), tranPoint(ept))End Function&#x27;=============transform ICAD about point and points======================Function tranPoint(ByVal CADpt)If CADVer &lt;&gt; &quot;ICAD&quot; Then tranPoint = CADpt: Exit FunctionSet tranPoint = Library.CreatePoint(CADpt(0), CADpt(1), CADpt(2))End Function\r\n👉後續利用\r\n確認下一文字外框點是否位於這次文字框中，進行重疊文字判識，如不符合則再上下位移即可。\r\nFunction checkPtFromBorders(midX,midY,BorderPTs) as booleanBorder_minX = CDbl(BorderPTs(0))Border_minY = CDbl(BorderPTs(1))Border_maxX = CDbl(BorderPTs(2))Border_maxY = CDbl(BorderPTs(3))If midX &gt;= Border_minX And midX &lt;= Border_maxX And midY &gt;= Border_minY And midY &lt;= Border_maxY Then        checkPtFromBorders = true    Exit For    End IfEnd Function\r\n","categories":["基本概念"],"tags":["AutoCAD VBA","ProgeCAD VBA"]},{"title":"監造日報表設計規劃","url":"/posts/168906144/","content":"🙌前言\r\n\r\n監造報表為公共工程三級品管制度下的必備表單\r\n\r\n依公共工程施工品質管理作業要點第十一、監造單位及其所派駐現場人員工作重點如下:(十五)依規定填報監造報表\r\n\r\n格式來源請參考監造報表(附表五)\r\n\r\n監造報表所需登載內容除基本資料外，其餘重點簡述如下:\r\n\r\n工程進度\r\n數量計算\r\n施工抽查\r\n品質試驗\r\n文件管理\r\n\r\n本篇為我所開發的監造日報表VBA的一些專案設計架構簡述，\r\n有興趣請繼續觀看...\r\n\r\n\r\n\r\nFig1. 監造報表畫面\r\n\r\n\r\n🚸工程進度\r\n預定進度\r\n\r\n此處的紀錄內容為提報施工計畫書時的施工進度網圖內容\r\n\r\n複雜的案子可能會是箭線網圖畫、簡單的案子通常用甘特圖，不管如何，最底下的累積進度通常每半個月會有一個數值，這就是報表上所需的預定進度，如果比較簡單的案子可以用內插值的方式去補數值。\r\n累積進度以內插方式進行時，在某些大案子中可能無法貼近預排進度，建議透過構造物的拆項預排，由構造物的單元分析去換算契約價金，再以該價金進行預定進度的換算會比較準確。\r\n\r\n實際進度\r\n\r\n按契約詳細表項目已經抽查完成部分所換算之金額佔契約價金之金額百分比。\r\n\r\n有些業主會要求計算工程進度分母時，不要計入廠商管理費及營業稅，但卻又要求要顯示於監造報表的詳細表上...\r\n突發情形\r\n在工程執行期間，可能有諸多原因導致展延工期、停工等情況，此時也需要重新調整施工網圖並將正確之預定進度紀錄上去。\r\n\r\n✏️數量計算\r\n\r\n對應於 一、工程進行情況(含約定之重要施工項目及數量)\r\n\r\n在監造計畫書中會提及重要施工項目及數量，可以用這部分的內容來進行紀錄\r\n紀錄內容可能會有以下情況\r\n\r\n紀錄累積數量不為0的契約項目(即部分呈現)\r\n紀錄契約數量不為0的契約項目(即全部呈現)\r\n紀錄當日施作內容，再另檢附第二聯詳細表(即全部呈現在第二聯)\r\n\r\n這部分的差異變化比較大，我的專案都會把這些邏輯建立起來，到時再來選要哪一種即可\r\n\r\n⚒️施工抽查\r\n\r\n對應於\r\n二、監督依照設計圖說及核定施工圖說施工(含約定之檢驗停留點及施工抽查等情形)\r\n\r\n依照監造計畫書所提及的檢驗頻率進行檢驗停留點抽查或隨機抽查。\r\n紀錄內容為抽查紀錄表的編號、項目、合格與否。\r\n很多委員都會認為紀錄表就是要用手寫才有FU，因此在進行施工抽查的歸檔時，會需要再另外掃描。\r\n📋品質試驗\r\n\r\n對應於\r\n三、查核材料規格及品質(含約定之檢驗停留點、材料設備管制及檢(試)驗等抽驗情形)\r\n\r\n依照品質計畫書所提及的材料設備品管頻率進行廠驗或抽驗。\r\n紀錄內容為材料設備管制名稱、契約數量、已作數量。\r\n這部分跟施工抽查有點類似，試驗報告通常也會是紙本的內容，因此在品質試驗的歸檔，一樣也是要另外掃描起來。\r\n📚文件管理\r\n\r\n對應於\r\n五、其他約定監造事項(含重要事項紀錄、主辦機關指示及通知廠商辦理事項)\r\n\r\n\r\n機關公文(變更、新增、展延、停工、材料、估驗、行政文件...等)\r\n督導查核\r\n會議記錄\r\n交辦事項\r\n其他覺得應該要紀錄的內容\r\n\r\n每個工程案應該都會有無數個會議、無數個來往公文，無論是對業主還是對廠商都是，而這些都會需要紀錄在監造報表中\r\n預期每個對工程案不了解的人，透過翻找監造報表，就能夠了解整個工程的大致內容，這就是撰寫的主要目的。\r\n💥監造報表VBA系統架構圖\r\n\r\n\r\nFig2. 監造報表VBA系統架構圖\r\n\r\n","categories":["專案開發"],"tags":["Excel VBA","監造報表"]},{"title":"道路標線標註彙總VBA","url":"/posts/2735421494/","content":"前言\r\n道路標線，乃依據道路交通標誌標線號誌設置規則所繪製而成，於CAD上常用聚合線、陣列、圖塊來呈現，平面圖上繪製、標註、數量彙總，最後讓施工廠商據以施工，，無論是標線或圖塊皆需要換算其施作面積(m2)計價。\r\n\r\n操作對象\r\n\r\n\r\n聚合線\r\n\r\n路面邊線、禁止臨時停車線、禁止停車線...等\r\n\r\n陣列\r\n\r\n枕木紋行人穿越線、路口行車引導線...等\r\n\r\n圖塊\r\n\r\n右轉箭頭、左轉箭頭、機車停等區...等\r\n\r\n\r\n工作流程中最繁瑣的步驟針對每個標線標示其線名及長度，再根據各個不同線名登打數量公式，本篇文章介紹如何透過AutoCAD\r\nVBA的方式，將各個操作對象原先的工作流程進行簡化。\r\n\r\n預期成果\r\n\r\n\r\nFig1. 標線所需標示內容\r\n\r\n繪製方式\r\n線段繪製\r\n線、聚合線都是屬於線段的一種，但對於VBA而言，他們的座標物件不同，線的座標為StartPoint及EndPoint，聚合線的座標為Coordinates，建議在使用上都用聚合線(指令為PL)作為畫線的方式。\r\n圖層設定\r\nVBA中可以透過SelectionSet框選CAD物件，並針對各個物件進行屬性讀取，包含圖層、座標、長度...等等，如果將所有的物件都拉進來，在計算上會較難處理，因此要讓使用者在繪製線段的過程，將圖層名稱設置前綴以利程式判讀，再將操作對象設定為此圖層名。\r\n\r\n舉例: 長度_禁止停車線 舉例: 陣列_枕木紋行穿線\r\n\r\n執行步驟\r\n\r\n確認操作對象為聚合線，並且圖層名稱為長度_{線名}\r\n確認操作對象為陣列部分，其圖層名稱為陣列_{線名}\r\n點選按鈕長度標示\r\n移動至CAD框選所有長度內容\r\n由下而上依序點選標線文字出現位置\r\n點選按鈕長度彙總\r\n移動至CAD點選長度彙總出現位置\r\n\r\n影片DEMO\r\n\r\n\r\n","categories":["專案開發"],"tags":["AutoCAD VBA"]},{"title":"跨系統網頁自動化填寫做法","url":"/posts/706100979/","content":"背景\r\n上級單位需要管考目前管理處執行中的工程案件，建立農田水利設施工程管考系統(以下稱外部系統)供各管理處進行填報，然而管理處於前期便已建立工程管考E化系統(以下稱內部系統)做為內部資料的收集，監造單位需要在內部系統先進行填寫後，再由管理單位進入外部系統將內部系統資料再重新謄打一次。\r\n為進行外部系統資料填報，最理想的狀況當然是能透過內部系統自身觸發器(Trigger)執行外部系統API發送，內部系統資料庫異動時也能一併修改到外部系統的內容。\r\n然而今日沒有外部系統API使用，需要另外想辦法從原本的資料庫撈取資料進行網頁自動化填報才能省事，首先要確認內部系統的資料庫欄位是否能進行資料梳理，再者確認網頁自動化填報做法為何。\r\n\r\n\r\n外部系統操作畫面\r\n\r\n\r\nFig1. 新增計畫工程\r\n\r\n\r\n\r\n\r\nFig2. 計畫工程成果\r\n\r\n\r\n\r\n\r\nFig3. 新增分項工程\r\n\r\n\r\n\r\n\r\nFig4. 分項工程成果\r\n\r\n\r\n\r\n\r\nFig5. 工程概要表填寫欄位(一)\r\n\r\n\r\n\r\n\r\nFig6. 工程概要表填寫欄位(二)\r\n\r\n內部系統資料庫\r\n經查外部系統相關資料欄位分散於內部系統資料庫(SQLserver)各個不同資料表，雖然透過JOIN的方式也可以產出一個滿接近可以直接輸入的成果，但筆者對於資料庫的操作經驗尚顯不足，期程迫在眉睫，只好先將內部系統相關各表先匯出成excel，再透過熟悉的VBA進行資料梳理，整理成未來網頁自動化填報待載入的內容。\r\n為不影響既有資料庫運作，先請各同仁將欲填報資料內容填寫完後進行資料庫備份，於本地端重啟一個資料庫服務並導入備份內容進行後續操作。\r\n資料梳理細節\r\n\r\n\r\n\r\n外部系統頁面\r\n欄位名稱\r\n內部系統資料表\r\n\r\n\r\n\r\n\r\n工程研提\r\n工程編號(自訂)\r\nAPMFORM\r\n\r\n\r\n\r\n工程名稱\r\n\r\n\r\n\r\n\r\n鄉鎮市\r\n\r\n\r\n\r\n\r\n水路名稱列表(自訂)\r\n\r\n\r\n\r\n分項工程\r\n水路名稱\r\nMONFORM\r\n\r\n\r\n工程概要表\r\n受益面積\r\n\r\n\r\n\r\n\r\n改善類別\r\n\r\n\r\n\r\n\r\n改善效益\r\n\r\n\r\n\r\n\r\n用地情形\r\n\r\n\r\n\r\n\r\n規劃情形\r\n\r\n\r\n\r\n\r\n相關情形\r\n\r\n\r\n\r\n\r\n農民意願\r\n\r\n\r\n\r\n\r\n水源情形\r\n\r\n\r\n\r\n\r\n水權情形\r\n\r\n\r\n\r\n\r\n是否需配合斷水期施工\r\n\r\n\r\n\r\n\r\n工程重要性\r\n\r\n\r\n\r\n\r\n經費概估項目\r\nMONFUND\r\n\r\n\r\n\r\n現況照片及設計簡圖\r\nMONFPIC\r\n\r\n\r\n\r\n照片處理\r\n在處理照片對映時，發現資料庫中的照片存成二進位，需先把二進位轉成圖片才有辦法進行後續處理。\r\ndef get_photos():    conn = get_db_connection()    cursor = conn.cursor()    query=&quot;&quot;&quot;    SELECT          mf.[MN_ID],        mf.[WRD_NAME],        mp.[PIC_FILE],  -- 假設你想要選擇圖片欄位        mp.[PIC_PATH]    FROM         [CMPSGS].[dbo].[MONFORM] mf    JOIN         [CMPSGS].[dbo].[MONFPIC] mp        ON mf.[MN_ID] = mp.[MN_ID]    WHERE         mf.[ADD_DT] &gt; &#x27;2024-11-01&#x27;    ORDER BY        mf.[MN_ID]&quot;&quot;&quot;    cursor.execute(query)    # 獲取列名    columns = [column[0] for column in cursor.description]        # 將結果轉換為字典列表    results = [dict(zip(columns, row)) for row in cursor.fetchall()]        # print(&quot;Results:&quot;, results)  # 新增這一行    # 將結果轉換為 DataFrame    df = pd.DataFrame(results)    for index, row in df.iterrows():                if index %3==0:            print(row[&quot;WRD_NAME&quot;])            folder_name=row[&quot;WRD_NAME&quot;]            os.makedirs(&quot;./data/&quot;+folder_name, exist_ok=True)                    with open(&quot;./data/&quot;+folder_name+&quot;/&quot;+row[&quot;WRD_NAME&quot;]+&quot;-&quot;+row[&quot;PIC_PATH&quot;], &quot;wb&quot;) as image_file:            image_file.write(row[&quot;PIC_FILE&quot;])            print(str(index)+&quot;...OK!&quot;)    cursor.close()    conn.close()        return df\r\n \r\n\r\n網頁自動化填報\r\n原本想像中的Selenium會需要從無到有開啟一個網站後開始進行資料填寫，大多數的網站都會有帳號密碼驗證機制，甚至祭出驗證碼、選擇汽車圖片、移動滑鼠到指定位置...等反爬蟲機制來確認是否為機器人，但若網頁可以被接管繞開這些機制的話，那整個資料填報作業就會很有機會讓電腦代勞，這就是寫程式的趣味來源，當然還是要小心不能點太快，否則網站可能會負荷不過來。\r\nChrome\r\n網頁瀏覽器，透過以下指令即可進行網站操作接管，需要根據自身電腦的chrome安裝路徑執行，建議將原本所開啟中的chrome畫面通通關閉後再執行以下指令。\r\n\r\nWIN10\r\n\r\n\"C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe\" –remote-debugging-port=9222\r\n\r\nWIN11\r\n\r\n\"C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe\" –remote-debugging-port=9222\r\nNOTE:如果仍然找不到瀏覽器的執行路徑，可以在原本桌面瀏覽器捷徑找尋內容\r\n\r\n\r\nFig9. 瀏覽器畫面\r\n\r\n\r\n更多細節請參考.Selenium詳細操作步驟\r\n操作DEMO\r\n\r\n\r\n","categories":["專案開發"],"tags":["Python","SQL","Selenium"]},{"title":"Selenium操作細節","url":"/posts/391727536/","content":"前言\r\n原本想像中的Selenium會需要從無到有開啟一個網站後開始進行資料填寫，大多數的網站都會有帳號密碼驗證機制，甚至祭出驗證碼、選擇汽車圖片、移動滑鼠到指定位置...等反爬蟲機制來確認是否為機器人，但若網頁可以被接管繞開這些機制的話，那整個資料填報作業就會很有機會讓電腦代勞，這就是寫程式的趣味來源，當然還是要小心不能點太快，否則網站可能會負荷不過來。\r\n\r\n使用工具\r\nChrome\r\n網頁瀏覽器，透過以下指令即可進行網站操作接管，需要根據自身電腦的chrome安裝路徑執行，建議將原本所開啟中的chrome畫面通通關閉後再執行以下指令。\r\nWIN10\r\n\"C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe\" –remote-debugging-port=9222\r\nWIN11\r\n\"C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe\" –remote-debugging-port=9222\r\nNOTE:如果仍然找不到瀏覽器的執行路徑，可以在原本桌面瀏覽器捷徑找尋內容\r\n\r\n\r\nFig1. 瀏覽器畫面\r\n\r\nSelenium\r\n目前使用為Selenium4的語法，透過分析網站的元素來進行文字輸入、文字萃取、點擊連結、循環表格取得目標欄位...等。\r\n網站接管步驟\r\n\r\n打開終端機\r\n\r\n搜尋&gt;輸入cmd\r\n\r\n輸入指令\r\n\r\n\"C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe\" –remote-debugging-port=9222\r\n\r\n開啟網站，輸入帳號密碼驗證碼後到可填寫畫面\r\n交給Selenium來進行網站自動填報作業。\r\n\r\nPython\r\nrequirements.txt\r\nseleniumpandasopenpyxl\r\nmain.py\r\n接管瀏覽器\r\nfrom selenium import webdriverfrom selenium.webdriver.chrome.options import Optionsdef init_driver():    chrome_options = Options()    chrome_options.add_experimental_option(&quot;debuggerAddress&quot;, &quot;127.0.0.1:9222&quot;)    driver = webdriver.Chrome(options=chrome_options)    return driver    #======主要介面開始======driver=init_driver()# 獲取當前網址current_url = driver.current_urlprint(&quot;當前網址:&quot;, current_url)\r\n取得網頁元素\r\n\r\n\r\n\r\n方法\r\n適用情況\r\n\r\n\r\n\r\n\r\nID\r\n用於定位具有唯一標識符的元素\r\n\r\n\r\nXPATH\r\n當元素位置不確定或無法使用其他方式定位時使用\r\n\r\n\r\nLINK_TEXT\r\n用於定位頁面上可點擊的超連結文字\r\n\r\n\r\nCSS_SELECTOR\r\n當元素的結構較為複雜或無法使用ID時使用\r\n\r\n\r\n\r\n執行網頁動作\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n操作類型\r\n方法\r\n描述\r\n\r\n\r\n\r\n\r\n文字欄位操作\r\nclear\r\n清空文字欄位的內容\r\n\r\n\r\n\r\nsendkey\r\n在文字欄位中輸入文字\r\n\r\n\r\n\r\nclick\r\n點擊文字欄位（若為可點擊的元素）\r\n\r\n\r\n選擇欄位操作\r\nselect_by_value\r\n根據選項的值來選擇\r\n\r\n\r\n\r\nselect_by_visible_value\r\n根據選項的可見文字來選擇\r\n\r\n\r\n\r\n網頁表格操作\r\ndef edit_case(driver,targetID):     select_element  = driver.find_element(By.XPATH, &#x27;//*[@id=&quot;DataTables_Table_0_length&quot;]/label/select&#x27;)    select = Select(select_element)    select.select_by_value(&quot;100&quot;)    table = driver.find_element(By.ID, &quot;DataTables_Table_0&quot;)    rows = table.find_elements(By.CSS_SELECTOR, &quot;tbody tr&quot;)    for row in rows:        cells = row.find_elements(By.CSS_SELECTOR, &quot;td&quot;)                # print(cells[0].text)                if cells[0].text==targetID:            print(cells[0].text)            edit_button = cells[3].find_element(By.CSS_SELECTOR, &quot;a&quot;)            edit_button.click()                        break\r\n刪除時之警告視窗\r\ndef check_item_by_chname(driver,ch_name,is_rebuild):    table = driver.find_element(By.ID, &quot;DataTables_Table_0&quot;)    rows = table.find_elements(By.CSS_SELECTOR, &quot;tbody tr&quot;)    for row in rows:        cells = row.find_elements(By.CSS_SELECTOR, &quot;td&quot;)        del_button=cells[3].find_element(By.CSS_SELECTOR, &#x27;a[onclick^=&quot;delConfirm&quot;]&#x27;)        del_button.click()        alert = Alert(driver)        alert.accept()  # 點擊確認        print(&quot;已經強制刪除&quot;)        \r\n圖片置換處理\r\ndef get_photo_path(ch_name):    import os    if os.path.exists(&#x27;./data/&#x27;+ch_name):        photo_list=[]        for file in os.listdir(&#x27;D:/Python/st_selenium/data/&#x27;+ch_name):            print(file)            photo_list.append(&#x27;D:/Python/st_selenium/data/&#x27;+ch_name+&quot;/&quot;+file)        return photo_listdef paste_photo(driver,photo_list):    # 定位文件上傳的 input 元素    file_input = driver.find_element(By.ID, &quot;userfile1&quot;)    file_path =photo_list[0] # 請替換成你圖片的絕對路徑    file_input.send_keys(file_path)    file_input = driver.find_element(By.ID, &quot;userfile2&quot;)    file_path =photo_list[1] # 請替換成你圖片的絕對路徑    file_input.send_keys(file_path)    file_input = driver.find_element(By.ID, &quot;userfile3&quot;)    file_path =photo_list[2] # 請替換成你圖片的絕對路徑    file_input.send_keys(file_path)# ===主要操作內容===    photo_list=get_photo_path(ch)paste_photo(driver,photo_list)    \r\n\r\n資料夾安排\r\n\r\n\r\n\r\nFig2.\r\n資料夾安排(以渠道名稱為分類)\r\n\r\n\r\n資料夾內容\r\n\r\n\r\n\r\nFig1.\r\n資料夾內容(檔案名稱取為數字方便排序進行)\r\n\r\n錯誤紀錄\r\n\r\n如果取得表格之後就要直接進行各項功能操作，會出現中止狀況，需要先把每個列的資料先儲存成list，才能根據每個list中的內容進行後續填寫、修改、儲存等功能。\r\n\r\nfor i in range(166,167):    # print(&quot;OO113T&quot;+str(i))    edit_case(driver,&quot;OO113T&quot;+str(i))    table = driver.find_element(By.ID, &quot;DataTables_Table_0&quot;)    rows = table.find_elements(By.CSS_SELECTOR, &quot;tbody tr&quot;)    ### 先把資料儲存起來        ch_list=[]        for row in rows:        cells = row.find_elements(By.CSS_SELECTOR, &quot;td&quot;)        ch=cells[1].text        ch_list.append(ch)    ### 循環每個LIST中的內容進行後續處理            for ch in ch_list:        #do something~\r\n","categories":["基本原理"],"tags":["Python","Selenium"]},{"title":"雲端空間Synology-C2-Object","url":"/posts/1168852487/","content":"前言\r\n一提到雲端空間，廣為人知的不外乎是Google\r\nDrive、DropBox、OneDrive等等知名大廠的產品，NAS(地端儲存伺服器)則大多常見為Synology群暉所主導，而本篇要介紹的Synology\r\nC2 Object則是群暉所提供的服務之一。\r\n在網路上有許多服務經過使用者對網頁進行互動，伺服器背後通常都會有一個以上的資料庫及檔案空間進行儲存，而本篇\r\nSynology C2 Object\r\n就是指檔案存存放空間，只因為它屬於雲端所提供的服務，因此叫做雲端空間。\r\n未來只要有建立好連接的參數，就可以透過API進行呼叫存放、取用，有關檔案空間申請主要目的為取得下列重要參數，以備未來進行檔案空間串接。\r\n\r\nBUCKET_NAME\r\nendpoint_url\r\naws_access_key_id\r\naws_secret_access_key\r\n\r\n\r\n\r\n申請流程\r\n點擊登入\r\n可以綁定Google或者自行申請一組帳號密碼\r\n\r\n\r\nFig1.多種登入方式\r\n\r\n登入畫面\r\n\r\n\r\nFig2.入口畫面\r\n\r\n選取C2 Object Storage\r\n\r\n\r\nFig3.選擇C2 Object\r\nStorage服務\r\n\r\n點選開始使用15GB免費空間\r\n\r\n\r\nFig4.開始使用\r\n\r\n點選服務條款\r\n\r\n\r\nFig5.服務條款\r\n\r\n建立儲存體\r\n\r\n\r\nFig6.建立儲存體\r\n\r\n\r\n\r\nFig7.建立存取金鑰\r\n\r\n\r\n\r\nFig8.預設就好\r\n\r\n取得金鑰ID與私密金鑰\r\n\r\n\r\nFig9.存取金鑰與私密金鑰\r\n\r\n\r\naws_access_key_id\r\naws_secret_access_key\r\n\r\n確認儲存體名稱及端點\r\n\r\n\r\nFig9.儲存體名稱及端點\r\n\r\n\r\nBUCKET_NAME\r\nendpoint_url\r\n\r\n結論\r\n申請完畢之後就可以用Python中Boto3的套件進行檔案空間的儲存、下載了，未來要開發相關網站的時候也多了一個地方可以放置檔案。\r\n開發範例\r\nimport boto3from botocore.exceptions import NoCredentialsError, PartialCredentialsErrorimport streamlit as stimport pandas as pd# 請填入你的 bucket 名稱BUCKET_NAME = &#x27;hankbucket&#x27;# 設定 S3 客戶端def get_s3_client():    return boto3.client(        &#x27;s3&#x27;,        endpoint_url=&#x27;https://OOOOO.OO.synologyc2.net&#x27;,        aws_access_key_id=&#x27;twmOPTcq8MAxXaNVMOOOOOOOOO&#x27;,        aws_secret_access_key=&#x27;n7O1Pys3nyp15T5OGOOOOOOO&#x27;    )# 列出所有檔案def list_files(bucket_name):    s3 = get_s3_client()    try:        response = s3.list_objects_v2(Bucket=bucket_name)        files = response.get(&#x27;Contents&#x27;, [])        # print(files)        file_list = []        for file in files:            file_info = &#123;                &quot;File Name&quot;: file[&#x27;Key&#x27;],                &quot;Size (bytes)&quot;: file[&#x27;Size&#x27;],                &quot;Last Modified&quot;: file[&#x27;LastModified&#x27;],                &quot;ETag&quot;: file[&#x27;ETag&#x27;]            &#125;            file_list.append(file_info)        return file_list    except (NoCredentialsError, PartialCredentialsError) as e:        return str(e)# 上傳檔案def upload_file(bucket_name, file_path, object_name):    s3 = get_s3_client()    try:        with open(file_path, &#x27;rb&#x27;) as f:            s3.upload_fileobj(f, bucket_name, object_name)        return f&quot;Uploaded &#123;object_name&#125; to &#123;bucket_name&#125;&quot;    except Exception as e:        return str(e)# 上傳檔案並獲取唯一碼def upload_file_and_get_etag(bucket_name, file_path, object_name):    s3 = get_s3_client()    try:        with open(file_path, &#x27;rb&#x27;) as f:            response = s3.upload_fileobj(f, bucket_name, object_name)        return response[&#x27;ETag&#x27;]    except Exception as e:        return str(e)# 上傳檔案並顯示唯一碼def upload_new_file():    uploaded_file = st.file_uploader(&quot;Choose a file&quot;)    if uploaded_file is not None:        with open(uploaded_file.name, &quot;wb&quot;) as f:            f.write(uploaded_file.getbuffer())        etag = upload_file_and_get_etag(BUCKET_NAME, uploaded_file.name, uploaded_file.name)        st.write(f&quot;Uploaded &#123;uploaded_file.name&#125; with ETag: &#123;etag&#125;&quot;)# 刪除檔案def delete_file(bucket_name, object_name):    s3 = get_s3_client()    try:        s3.delete_object(Bucket=bucket_name, Key=object_name)        return f&quot;Deleted &#123;object_name&#125; from &#123;bucket_name&#125;&quot;    except Exception as e:        return str(e)# 列出所有檔案def list_all_files():    files = list_files(BUCKET_NAME)    if files:        # print(files)        file_list = [&#123;&quot;File Name&quot;: file[&#x27;File Name&#x27;],                       &quot;Etag&quot;: file[&#x27;ETag&#x27;],                       &quot;Size (bytes)&quot;: file[&#x27;Size (bytes)&#x27;], &quot;Last Modified&quot;: file[&#x27;Last Modified&#x27;]&#125;                         for file in files]        df = pd.DataFrame(file_list)        return df    else:        return pd.DataFrame(columns=[&quot;File Name&quot;, &quot;ETag&quot;])# 下載檔案def download_file(bucket_name, object_name):    s3 = get_s3_client()    try:        with open(object_name, &#x27;wb&#x27;) as f:            s3.download_fileobj(bucket_name, object_name, f)        return f&quot;Downloaded &#123;object_name&#125; from &#123;bucket_name&#125;&quot;    except Exception as e:        return str(e)# 下載檔案def download_selected_file(selected_file):    response = download_file(BUCKET_NAME, selected_file)    st.write(response)# Streamlit app layoutst.title(&quot;Synology C2 Storage Management with S3 API&quot;)st.header(&quot;List and Download Files&quot;)files_df = list_all_files()st.dataframe(files_df)if not files_df.empty:    selected_file = st.selectbox(&quot;Select a file to download&quot;, files_df[&quot;File Name&quot;].tolist())    if st.button(&quot;Download File&quot;):        download_selected_file(selected_file)st.header(&quot;Upload a New File and Get Unique ETag&quot;)upload_new_file()\r\n","categories":["基本概念"],"tags":["Python","API"]},{"title":"Clever cloud postgreSQL申請流程","url":"/posts/3965020317/","content":"前言\r\n資料庫介紹\r\n資料庫(此為關聯式資料庫)的主要用途是為資料提供一個儲存空間，讓使用者可以進行讀取、寫入、修改、刪除等功能。\r\n關聯式資料庫常見如下:\r\n\r\nMySQL 和 PostgreSQL 是開源且廣泛使用的選擇，適合中小型應用程式\r\nMicrosoft SQL Server 通常用於大型企業解決方案\r\nSQLite 則是一個輕量級的資料庫，適合用於嵌入式應用或單機應用。\r\n\r\n申請雲端服務\r\n本篇文章介紹的部分為Clever Cloud 所提供無料的 256MB PostgreSQL\r\n服務，適合需要基本資料庫功能的小型應用程式。\r\n重要參數\r\n當您成功註冊並啟用 PostgreSQL 服務後，只需要取得一項重要參數\r\nCONNECTION_URI即可開始使用雲端資料庫。\r\n\r\n進入網站\r\nClever-Coud\r\n註冊\r\n\r\n\r\nFig1. 登入頁面\r\n\r\n註冊方式:\r\n\r\nemail\r\nGithub\r\n\r\n\r\n\r\nFig2. 登入頁面2\r\n\r\n入口畫面\r\n\r\n\r\nFig3. 入口畫面\r\n\r\n需要先去驗證你的email是否正確\r\n\r\n\r\nFig4. 驗證信內容\r\n\r\n新增一個addon\r\n\r\n\r\nFig5. 新建按鈕\r\n\r\n選取PostgreSQL\r\n\r\n\r\nFig6. 資料庫服務\r\n\r\n指定計畫名稱為DEV，最右下角有一個next\r\n\r\n\r\nFig7. 選擇內容DEV\r\n\r\n填寫名稱\r\n\r\n\r\nFig8. 服務名稱\r\n\r\n服務成功建立\r\n\r\n\r\nFig9. 資料庫管理介面\r\n\r\n\r\n結論\r\n上述結論就可以得到一組 Connection\r\nURI，這就可以拿來當作其他網站的資料庫使用了!!\r\n\r\n256MB雖然沒有很大，但是可以塞大概58萬條純文字紀錄，一般開發上來說滿夠的。\r\n\r\n串接範例\r\nfrom sqlalchemy import create_engine, Column, Integer, String, DateTime, JSON, UniqueConstraint, ForeignKeyfrom sqlalchemy.orm import sessionmaker,declarative_base, relationshipfrom datetime import datetimefrom sqlalchemy.orm import Sessionfrom sqlalchemy import select,textimport pytz# PostgreSQL 配置(改成你的)DATABASE_URL=&quot;postgresql://uizbhnmkOOOOOO:K0r18XtU1Nb2yGwC1SfwoOOOOOOO@bngbuvea6wkwlOOOg-postgresql.services.clever-cloud.com:50OOO/bngbuvea6wOOOOOOhzig&quot;engine = create_engine(DATABASE_URL)SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)# DATABASE_URL2=&quot;sqlite:///members.db&quot;# engine2 = create_engine(DATABASE_URL2)# SessionLocal2 = sessionmaker(autocommit=False, autoflush=False, bind=engine2)    Base = declarative_base()# 定義數據庫模型class Photo(Base):    __tablename__ = &#x27;photos_backup&#x27;    id = Column(Integer, primary_key=True, index=True)    user_id = Column(String(255))    group_id = Column(String(255))    photo_name = Column(String(255))    photo_url = Column(String(255))    photo_thumbnail_url = Column(String(255))    place_tmp=  Column(String(50))    created_time = Column(DateTime, default=lambda: datetime.now(pytz.timezone(&#x27;Asia/Taipei&#x27;)))    photo_properties = Column(JSON)    photo_image_hash = Column(String(255))#, unique=True, nullable=False)Base.metadata.create_all(bind=engine)def add_photo(user_id, group_id, photo_name, photo_url, photo_thumbnail_url, place_tmp, photo_properties, photo_image_hash):    # 創建一個新的數據庫會話    db: Session = SessionLocal()    try:        # 創建 Photo 實例        new_photo = Photo(            user_id=user_id,            group_id=group_id,            photo_name=photo_name,            photo_url=photo_url,            photo_thumbnail_url=photo_thumbnail_url,            place_tmp=place_tmp,            photo_properties=photo_properties,            photo_image_hash=photo_image_hash        )                # 將新實例添加到會話中        db.add(new_photo)                # 提交會話以保存更改        db.commit()                # 刷新會話以獲取新資料的 ID        db.refresh(new_photo)                print(f&quot;新增照片資料成功，ID: &#123;new_photo.id&#125;&quot;)    except Exception as e:        # 如果發生錯誤，回滾事務        db.rollback()        print(f&quot;新增照片資料失敗: &#123;e&#125;&quot;)    finally:        # 關閉會話        db.close()def get_all_photos():    # 創建一個新的數據庫會話    db: Session = SessionLocal()    try:        # 獲取所有照片資料        photos = db.query(Photo).all()        return photos    except Exception as e:        # 如果發生錯誤，回滾事務        db.rollback()        print(f&quot;獲取照片資料失敗: &#123;e&#125;&quot;)    finally:        # 關閉會話        db.close()def delete_photo_by_id(photo_id):    # 創建一個新的數據庫會話    db: Session = SessionLocal()    try:        # 透過 ID 刪除照片資料        db.query(Photo).filter(Photo.id == photo_id).delete()        db.commit()        print(f&quot;刪除照片資料成功，ID: &#123;photo_id&#125;&quot;)    except Exception as e:        # 如果發生錯誤，回滾事務        db.rollback()        print(f&quot;刪除照片資料失敗: &#123;e&#125;&quot;)    finally:        # 關閉會話        db.close()# 使用範例add_photo(    user_id=&quot;user_123&quot;,    group_id=&quot;group_456&quot;,    photo_name=&quot;example_photo.jpg&quot;,    photo_url=&quot;http://example.com/photo.jpg&quot;,    photo_thumbnail_url=&quot;http://example.com/photo_thumb.jpg&quot;,    place_tmp=&quot;Taipei&quot;,    photo_properties=&#123;&quot;description&quot;: &quot;A beautiful sunset.&quot;&#125;,    photo_image_hash=&quot;hash_value_example&quot;)photos = get_all_photos()print(photos)delete_photo_by_id(1)session = SessionLocal()try:    # 使用原生 SQL 執行 ALTER TABLE，並使用 text() 包裝 SQL 語句    # session.execute(text(&quot;ALTER TABLE photos_backup ADD COLUMN description TEXT&quot;))    session.execute(text(&quot;DROP TABLE IF EXISTS photos_backup&quot;))    session.commit()except Exception as e:    print(f&quot;出錯了: &#123;e&#125;&quot;)    session.rollback()finally:    session.close()\r\n遭遇問題紀錄\r\n當介面的PG\r\nStudio無法登入時，會無法操作資料庫中的所有內容，儘管用pgadmin來進行也會出現'ServerManager'沒有存在user_info之類的錯誤訊息。\r\n我用streamlit建立一個介面去進行操作也無法成功(後來操作成功了!?)\r\nVScode進行連接時會出現pg_table無法顯示\r\n總言之就是一個很無解的過程，看來雲端服務也不一定是好的方案，能夠完整掌握會比較安全\r\n","categories":["基本概念"],"tags":["SQL"]}]